
[package.json]

```json
{
  "name": "folie",
  "private": true,
  "license": "MIT",
  "type": "module",
  "scripts": {
    "build": "turbo build",
    "build:pkg": "turbo build --filter=./packages/* --filter=!./packages/cobalt --filter=!./packages/gate_next --filter=!./packages/gate_tan && turbo build --filter=./packages/cobalt --filter=./packages/gate_next --filter=./packages/gate_tan",
    "dev": "turbo dev",
    "dev:playground": "turbo dev --filter=./playground/*",
    "lint": "turbo lint",
    "typecheck": "turbo typecheck",
    "format": "turbo format",
    "check": "turbo format && turbo lint typecheck",
    "changelog": "nr build:pkg && changeset add",
    "release": "changeset version && ./release.ts && changeset publish ; ./release.ts --cleanup",
    "dev:docs": "vitepress dev docs",
    "build:docs": "vitepress build docs",
    "preview:docs": "vitepress preview docs"
  },
  "devDependencies": {
    "@changesets/cli": "^2.27.11",
    "prettier": "^3.2.5",
    "turbo": "^2.3.3",
    "typescript": "^5.6"
  },
  "dependencies": {
    "vitepress": "^1.5.0"
  },
  "engines": {
    "node": ">=20"
  },
  "resolutions": {
    "strtok3": "8.0.1"
  },
  "pnpm": {
    "overrides": {
      "strtok3": "8.0.1"
    }
  },
  "folie": {},
  "packageManager": "pnpm@9.15.1+sha512.1acb565e6193efbebda772702950469150cf12bcc764262e7587e71d19dc98a423dff9536e57ea44c49bdf790ff694e83c27be5faa23d67e0c033b583be4bfcf"
}

```
-------------------------------
[packages/blueprint/bin/playground.ts]

```ts
console.log('Welcome to playground!')

```
-------------------------------
[packages/blueprint/bin/test.ts]

```ts
import { assert } from '@japa/assert'
import { configure, processCLIArgs, run } from '@japa/runner'

processCLIArgs(process.argv.splice(2))

configure({
  files: ['tests/**/*.spec.ts'],
  plugins: [assert()],
})

run()

```
-------------------------------
[packages/blueprint/commands/generate.ts]

```ts
import { BaseCommand, flags } from '@adonisjs/core/ace'
import type { CommandOptions } from '@adonisjs/core/types/ace'
import { Project, QuoteKind } from 'ts-morph'
import { fileURLToPath } from 'node:url'
import { existsSync, mkdirSync, readdirSync, rmSync } from 'node:fs'
import { RouteJSON } from '@adonisjs/core/types/http'
import { parseBindingReference, slash } from '@adonisjs/core/helpers'
import stringHelpers from '@adonisjs/core/helpers/string'
import { dirname, relative } from 'node:path'
import { x } from 'tinyexec'
import { RuntimeException } from '@adonisjs/core/exceptions'
import { Config, Endpoint } from '../src/types.js'
import { Action } from '../src/action_logger.js'

export default class BluePrintGenerate extends BaseCommand {
  static commandName = 'blueprint:generate'
  static description = 'Generate API blueprint from routes'

  @flags.boolean({
    default: true,
  })
  declare formatting: boolean

  @flags.boolean({
    default: true,
  })
  declare typechecking: boolean

  @flags.boolean({
    default: true,
  })
  declare linting: boolean

  static options: CommandOptions = {
    startApp: true,
  }

  #config = () => {
    const rawConfig = this.app.config.get<Config | null>('blueprint', null)

    if (!rawConfig) {
      throw new RuntimeException(
        'Invalid "config/blueprint.ts" file. Make sure you are using the "defineConfig" method'
      )
    }

    return rawConfig
  }

  #getRootPath = (path: string) => fileURLToPath(new URL(path, this.app.appRoot))

  #getClientPath = (path?: string) =>
    this.#getRootPath(`./${this.#config().output ?? 'blueprint'}/${path || ''}`)

  #getSchemaPath = (group?: string) => this.#getClientPath(`${group || ''}/schema.ts`)

  #getReferencePath = () => this.#getClientPath('reference.ts')

  #getRelativePath = (from: string, to: string) => slash(relative(from, to))

  #prepareDestination() {
    const directory = this.#getClientPath()

    if (existsSync(directory)) {
      const files = readdirSync(directory)

      for (const file of files) {
        if (!file.endsWith('.ts')) {
          rmSync(file, { recursive: true, force: true })
        }
      }
    } else {
      mkdirSync(directory, { recursive: true })
    }
  }

  #getMethod(methods: string[]) {
    let result = 'GET'

    for (const method of methods) {
      const lowerMethod = method.toLowerCase()

      if (lowerMethod === 'head') {
        continue
      }

      result = lowerMethod.toUpperCase()
    }

    return result
  }

  #getConstructorAction(path: string) {
    const fileName = path.split('/').pop()

    if (!fileName) {
      throw new Error('Unable to determine the file name', {
        cause: {
          path,
        },
      })
    }

    if (!fileName.endsWith('_controller.ts')) {
      throw new Error('The file name must end with "_controller.ts"', {
        cause: {
          path,
        },
      })
    }

    return fileName.replace('_controller.ts', '').split('_')
  }

  async #groupRoutes(routes: RouteJSON[]) {
    const config = this.#config()

    const result = new Map<string, RouteJSON[]>()

    for (const route of routes) {
      let group: string | undefined

      for (const [key, value] of Object.entries(config.groups)) {
        if (value.test(route.pattern)) {
          group = key
          break
        }
      }

      if (!group) {
        group = 'default'
      }

      if (!result.has(group)) {
        result.set(group, [])
      }

      result.get(group)!.push(route)
    }

    return result
  }

  async #getRoutes() {
    const router = await this.app.container.make('router')

    router.commit()

    return router.toJSON().root
  }

  #action(title: string) {
    return new Action(title)
      .useColors(this.kernel.ui.logger.getColors())
      .useRenderer(this.kernel.ui.logger.getRenderer())
  }

  async #runCMD(params: {
    message: string
    command: {
      main: string
      args?: string[]
    }
    active?: boolean
    verbose?: boolean
  }) {
    if (params.active === false) {
      return
    }

    const runningCommand = this.#action(params.message)

    runningCommand.started()

    const res = await x(params.command.main, params.command.args, {
      nodeOptions: {
        stdio: params.verbose ? 'inherit' : undefined,
      },
    })

    if (res.exitCode !== 0) {
      for (const line of res.stdout.split('\n')) {
        const parsedLine = line.trim()

        if (parsedLine.length > 0) {
          runningCommand.error(parsedLine)
        }
      }

      for (const line of res.stderr.split('\n')) {
        const parsedLine = line.trim()

        if (parsedLine.length > 0) {
          runningCommand.error(parsedLine)
        }
      }

      process.exit(1)
    }

    runningCommand.completed()
  }

  async #writeSchemaFile(group: string, endpoints: Endpoint[]) {
    const file = this.#project.createSourceFile(this.#getSchemaPath(group), '', { overwrite: true })

    if (!file) throw new Error('Unable to create the schema.ts file')

    const referenceFilePath = this.#getRelativePath(
      this.#getClientPath(group),
      this.#getClientPath('reference.ts')
    )

    file.removeText().insertText(0, (writer) => {
      writer.writeLine(`/// <reference path="${referenceFilePath}" />`)

      writer.newLine()

      writer.writeLine(`import { InferController, endpoint } from '@folie/blueprint-lib'`)

      writer.newLine()

      writer.writeLine(`/*`)
      writer.writeLine(` * This is an auto-generated file. Changes made to this file will be lost.`)
      writer.writeLine(' * Run `nr ace blueprint:generate` to update it.')
      writer.writeLine(` */`)

      writer.newLine()

      endpoints.forEach((route) => {
        writer.writeLine(
          `export type ${route.name.type} = InferController<(typeof import('${route.controller.relative}'))['default']>`
        )
      })

      writer.newLine()

      writer
        .write('export const endpoints = ')
        .inlineBlock(() => {
          endpoints.forEach((route) => {
            writer.writeLine(
              `${route.name.key}: endpoint<${route.name.type}>({ form: ${route.form}, url: '${route.path}', method: '${route.method}' }),`
            )
          })
        })
        .write(' as const')
    })

    await file.save()
  }

  async #writeReferenceFile() {
    const path = this.#getReferencePath()

    if (existsSync(path)) {
      return
    }

    const file = this.#project.createSourceFile(path, '', { overwrite: true })

    const rcFilePath = this.#getRelativePath(dirname(path), this.#getRootPath('adonisrc.ts'))

    file.removeText().insertText(0, (writer) => {
      writer.writeLine(`/// <reference path="${rcFilePath}" />`)

      writer.newLine()

      writer.writeLine(`/* Add the other required types here */`)
    })

    await file.save()
  }

  #project = new Project({
    manipulationSettings: { quoteKind: QuoteKind.Single, useTrailingCommas: true },
    tsConfigFilePath: this.#getRootPath('tsconfig.json'),
  })

  async run() {
    const config = this.#config()

    await this.#runCMD({
      message: 'Formatting files',
      command: {
        main: 'prettier',
        args: ['--write', '.'],
      },
      active: this.formatting,
    })

    await this.#runCMD({
      message: 'Typechecking',
      command: {
        main: 'tsc',
        args: ['--noEmit'],
      },
      active: this.typechecking,
    })

    await this.#runCMD({
      message: 'Linting',
      command: {
        main: 'eslint',
        args: ['.'],
      },
      active: this.linting,
    })

    const generatingBlueprint = this.#action('Generating blueprint')

    generatingBlueprint.started()

    this.#prepareDestination()

    generatingBlueprint.progress('Destination prepared')

    const routes = await this.#groupRoutes(await this.#getRoutes())

    generatingBlueprint.progress('Routes grouped')

    await this.#writeReferenceFile()

    generatingBlueprint.progress('Reference file written')

    const parsingRoutes = this.#action('Parsing routes')

    parsingRoutes.started()

    const sourcesFiles = this.#project.getSourceFiles()

    const endpoints: Endpoint[] = []

    for (const [group, groupRoutes] of routes.entries()) {
      const groupEndpoints: Endpoint[] = []

      const processingGroup = this.#action(`Processing group "${group}"`)

      processingGroup.started()

      for (const route of groupRoutes) {
        const processingRoute = this.#action(
          `Processing route "${route.pattern}" in group "${group}"`
        )

        processingRoute.started()

        // =======================

        if (typeof route.handler === 'function') {
          processingRoute.skipped(`We don't support function routes`)
          continue
        }

        const routeHandler = await parseBindingReference(route.handler.reference)

        const routeSourceFile = sourcesFiles.find((sf) =>
          sf.getFilePath().endsWith(`${routeHandler.moduleNameOrPath.replace('#', '')}.ts`)
        )

        if (!routeSourceFile) {
          processingRoute.failed(`We couldn't find the source file`)
          continue
        }

        const relativePath = this.#getRelativePath(
          this.#getClientPath(group),
          routeSourceFile.getFilePath()
        )

        // Key Generation

        const spacedPath: string[] = []

        for (const segment of route.pattern.split(/[./-]+/)) {
          if (!segment.startsWith(':')) {
            spacedPath.push(segment)
          }
        }

        spacedPath.push(...this.#getConstructorAction(relativePath))

        const joinedSpacedPath = [
          ...new Set(spacedPath.map((s) => stringHelpers.snakeCase(s))),
        ].join(' ')

        const parsedSpacedPath = config.key ? config.key(joinedSpacedPath) : joinedSpacedPath

        // ======================

        const splittedPath = route.pattern
          .split('/')
          .slice(1)
          .map((segment, segmentIndex) => {
            if (segment.startsWith(':')) {
              const paramName = segment.slice(1)
              if (!/^[a-zA-Z?]+$/.test(paramName)) {
                throw new Error('Only letters allowed in parameter segments', {
                  cause: { segment: segmentIndex, route: route.pattern },
                })
              }
              return `{{ ${paramName.replace('?', '')} }}`
            } else if (!/^[a-z0-9-]+$/i.test(segment)) {
              throw new Error(
                'Only lowercase letters, numbers, and hyphens allowed in non-parameter segments',
                {
                  cause: { segment: segmentIndex, route: route.pattern },
                }
              )
            }
            return segment
          })

        const endpointDraft: Endpoint = {
          path: `/${splittedPath.join('/')}`,
          method: this.#getMethod(route.methods),
          form: false,
          controller: {
            relative: relativePath,
            path: routeHandler.moduleNameOrPath,
          },
          name: {
            key: stringHelpers.snakeCase(parsedSpacedPath).toUpperCase(),
            type: `${stringHelpers.pascalCase(parsedSpacedPath)}Route`,
          },
        }

        processingRoute.progress('Successfully parsed the route')

        // =======================

        for (const parsedRoute of endpoints) {
          if (parsedRoute.controller.path === endpointDraft.controller.path) {
            throw new Error(
              `The controller ${endpointDraft.controller.path} is already registered`,
              {
                cause: {
                  currentRoute: endpointDraft,
                  registeredRoute: parsedRoute,
                },
              }
            )
          }

          if (parsedRoute.name.key === endpointDraft.name.key) {
            throw new Error(`The controller key has already been registered`, {
              cause: {
                currentRoute: endpointDraft,
                registeredRoute: parsedRoute,
              },
            })
          }
        }

        const classDef = routeSourceFile.getClasses().find((c) => c.isDefaultExport())

        if (!classDef) {
          throw new Error(`We were not able to find the default export`, {
            cause: {
              endpoint: endpointDraft,
            },
          })
        }

        if (!classDef.getType().isClass()) {
          throw new Error(`The default export is not a class`, {
            cause: {
              endpoint: endpointDraft,
            },
          })
        }

        const handleMethod = classDef.getProperty('handle')
        const inputProperty = classDef.getProperty('input')
        const formProperty = classDef.getProperty('form')

        if (!handleMethod) {
          throw new Error(`We were not able to find the "handle" method`, {
            cause: {
              endpoint: endpointDraft,
            },
          })
        }

        if (inputProperty) {
          const inputPropertyType = inputProperty.getType()

          if (!inputPropertyType.isObject()) {
            throw new Error(`The "input" property is not an object`, {
              cause: {
                endpoint: endpointDraft,
              },
            })
          }
        }

        if (formProperty) {
          const formPropertyType = formProperty.getType()

          if (!formPropertyType.isBoolean()) {
            throw new Error(`The "form" property is not a boolean`, {
              cause: {
                endpoint: endpointDraft,
              },
            })
          }

          endpointDraft.form = Boolean(formProperty.getStructure().initializer)
        }

        groupEndpoints.push(endpointDraft)
        endpoints.push(endpointDraft)

        // =======================

        processingRoute.completed()
      }

      if (groupEndpoints.length === 0) {
        processingGroup.skipped(`No routes found in "${group}" group`)
        continue
      }

      await this.#writeSchemaFile(group, groupEndpoints)

      processingGroup.completed()
    }

    parsingRoutes.completed()

    // =======================

    await this.#runCMD({
      message: 'Formatting client file',
      command: {
        main: 'prettier',
        args: ['--write', this.#getClientPath()],
      },
      active: this.formatting,
    })

    generatingBlueprint.completed()
  }
}

```
-------------------------------
[packages/blueprint/index.ts]

```ts
/*
|--------------------------------------------------------------------------
| Package entrypoint
|--------------------------------------------------------------------------
|
| Export values from the package entrypoint as you see fit.
|
*/

export { defineConfig } from './src/define_config.js'

```
-------------------------------
[packages/blueprint/package.json]

```json
{
  "name": "@folie/blueprint",
  "description": "",
  "version": "0.0.5",
  "engines": {
    "node": ">=20.6.0"
  },
  "type": "module",
  "files": [
    "build",
    "!build/bin",
    "!build/tests"
  ],
  "exports": {
    ".": "./build/index.js",
    "./commands": "./build/commands/main.js"
  },
  "scripts": {
    "clean": "del-cli build",
    "typecheck": "tsc --noEmit",
    "lint": "eslint .",
    "format": "prettier --write \"**/*.{ts,tsx,md}\"",
    "test": "c8 nr quick:test",
    "prebuild": "nr clean",
    "build": "tsc && adonis-kit index build/commands",
    "quick:test": "tsx bin/test.ts",
    "playground": "tsx bin/playground.ts"
  },
  "devDependencies": {
    "@adonisjs/eslint-config": "^2.0.0-beta.7",
    "@adonisjs/prettier-config": "^1.3.0",
    "@adonisjs/tsconfig": "^1.3.0",
    "@japa/assert": "^3.0.0",
    "@japa/runner": "^3.1.4",
    "@types/node": "^20.14.5",
    "@types/pretty-hrtime": "^1.0.3",
    "c8": "^10.1.2",
    "copyfiles": "^2.4.1",
    "del-cli": "^5.1.0",
    "eslint": "^9.12.0",
    "prettier": "^3.3.3",
    "typescript": "^5.6"
  },
  "author": "MohitXSkull, Folie",
  "license": "Apache-2.0",
  "keywords": [],
  "prettier": "@adonisjs/prettier-config",
  "publishConfig": {
    "access": "public"
  },
  "c8": {
    "exclude": [
      "tests/**"
    ]
  },
  "dependencies": {
    "@poppinss/cliui": "^6.4.2",
    "pretty-hrtime": "^1.0.3",
    "tinyexec": "^0.3.1",
    "ts-morph": "^24.0.0",
    "zod": "^3.24.1"
  },
  "peerDependencies": {
    "@adonisjs/core": "^6.14.1"
  }
}

```
-------------------------------
[packages/blueprint/src/action_logger.ts]

```ts
import prettyHrtime from 'pretty-hrtime'
import type { Colors } from '@poppinss/colors/types'
import { RendererContract } from '@poppinss/cliui/types'
import { ConsoleRenderer } from '@poppinss/cliui'
import colors from '@poppinss/colors'

/**
 * Returns the colors instance based upon the environment.
 *
 * - The "raw" option returns the colors instance that prefix the color
 *   transformations as raw text
 * - The "silent" option returns the colors instance that performs no
 *   color transformations
 */
const useColors = (options: { raw?: boolean; silent?: boolean } = {}): Colors => {
  if (options.raw) {
    return colors.raw()
  }

  if (options.silent) {
    return colors.silent()
  }

  return colors.ansi()
}

export class Action {
  #startTime?: [number, number]

  /**
   * Action message
   */
  #message: string

  /**
   * Reference to the colors implementation
   */
  #colors?: Colors

  /**
   * The renderer to use for writing to the console
   */
  #renderer?: RendererContract

  constructor(message: string) {
    this.#message = message
    this.#startTime = process.hrtime()
  }

  /**
   * Format label
   */
  #formatLabel(label: string, color: keyof Colors) {
    label = this.getColors()[color](`${label.toUpperCase()}:`)

    return label
  }

  /**
   * Format message
   */
  #formatMessage(message: string) {
    return message
  }

  /**
   * Format the suffix
   */
  #formatSuffix(message: string) {
    message = `(${message})`
    return this.getColors().dim(message)
  }

  /**
   * Format error
   */
  #formatError(error: string | Error) {
    let message = typeof error === 'string' ? error : error.stack || error.message

    return `\n    ${message
      .split('\n')
      .map((line) => {
        return `       ${this.getColors().red(line)}`
      })
      .join('\n')}`
  }

  #time() {
    return prettyHrtime(process.hrtime(this.#startTime))
  }

  /**
   * Returns the renderer for rendering the messages
   */
  getRenderer(): RendererContract {
    if (!this.#renderer) {
      this.#renderer = new ConsoleRenderer()
    }

    return this.#renderer
  }

  /**
   * Define a custom renderer.
   */
  useRenderer(renderer: RendererContract): this {
    this.#renderer = renderer
    return this
  }

  /**
   * Returns the colors implementation in use
   */
  getColors(): Colors {
    if (!this.#colors) {
      this.#colors = useColors()
    }

    return this.#colors
  }

  /**
   * Define a custom colors implementation
   */
  useColors(color: Colors): this {
    this.#colors = color
    return this
  }

  /**
   * Prepares the message to mark action as successful
   */
  prepareCompleted() {
    const formattedLabel = this.#formatLabel('completed', 'green')
    const formattedMessage = this.#formatMessage(this.#message)
    const formattedTime = this.#formatSuffix(this.#time())

    return `${formattedLabel} ${formattedMessage} ${formattedTime}\n`
  }

  /**
   * Mark action as completed
   */
  completed() {
    this.getRenderer().log(this.prepareCompleted())
  }

  /**
   * Prepares the message to mark action as skipped
   */
  prepareSkipped(skipReason: string) {
    const formattedLabel = this.#formatLabel('skipped', 'cyan')
    const formattedMessage = this.#formatMessage(skipReason)

    return `${formattedLabel}   ${formattedMessage}  ${this.#formatSuffix(this.#message)}`
  }

  /**
   * Mark action as skipped. An optional skip reason can be
   * supplied
   */
  skipped(skipReason: string) {
    this.getRenderer().log(this.prepareSkipped(skipReason))
  }

  /**
   * Prepares the message to mark action as failed
   */
  prepareFailed(error: string | Error) {
    const formattedLabel = this.#formatLabel('failed', 'red')
    const formattedMessage = this.#formatMessage(this.#message)
    const formattedError = this.#formatError(error)
    const formattedTime = this.#formatSuffix(this.#time())

    return `${formattedLabel}    ${formattedMessage}  ${formattedError} ${formattedTime}`
  }

  /**
   * Mark action as failed. An error message is required
   */
  failed(error: string | Error) {
    this.getRenderer().logError(this.prepareFailed(error))
  }

  prepareError(error: string) {
    const formattedLabel = this.#formatLabel('error', 'red')
    const formattedError = this.getColors().red(error)

    return `${formattedLabel}     ${formattedError}`
  }

  error(error: string) {
    this.getRenderer().logError(this.prepareError(error))
  }

  prepareStarted() {
    const formattedLabel = this.#formatLabel('started', 'blue')
    const formattedMessage = this.#formatMessage(this.#message)

    return `${formattedLabel}   ${formattedMessage}`
  }

  started() {
    this.getRenderer().log(this.prepareStarted())
  }

  prepareProgress(progress: string) {
    const formattedLabel = this.#formatLabel('progress', 'yellow')
    const formattedMessage = this.#formatMessage(progress)
    const formattedProgress = this.#formatSuffix(this.#message)
    const formattedTime = this.#formatSuffix(this.#time())

    return `${formattedLabel}  ${formattedMessage} ${formattedProgress} ${formattedTime}`
  }

  progress(message: string) {
    this.getRenderer().log(this.prepareProgress(message))
  }
}

```
-------------------------------
[packages/blueprint/src/define_config.ts]

```ts
import { InvalidArgumentsException } from '@adonisjs/core/exceptions'
import { Config, configSchema } from './types.js'

export const defineConfig = (config: Config) => {
  const parsedConfig = configSchema.safeParse(config)

  if (!parsedConfig.success) {
    throw new InvalidArgumentsException(parsedConfig.error.message, {
      cause: parsedConfig.error.format(),
    })
  }

  return parsedConfig.data
}

```
-------------------------------
[packages/blueprint/src/space.ts]

```ts
export const space = () => {
  console.log('')
}

```
-------------------------------
[packages/blueprint/src/types.ts]

```ts
import { z } from 'zod'

export type Endpoint = {
  path: string
  method: string
  form: boolean
  name: {
    key: string
    type: string
  }
  controller: {
    relative: string
    path: string
  }
}

export const configSchema = z.object({
  groups: z.record(z.string().regex(new RegExp('^[a-z0-9_]*$')), z.instanceof(RegExp)),
  key: z.function().args(z.string()).returns(z.string()).optional(),
  output: z.string().regex(new RegExp('^[a-z0-9_]*$')).optional(),
})

export type Config = z.infer<typeof configSchema>

```
-------------------------------
[packages/blueprint/tests/config.spec.ts]

```ts
import { test } from '@japa/runner'
import { defineConfig } from '../src/define_config.js'

test.group('Config', () => {
  test('add two numbers', ({ assert }) => {
    const config = defineConfig({
      groups: {
        private: new RegExp('/api/internal/v[12]/private/'),
      },
    })

    const privateArray = config.groups['private']

    if (!privateArray) {
      return assert.fail('Private array not found')
    }

    assert.equal(privateArray instanceof RegExp, true)

    assert.equal(privateArray.test('/api/internal/v1/private/'), true)
    assert.equal(privateArray.test('/api/internal/v2/private/'), true)
  })
})

```
-------------------------------
[packages/blueprint_lib/bin/playground.ts]

```ts
console.log('Welcome to playground!')

```
-------------------------------
[packages/blueprint_lib/bin/test.ts]

```ts
import { assert } from '@japa/assert'
import { configure, processCLIArgs, run } from '@japa/runner'

processCLIArgs(process.argv.splice(2))

configure({
  files: ['tests/**/*.spec.ts'],
  plugins: [assert()],
})

run()

```
-------------------------------
[packages/blueprint_lib/index.ts]

```ts
/*
|--------------------------------------------------------------------------
| Package entrypoint
|--------------------------------------------------------------------------
|
| Export values from the package entrypoint as you see fit.
|
*/

export { endpoint } from './src/endpoint.js'
export * from './src/types.js'

```
-------------------------------
[packages/blueprint_lib/package.json]

```json
{
  "name": "@folie/blueprint-lib",
  "description": "",
  "version": "0.0.5",
  "engines": {
    "node": ">=20.6.0"
  },
  "type": "module",
  "files": [
    "build",
    "!build/bin",
    "!build/tests"
  ],
  "exports": {
    ".": "./build/index.js"
  },
  "scripts": {
    "clean": "del-cli build",
    "typecheck": "tsc --noEmit",
    "lint": "eslint .",
    "format": "prettier --write \"**/*.{ts,tsx,md}\"",
    "test": "c8 nr quick:test",
    "prebuild": "nr clean",
    "build": "tsc",
    "quick:test": "tsx bin/test.ts",
    "playground": "tsx bin/playground.ts"
  },
  "devDependencies": {
    "@adonisjs/core": "^6.15.1",
    "@adonisjs/eslint-config": "^2.0.0-beta.7",
    "@adonisjs/prettier-config": "^1.3.0",
    "@adonisjs/tsconfig": "^1.3.0",
    "@japa/assert": "^3.0.0",
    "@japa/runner": "^3.1.4",
    "@types/node": "^20.14.5",
    "c8": "^10.1.2",
    "del-cli": "^5.1.0",
    "eslint": "^9",
    "prettier": "^3.3.2",
    "typescript": "^5.6"
  },
  "dependencies": {
    "@vinejs/vine": "3.0.0",
    "@folie/lib": "workspace:*",
    "qs": "6.14.0"
  },
  "author": "MohitXSkull, Folie",
  "license": "Apache-2.0",
  "keywords": [],
  "prettier": "@adonisjs/prettier-config",
  "publishConfig": {
    "access": "public"
  },
  "c8": {
    "exclude": [
      "tests/**"
    ]
  }
}

```
-------------------------------
[packages/blueprint_lib/src/endpoint.ts]

```ts
import { interpolate } from '@folie/lib'
import { Endpoint, EndpointIO } from './types.js'
import qs from 'qs'

export const endpoint = <IO extends EndpointIO>(params: {
  url: string
  method: string
  form: boolean
}): Endpoint<IO> =>
  ({
    url: (options?) => {
      let url = interpolate(params.url, options?.params)

      if (options?.query) {
        url += `?${qs.stringify(options.query)}`
      }

      return url
    },
    method: params.method,
    form: params.form,
    io: {} as IO,
  }) as const

```
-------------------------------
[packages/blueprint_lib/src/types.ts]

```ts
import { VineValidator } from '@vinejs/vine'
import { InferInput } from '@vinejs/vine/types'
import type { MultipartFile } from '@adonisjs/bodyparser/types'
import { Constructor } from '@adonisjs/core/types/container'

export type EndpointIO = {
  output: any
  input: any
}

export type Endpoint<IO extends EndpointIO> = {
  url: (options?: {
    params?: 'input' extends keyof IO
      ? 'params' extends keyof IO['input']
        ? IO['input']['params']
        : undefined
      : undefined
    query?: 'input' extends keyof IO
      ? 'query' extends keyof IO['input']
        ? IO['input']['query']
        : undefined
      : undefined
  }) => string
  method: string
  form?: boolean
  io: IO
}

export type ApiEndpoints = Record<string, Endpoint<EndpointIO>>

export type EndpointKeys<Endpoints extends ApiEndpoints> = keyof Endpoints

// ===============
// https://github.com/Julien-R44/tuyau/blob/main/packages/utils/src/types.ts

type Prettify<T> = {
  [K in keyof T]: T[K]
} & {}

type UndefinedProps<T extends object> = {
  [K in keyof T as undefined extends T[K] ? K : never]?: T[K]
}

export type MakeOptional<T extends object> = UndefinedProps<T> & Omit<T, keyof UndefinedProps<T>>

export type FileMapping<T extends object> = MakeOptional<{
  [K in keyof T]: T[K] extends MultipartFile ? Blob | File : T[K]
}>

export type InferController<CONTROLLER extends Constructor<{ [key: string]: any }>> = {
  output: 'handle' extends keyof InstanceType<CONTROLLER>
    ? ReturnType<InstanceType<CONTROLLER>['handle']> extends Promise<infer U>
      ? U extends object
        ? Prettify<U>
        : undefined
      : undefined
    : undefined

  input: 'input' extends keyof InstanceType<CONTROLLER>
    ? InstanceType<CONTROLLER>['input'] extends VineValidator<any, any>
      ? InferInput<InstanceType<CONTROLLER>['input']> extends object
        ? Prettify<FileMapping<InferInput<InstanceType<CONTROLLER>['input']>>>
        : undefined
      : undefined
    : undefined
}

```
-------------------------------
[packages/blueprint_lib/tests/example.spec.ts]

```ts
import { test } from '@japa/runner'

test.group('Example', () => {
  test('add two numbers', ({ assert }) => {
    assert.equal(1 + 1, 2)
  })
})

```
-------------------------------
[packages/captcha/bin/playground.ts]

```ts
console.log('Welcome to playground!')

```
-------------------------------
[packages/captcha/bin/test.ts]

```ts
import { assert } from '@japa/assert'
import { configure, processCLIArgs, run } from '@japa/runner'

processCLIArgs(process.argv.splice(2))

configure({
  files: ['tests/**/*.spec.ts'],
  plugins: [assert()],
})

run()

```
-------------------------------
[packages/captcha/index.ts]

```ts
/*
|--------------------------------------------------------------------------
| Package entrypoint
|--------------------------------------------------------------------------
|
| Export values from the package entrypoint as you see fit.
|
*/

export { CaptchaManager } from './src/manager.js'

```
-------------------------------
[packages/captcha/package.json]

```json
{
  "name": "@folie/captcha",
  "description": "",
  "version": "0.0.0",
  "engines": {
    "node": ">=20.6.0"
  },
  "type": "module",
  "files": [
    "build",
    "!build/bin",
    "!build/tests"
  ],
  "exports": {
    ".": "./build/index.js",
    "./drivers": "./build/src/drivers/index.js",
    "./types": "./build/src/types.js"
  },
  "scripts": {
    "clean": "del-cli build",
    "typecheck": "tsc --noEmit",
    "lint": "eslint .",
    "format": "prettier --write \"**/*.{ts,tsx,md}\"",
    "test": "c8 nr quick:test",
    "prebuild": "nr clean",
    "build": "tsc",
    "quick:test": "tsx bin/test.ts",
    "playground": "tsx bin/playground.ts"
  },
  "devDependencies": {
    "@adonisjs/eslint-config": "^2.0.0-beta.7",
    "@adonisjs/prettier-config": "^1.3.0",
    "@adonisjs/tsconfig": "^1.3.0",
    "@japa/assert": "^3.0.0",
    "@japa/runner": "^3.1.4",
    "@types/node": "^20.14.5",
    "c8": "^10.1.2",
    "del-cli": "^5.1.0",
    "eslint": "^9",
    "prettier": "^3.3.2",
    "typescript": "^5.6"
  },
  "author": "MohitXSkull, Folie",
  "license": "Apache-2.0",
  "prettier": "@adonisjs/prettier-config",
  "publishConfig": {
    "access": "public"
  },
  "c8": {
    "exclude": [
      "tests/**"
    ]
  },
  "dependencies": {
    "@vinejs/vine": "^3.0.0",
    "ky": "^1.7.5"
  }
}

```
-------------------------------
[packages/captcha/src/drivers/index.ts]

```ts
export { TurnstileDriver } from './turnstile.js'

```
-------------------------------
[packages/captcha/src/drivers/turnstile.ts]

```ts
import vine from '@vinejs/vine'
import { CaptchaDriverContract } from '../types.js'
import ky from 'ky'

const schema = vine.compile(
  vine.object({
    'success': vine.boolean({ strict: true }),
    'error-codes': vine.array(vine.string()),
    'hostname': vine.string().optional(),
    'action': vine.string().optional(),
    'cdata': vine.string().optional(),
    'challenge_ts': vine
      .date({
        formats: ['iso8601'],
      })
      .optional(),
  })
)

export class TurnstileDriver implements CaptchaDriverContract {
  #privateKey: string
  #baseUrl: string = 'https://challenges.cloudflare.com/turnstile/v0/siteverify'

  constructor(params: { privateKey: string; baseUrl?: string }) {
    this.#privateKey = params.privateKey
    if (params.baseUrl) {
      this.#baseUrl = params.baseUrl
    }
  }

  async verify(params: { token: string; ip?: string }) {
    const idempotencyKey = crypto.randomUUID()

    try {
      const response = await ky
        .post(this.#baseUrl, {
          json: {
            secret: this.#privateKey,
            response: params.token,
            remoteip: params.ip,
            idempotency_key: idempotencyKey,
          },
        })
        .json()

      const validatedResponse = await schema.validate(response)

      return [validatedResponse.success, validatedResponse] as const
    } catch (error) {
      throw new Error('Captcha verification failed', {
        cause: error,
      })
    }
  }
}

```
-------------------------------
[packages/captcha/src/manager.ts]

```ts
import { CaptchaDriverContract } from './types.js'

export class CaptchaManager<T extends Record<string, CaptchaDriverContract>> {
  #drivers: T
  #defaultDriver: keyof T

  constructor(params: { drivers: T; defaultDriver: keyof T }) {
    this.#drivers = params.drivers
    this.#defaultDriver = params.defaultDriver
  }

  use(driverName?: keyof T) {
    return this.#drivers[driverName || this.#defaultDriver]
  }
}

```
-------------------------------
[packages/captcha/src/types.ts]

```ts
export interface CaptchaDriverContract {
  verify: (params: { token: string; [key: string]: any }) => Promise<readonly [boolean, unknown]>
}

```
-------------------------------
[packages/captcha/tests/example.spec.ts]

```ts
import { test } from '@japa/runner'

test.group('Example', () => {
  test('add two numbers', ({ assert }) => {
    assert.equal(1 + 1, 2)
  })
})

```
-------------------------------
[packages/castle/bin/playground.ts]

```ts
console.log('Welcome to playground!')

```
-------------------------------
[packages/castle/bin/test.ts]

```ts
import { assert } from '@japa/assert'
import { configure, processCLIArgs, run } from '@japa/runner'

processCLIArgs(process.argv.splice(2))

configure({
  files: ['tests/**/*.spec.ts'],
  plugins: [assert()],
})

run()

```
-------------------------------
[packages/castle/index.ts]

```ts
/*
|--------------------------------------------------------------------------
| Package entrypoint
|--------------------------------------------------------------------------
|
| Export values from the package entrypoint as you see fit.
|
*/

export { CastleModule } from './modules/castle.js'
export { SessionManager } from './modules/session_manager.js'
export { ModelCache } from './modules/model_cache.js'

```
-------------------------------
[packages/castle/middlewares/force_json_response_middleware.ts]

```ts
import type { HttpContext } from '@adonisjs/core/http'
import type { NextFn } from '@adonisjs/core/types/http'

/**
 * Updating the "Accept" header to always accept "application/json" response
 * from the server. This will force the internals of the framework like
 * validator errors or auth errors to return a JSON response.
 */
export default class ForceJsonResponseMiddleware {
  async handle({ request }: HttpContext, next: NextFn) {
    const headers = request.headers()

    headers.accept = 'application/vnd.api+json'

    return next()
  }
}

```
-------------------------------
[packages/castle/modules/authenticator.ts]

```ts
import crypto from 'node:crypto'
import { base32Decode, base32Encode } from '../src/helpers/base32.js'

export type AuthenticatorAlgorithm = 'SHA-1' | 'SHA-256' | 'SHA-384' | 'SHA-512'
export type AuthenticatorEncoding = 'hex' | 'ascii'

type Options = {
  digits?: number
  algorithm?: AuthenticatorAlgorithm
  encoding?: AuthenticatorEncoding
  period?: number
  timestamp?: number
}

const DEFAULT_OPTIONS: Required<Options> = {
  digits: 6,
  algorithm: 'SHA-1',
  encoding: 'hex',
  period: 30,
  timestamp: Date.now(),
}

export class Authenticator {
  static crypto = crypto.webcrypto.subtle

  static async generate(
    key: string,
    options: Options = {}
  ): Promise<{ otp: string; expires: number }> {
    const { digits, algorithm, encoding, period, timestamp } = { ...DEFAULT_OPTIONS, ...options }
    const epochSeconds = Math.floor(timestamp / 1000)
    const timeHex = Math.floor(epochSeconds / period)
      .toString(16)
      .padStart(16, '0')
    const keyBuffer = encoding === 'hex' ? this.base32ToBuffer(key) : this.asciiToBuffer(key)

    const hmacKey = await this.crypto.importKey(
      'raw',
      keyBuffer,
      { name: 'HMAC', hash: { name: algorithm } },
      false,
      ['sign']
    )
    const signature = await this.crypto.sign('HMAC', hmacKey, this.hex2buf(timeHex))
    const signatureHex = this.buf2hex(signature)
    const offset = Number.parseInt(signatureHex.slice(-1), 16) * 2
    const otp = (Number.parseInt(signatureHex.slice(offset, offset + 8), 16) & 0x7fffffff)
      .toString()
      .slice(-digits)
    const expires = Math.ceil((timestamp + 1) / (period * 1000)) * (period * 1000)

    return { otp, expires }
  }

  static secret(length: number = 20): string {
    return base32Encode(crypto.randomBytes(length))
  }

  private static base32ToBuffer(str: string): ArrayBuffer {
    return new Uint8Array(base32Decode(str)).buffer
  }

  private static asciiToBuffer(str: string): ArrayBuffer {
    return new Uint8Array([...str].map((char) => char.charCodeAt(0))).buffer
  }

  private static hex2buf(hex: string): ArrayBuffer {
    return new Uint8Array(hex.match(/../g)!.map((byte) => Number.parseInt(byte, 16))).buffer
  }

  private static buf2hex(buffer: ArrayBuffer): string {
    return Array.from(new Uint8Array(buffer))
      .map((byte) => byte.toString(16).padStart(2, '0'))
      .join('')
  }
}

export class AuthenticatorFactory {
  #options?: Options

  constructor(options?: Options) {
    this.#options = options
  }

  generate(key: string, options: Options = {}) {
    return Authenticator.generate(key, { ...this.#options, ...options })
  }
}

```
-------------------------------
[packages/castle/modules/castle.ts]

```ts
import { ExtendedPivotOptions, PivotOptions } from '../src/types/castle.js'

export class CastleModule<
  Table extends Record<string, string>,
  Pivot extends Record<string, ExtendedPivotOptions<Table>>,
> {
  readonly table: Record<keyof Table, (column?: string) => string>
  readonly pivot: Record<
    keyof Pivot,
    {
      pivotTable: string
      pivotTimestamps: boolean
    } & PivotOptions
  >

  constructor(params: { config: { table: Table; pivot?: Pivot } }) {
    this.table = Object.fromEntries(
      Object.entries(params.config.table).map(([key, value]) => [
        key,
        (column?: string) => (column ? `${value}.${column}` : value),
      ])
    ) as Record<keyof Table, (column?: string) => string>

    this.pivot = Object.fromEntries(
      Object.entries(params.config.pivot ?? {}).map(([key, value]) => [
        key,
        {
          pivotTimestamps: true,
          ...value,
          pivotTable: value.pivotTable(this.table),
        },
      ])
    ) as Record<
      keyof Pivot,
      {
        pivotTable: string
        pivotTimestamps: boolean
      } & PivotOptions
    >
  }
}

```
-------------------------------
[packages/castle/modules/model_cache.ts]

```ts
import { CacheProvider, GetSetFactory, SetCommonOptions } from '@adonisjs/cache/types'
import { LucidModel, LucidRow } from '@adonisjs/lucid/types/model'

// ==================================

type DefaultCacheKeys = 'self'

type TargetModel = LucidModel & {
  new (): LucidRow & {
    $toJSON: () => object

    id: number
  }
}

// ==================================

class RowCache<GTargetModel extends TargetModel, CacheKeys extends string> {
  #modelCache: ModelCache<GTargetModel, CacheKeys>
  #row: InstanceType<GTargetModel>

  constructor(modelCache: ModelCache<GTargetModel, CacheKeys>, row: InstanceType<GTargetModel>) {
    this.#modelCache = modelCache
    this.#row = row
  }

  space() {
    return this.#modelCache.space(this.#row.id)
  }

  key(key: DefaultCacheKeys | CacheKeys) {
    return this.#modelCache.key(key)
  }

  async expire(key: DefaultCacheKeys | CacheKeys) {
    await this.space().delete({ key })
  }

  async get<T, O>(params: {
    key: DefaultCacheKeys | CacheKeys
    factory: GetSetFactory<T>
    parser: (value: T) => Promise<O>
    options?: SetCommonOptions
    latest?: boolean
  }) {
    return this.#modelCache.get({
      id: this.#row.id,
      key: params.key,
      factory: params.factory,
      parser: params.parser,
      options: params.options,
    })
  }
}

export class ModelCache<GTargetModel extends TargetModel, CacheKeys extends string> {
  #model: GTargetModel
  #cache: CacheProvider

  constructor(model: GTargetModel, cache: CacheProvider, _?: readonly CacheKeys[]) {
    this.#model = model
    this.#cache = cache
  }

  space(id: number) {
    return this.#cache.namespace(String(id))
  }

  key(key: DefaultCacheKeys | CacheKeys) {
    return key
  }

  async expire(params: { id: number; key: DefaultCacheKeys | CacheKeys }) {
    await this.space(params.id).delete({ key: params.key })
  }

  async get<I, O>(params: {
    id: number
    key: DefaultCacheKeys | CacheKeys
    factory: GetSetFactory<I>
    parser: (value: I) => Promise<O> | O
    options?: SetCommonOptions
    latest?: boolean
  }) {
    if (params.latest) {
      await this.expire({ id: params.id, key: params.key })
    }

    const result: I = await this.space(params.id).getOrSet({
      key: params.key,
      factory: params.factory,
      ...params.options,
    })

    return params.parser(result)
  }

  async $find(id: number, options?: SetCommonOptions) {
    return this.get<object | null, InstanceType<GTargetModel> | null>({
      id,
      key: this.key('self'),
      options,
      factory: async () => {
        const res = await this.#model.find(id)

        if (!res) {
          return null
        }

        return res.$toJSON()
      },
      parser: (row) => {
        if (!row) {
          return null
        }

        const res = new this.#model().fill(row)

        res.$hydrateOriginals()
        res.$isPersisted = true

        return res as InstanceType<GTargetModel>
      },
    })
  }

  async $findStrict(id: number, options?: SetCommonOptions) {
    const res = await this.$find(id, options)

    if (!res) {
      throw new Error('Find strict failed', {
        cause: {
          id,
          options,
        },
      })
    }

    return res
  }

  row(row: InstanceType<GTargetModel>) {
    return new RowCache<GTargetModel, CacheKeys>(this, row)
  }
}

```
-------------------------------
[packages/castle/modules/session_manager.ts]

```ts
import { base64, safeEqual, Secret } from '@adonisjs/core/helpers'
import stringHelpers from '@adonisjs/core/helpers/string'
import { LucidModel, LucidRow } from '@adonisjs/lucid/types/model'
import { DateTime } from 'luxon'
import { CRC32 } from '../src/helpers/crc32.js'
import { createHash } from 'node:crypto'
import db from '@adonisjs/lucid/services/db'
import { TransactionClientContract } from '@adonisjs/lucid/types/database'
import { ProcessingException } from '../src/exceptions/processing_exception.js'
import { getBearerToken } from '../src/helpers/get_bearer_token.js'
import { HttpContext } from '@adonisjs/core/http'

interface SessionRow extends LucidRow {
  id: number
  hash: string
  userId: number
  value: Secret<string> | null
  secret: Secret<string> | null
  createdAt: DateTime
  updatedAt: DateTime
  expiresAt: DateTime | null
  usedAt: DateTime | null
}

type ExtendedSessionModel = LucidModel & {
  new (): SessionRow
}

interface SessionModel extends ExtendedSessionModel {
  new (): SessionRow
}

export class SessionManager<SessionModelG extends SessionModel> {
  #tokenPrefix = 'oat_'

  /**
   * The size of the hash in bytes.
   */
  #secretSize = 64

  /**
   * The maximum number of sessions per user.
   */
  #maxSessions = 3

  #invalidMessage = 'Not a valid session'

  /**
   * Creates a secret opaque token and its hash. The secret is
   * suffixed with a crc32 checksum for secret scanning tools
   * to easily identify the token.
   */
  #seed() {
    const seed = stringHelpers.random(this.#secretSize)
    const secret = new Secret(`${seed}${new CRC32().calculate(seed)}`)
    const hash = createHash('sha256').update(secret.release()).digest('hex')
    return { secret, hash }
  }

  /**
   * Decodes a publicly shared token and return the series
   * and the token value from it.
   *
   * Returns null when unable to decode the token because of
   * invalid format or encoding.
   */
  async #decode(value: string) {
    /**
     * Ensure value is a string and starts with the prefix.
     */
    if (typeof value !== 'string' || !value.startsWith(`${this.#tokenPrefix}`)) {
      return null
    }

    /**
     * Remove prefix from the rest of the token.
     */
    const token = value.replace(new RegExp(`^${this.#tokenPrefix}`), '')

    if (!token) {
      return null
    }

    const [identifier, ...tokenValue] = token.split('.')

    if (!identifier || tokenValue.length === 0) {
      return null
    }

    const decodedIdentifier = base64.urlDecode(identifier)

    const decodedSecret = base64.urlDecode(tokenValue.join('.'))

    if (!decodedIdentifier || !decodedSecret) {
      return null
    }

    // Ensure the decoded identifier is a valid number
    if (Number.isNaN(Number(decodedIdentifier))) {
      return null
    }

    const session = await this.sessionModel.find(Number(decodedIdentifier))

    if (!session) {
      throw new ProcessingException(this.#invalidMessage, {
        meta: {
          reason: 'Session not found',
        },
      })
    }

    session.secret = new Secret(decodedSecret)
    session.value = this.#value(session.id, decodedSecret)

    return session as typeof session & {
      secret: Secret<string>
      value: Secret<string>
    }
  }

  #isVerified(hash: string, secret: Secret<string>): boolean {
    const newHash = createHash('sha256').update(secret.release()).digest('hex')

    return safeEqual(hash, newHash)
  }

  #isExpired(expiresAt: DateTime<boolean>) {
    return expiresAt < DateTime.utc()
  }

  #value(sessionId: number, secret: string) {
    return new Secret(
      `${this.#tokenPrefix}${base64.urlEncode(String(sessionId))}.${base64.urlEncode(secret)}`
    )
  }

  constructor(
    private readonly sessionModel: SessionModelG,
    options?: {
      maxSessions?: number
      tokenPrefix?: string
      secretSize?: number
      invalidMessage?: string
    }
  ) {
    this.#maxSessions = options?.maxSessions || this.#maxSessions
    this.#tokenPrefix = options?.tokenPrefix || this.#tokenPrefix
    this.#secretSize = options?.secretSize || this.#secretSize
    this.#invalidMessage = options?.invalidMessage || this.#invalidMessage
  }

  async create(
    user: LucidRow & {
      id: number
    },
    options?: { expiresIn?: string | number; client?: TransactionClientContract }
  ) {
    const trx = options?.client || (await db.transaction())

    try {
      // Deleting last session if max reached
      const activeSessions = await this.sessionModel
        .query({ client: trx })
        .where('user_id', user.id)
        .orderBy('created_at', 'desc')
        .limit(this.#maxSessions + 1)

      if (activeSessions.length > this.#maxSessions) {
        await activeSessions.pop()?.delete()
      }

      const newSession = new this.sessionModel()

      newSession.useTransaction(trx)

      if (options?.expiresIn) {
        newSession.expiresAt = DateTime.utc().plus({
          seconds: stringHelpers.seconds.parse(options.expiresIn),
        })
      }

      const seed = this.#seed()

      newSession.hash = seed.hash
      newSession.userId = user.id
      newSession.secret = seed.secret

      await newSession.save()

      if (!newSession.$isPersisted || !newSession.id) {
        throw new Error('Failed to create session', {
          cause: {
            reason: 'Failed to persist session or session id is missing',
            session: newSession.toJSON(),
          },
        })
      }

      newSession.value = this.#value(newSession.id, seed.secret.release())

      await trx.commit()

      return newSession as typeof newSession & {
        secret: Secret<string>
        value: Secret<string>
      }
    } catch (error) {
      await trx.rollback()
      throw error
    }
  }

  async authenticate(ctx: HttpContext) {
    const token = getBearerToken(ctx)

    if (!token) {
      throw new ProcessingException(this.#invalidMessage, {
        meta: {
          reason: 'Token not found in request',
          token: typeof token,
        },
      })
    }

    const session = await this.#decode(token)

    if (!session) {
      throw new ProcessingException(this.#invalidMessage, {
        meta: {
          reason: 'Session not found',
        },
      })
    }

    if (session.secret) {
      if (!this.#isVerified(session.hash, session.secret)) {
        throw new ProcessingException(this.#invalidMessage, {
          meta: {
            reason: 'Invalid secret',
          },
        })
      }
    } else {
      throw new Error('Secret not found in decoded session')
    }

    if (session.expiresAt) {
      if (this.#isExpired(session.expiresAt)) {
        throw new ProcessingException(this.#invalidMessage, {
          meta: {
            reason: 'Expired session',
          },
        })
      }
    }

    return session
  }
}

```
-------------------------------
[packages/castle/package.json]

```json
{
  "name": "@folie/castle",
  "description": "",
  "version": "0.0.12",
  "engines": {
    "node": ">=20.6.0"
  },
  "type": "module",
  "files": [
    "build",
    "!build/bin",
    "!build/tests"
  ],
  "exports": {
    ".": "./build/index.js",
    "./types": "./build/src/types/index.js",
    "./types/castle": "./build/src/types/castle.js",
    "./column": "./build/src/columns/index.js",
    "./exception": "./build/src/exceptions/index.js",
    "./services/*": "./build/services/*.js",
    "./helpers": "./build/src/helpers/index.js",
    "./middleware/*": "./build/middlewares/*.js",
    "./provider/*": "./build/providers/*.js",
    "./validator": "./build/src/validators/index.js",
    "./miscellaneous/*": "./build/src/miscellaneous/*.js"
  },
  "scripts": {
    "clean": "del-cli build",
    "typecheck": "tsc --noEmit",
    "lint": "eslint .",
    "format": "prettier --write \"**/*.{ts,tsx,md}\"",
    "test": "c8 nr quick:test",
    "prebuild": "nr clean",
    "build": "tsc",
    "quick:test": "tsx bin/test.ts",
    "playground": "tsx bin/playground.ts"
  },
  "devDependencies": {
    "@adonisjs/eslint-config": "^2.0.0-beta.7",
    "@adonisjs/prettier-config": "^1.3.0",
    "@adonisjs/tsconfig": "^1.3.0",
    "@japa/assert": "^3.0.0",
    "@japa/runner": "^3.1.4",
    "@types/luxon": "3.4.2",
    "@types/node": "^20.14.5",
    "c8": "^10.1.2",
    "del-cli": "^5.1.0",
    "eslint": "^9.12.0",
    "prettier": "^3.3.3",
    "typescript": "^5.6"
  },
  "peerDependencies": {
    "@adonisjs/bouncer": "^3.1.4",
    "@adonisjs/core": "^6.14.1",
    "@adonisjs/limiter": "^2.3.2",
    "@adonisjs/lucid": "^21.3.0",
    "@vinejs/vine": "^3.0.0",
    "@adonisjs/cache": "^1.1.0",
    "luxon": "^3.5.0"
  },
  "author": "MohitXSkull, Folie",
  "license": "Apache-2.0",
  "keywords": [],
  "prettier": "@adonisjs/prettier-config",
  "publishConfig": {
    "access": "public"
  },
  "c8": {
    "exclude": [
      "tests/**"
    ]
  },
  "dependencies": {
    "axios": "^1.7.9",
    "decimal.js": "^10.4.3",
    "superjson": "^2.2.1",
    "tinyexec": "^0.3.1",
    "ts-morph": "^24.0.0",
    "@folie/lib": "workspace:*"
  }
}

```
-------------------------------
[packages/castle/providers/migration_provider.ts]

```ts
import type { ApplicationService } from '@adonisjs/core/types'
import ace from '@adonisjs/core/services/ace'
import logger from '@adonisjs/core/services/logger'

export default class MigrationProvider {
  constructor(protected app: ApplicationService) {}

  /**
   * Register bindings to the container
   */
  register() {}

  /**
   * The container bindings have booted
   */
  async boot() {}

  /**
   * The application has been booted
   */
  async start() {
    if (['web'].includes(this.app.getEnvironment())) {
      await ace.boot()

      if (ace.hasCommand('migration:run')) {
        try {
          await ace.exec('migration:run', ['--force'])
        } catch (error) {
          logger.error({ err: error })

          await this.app.terminate()
        }
      } else {
        logger.error('Migration command not found')
      }
    }
  }

  /**
   * The process has been started
   */
  async ready() {}

  /**
   * Preparing to shutdown the app
   */
  async shutdown() {}
}

```
-------------------------------
[packages/castle/providers/request_validator_provider.ts]

```ts
/// <reference types="@adonisjs/core/providers/vinejs_provider" />

import type { ApplicationService } from '@adonisjs/core/types'
import { Request } from '@adonisjs/core/http'
import type { VineValidator } from '@vinejs/vine'
import type {
  Infer,
  SchemaTypes,
  ErrorReporterContract,
  MessagesProviderContact,
} from '@vinejs/vine/types'

import type { HttpContext } from '@adonisjs/core/http'
import { RequestValidationOptions } from '@adonisjs/core/types/http'

/**
 * Request validator is used validate HTTP request data using
 * VineJS validators. You may validate the request body,
 * files, cookies, and headers.
 */
class RequestValidator {
  #ctx: HttpContext

  constructor(ctx: HttpContext) {
    this.#ctx = ctx
  }

  /**
   * The error reporter method returns the error reporter
   * to use for reporting errors.
   *
   * You can use this function to pick a different error reporter
   * for each HTTP request
   */
  static errorReporter?: (_: HttpContext) => ErrorReporterContract

  /**
   * The messages provider method returns the messages provider to use
   * finding custom error messages
   *
   * You can use this function to pick a different messages provider for
   * each HTTP request
   */
  static messagesProvider?: (_: HttpContext) => MessagesProviderContact

  /**
   * The validate method can be used to validate the request
   * data for the current request using VineJS validators
   */
  validateUsing<Schema extends SchemaTypes, MetaData extends undefined | Record<string, any>>(
    validator: VineValidator<Schema, MetaData>,
    ...[options]: [undefined] extends MetaData
      ? [options?: RequestValidationOptions<MetaData> | undefined]
      : [options: RequestValidationOptions<MetaData>]
  ): Promise<Infer<Schema>> {
    const validatorOptions: RequestValidationOptions<any> = options || {}

    /**
     * Assign request specific error reporter
     */
    if (RequestValidator.errorReporter && !validatorOptions.errorReporter) {
      const errorReporter = RequestValidator.errorReporter(this.#ctx)
      validatorOptions.errorReporter = () => errorReporter
    }

    /**
     * Assign request specific messages provider
     */
    if (RequestValidator.messagesProvider && !validatorOptions.messagesProvider) {
      validatorOptions.messagesProvider = RequestValidator.messagesProvider(this.#ctx)
    }

    /**
     * Data to validate
     */
    const data = validatorOptions.data || {
      ...this.#ctx.request.body(),
      ...this.#ctx.request.allFiles(),
      params: this.#ctx.request.params(),
      headers: this.#ctx.request.headers(),
      cookies: this.#ctx.request.cookiesList(),
      query: this.#ctx.request.qs(),
    }

    return validator.validate(data, validatorOptions as any)
  }
}

export default class RequestValidatorProvider {
  constructor(protected app: ApplicationService) {}

  /**
   * Register bindings to the container
   */
  register() {}

  /**
   * The container bindings have booted
   */
  async boot() {
    /**
     * The validate method can be used to validate the request
     * data for the current request using VineJS validators
     */
    Request.macro('validateUsing', function (this: Request, ...args) {
      return new RequestValidator(this.ctx!).validateUsing(...args)
    })
  }

  /**
   * The application has been booted
   */
  async start() {}

  /**
   * The process has been started
   */
  async ready() {}

  /**
   * Preparing to shutdown the app
   */
  async shutdown() {}
}

```
-------------------------------
[packages/castle/src/columns/enum.ts]

```ts
import { ColumnOptions } from '@adonisjs/lucid/types/model'

export const EnumColumn = (
  rec: Record<string, number>,
  options?: Partial<ColumnOptions>
): Partial<ColumnOptions> => ({
  prepare: (value?: string | null) => {
    if (typeof value !== 'string') {
      return null
    }

    return rec[value] ?? null
  },

  consume: (value?: number | null) => {
    if (typeof value !== 'number') {
      return null
    }

    let result: string | null = null

    for (const key in rec) {
      if (rec[key] === value) {
        result = key
        break
      }
    }

    return result
  },

  ...options,
})

```
-------------------------------
[packages/castle/src/columns/index.ts]

```ts
export { EnumColumn } from './enum.js'
export { JSONColumn } from './json.js'

```
-------------------------------
[packages/castle/src/columns/json.ts]

```ts
import { ColumnOptions } from '@adonisjs/lucid/types/model'

export const JSONColumn = (options?: Partial<ColumnOptions>): Partial<ColumnOptions> => ({
  prepare: (value: any) => {
    if (!value) {
      return null
    }

    return JSON.stringify(value)
  },

  consume: (value: any) => {
    if (!value) {
      return null
    }

    return JSON.parse(value)
  },

  ...options,
})

```
-------------------------------
[packages/castle/src/exceptions/index.ts]

```ts
export { ProcessingException } from './processing_exception.js'

```
-------------------------------
[packages/castle/src/exceptions/processing_exception.ts]

```ts
import { Exception } from '@adonisjs/core/exceptions'
import { HttpContext } from '@adonisjs/core/http'
import { errors } from '@vinejs/vine'
import {
  ProcessingExceptionOptions,
  ProcessingExceptionResponse,
  ValidationError,
} from '../types/processing_exception.js'
import stringHelpers from '@adonisjs/core/helpers/string'
import { getHTTPStatusByKey, getHTTPStatusByCode, HTTPStatusCodeKeys } from '@folie/lib'

class ProcessingException extends Exception {
  title: string
  message: string

  code: HTTPStatusCodeKeys = 'BAD_GATEWAY'
  status: number = getHTTPStatusByKey('BAD_GATEWAY').status

  // ==================

  trace?: string[]

  options?: ProcessingExceptionOptions

  #parseStack = (stack: string): string[] => {
    return stack.split('\n').map((line) => stringHelpers.condenseWhitespace(line))
  }

  constructor(message: string, options?: ProcessingExceptionOptions)
  constructor(options?: ProcessingExceptionOptions)
  constructor(
    paramOne?: string | ProcessingExceptionOptions,
    paramTwo?: ProcessingExceptionOptions
  ) {
    const parsedOptions = typeof paramOne === 'object' ? paramOne : paramTwo
    const parsedMessage =
      typeof paramOne === 'string' ? paramOne : 'An error occurred while processing your request.'

    super(parsedMessage)

    this.title = parsedOptions?.title || 'Processing error'
    this.message = parsedMessage
    this.options = parsedOptions

    if (this.options?.status) {
      const HTTPStatus = getHTTPStatusByKey(this.options.status)

      this.status = HTTPStatus.status
      this.code = HTTPStatus.code
    }

    if (parsedOptions?.stack) {
      this.trace = this.#parseStack(parsedOptions.stack)
    } else {
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor)

        this.trace = this.stack ? this.#parseStack(this.stack) : undefined
      } else {
        const stack = new Error().stack

        this.trace = stack ? this.#parseStack(stack) : undefined
      }
    }
  }

  async handle(e: this, ctx: HttpContext) {
    const res: ProcessingExceptionResponse = {
      id: ctx.request.id() || 'unknown',
      title: e.title,
      status: e.status,
      code: e.code,
      multiple: [
        {
          message: e.message,
          source: e.options?.source,
          meta: e.options?.meta?.public,
        },
      ],
    }

    if (e.options?.multiple) {
      res.multiple = e.options.multiple.map((item) => ({
        message: item.message,
        source: item.source,
        meta: item.meta?.public,
      }))
    }

    ctx.response.status(e.status).json(res)
  }

  async report(e: this, ctx: HttpContext) {
    ctx.logger.error(
      {
        ip: ctx.request.ip(),
        status: e.status,
        multiple: [
          {
            message: e.message,
            source: e.options?.source,
            meta: e.options?.meta?.public,
          },
          ...(e.options?.multiple ?? []),
        ],
        error: e.options?.error,
        trace: e.trace,
      },
      e.title
    )
  }

  static fromError(error: unknown) {
    if (error instanceof ProcessingException) {
      return error
    } else if (error instanceof errors.E_VALIDATION_ERROR) {
      const messages: ValidationError[] = error.messages

      return new ProcessingException(error.message, {
        status: 'BAD_REQUEST',
        stack: error.stack,
        multiple: messages.map((m) => ({
          message: m.message,
          source: m.field,
          meta: {
            public: {
              ...m.meta,
              rule: m.rule,
              index: m.index,
            },
          },
        })),
      })
    } else if (error instanceof Exception) {
      return new ProcessingException(error.message, {
        status: getHTTPStatusByCode(error.status).code,
        stack: error.stack,
        meta: {
          cause: error.cause,
          public: {
            help: error.help,
          },
        },
      })
    } else if (error instanceof Error) {
      return new ProcessingException('Internal Server Error', {
        status: 'INTERNAL_SERVER_ERROR',
        meta: {
          error: {
            name: error.name,
            message: error.message,
            cause: error.cause,
          },
        },
        stack: error.stack,
      })
    } else {
      return new ProcessingException('Internal Server Error', {
        status: 'INTERNAL_SERVER_ERROR',
        meta: {
          reason: 'Unknown error',
        },
        error,
      })
    }
  }
}

export { ProcessingException }

```
-------------------------------
[packages/castle/src/helpers/base32.ts]

```ts
const RFC4648 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'
const RFC4648_HEX = '0123456789ABCDEFGHIJKLMNOPQRSTUV'
const CROCKFORD = '0123456789ABCDEFGHJKMNPQRSTVWXYZ'

type Variant = 'RFC3548' | 'RFC4648' | 'RFC4648-HEX' | 'Crockford'

export function base32Encode(
  input: Uint8Array,
  variant: Variant = 'RFC4648',
  options: Partial<{ padding: boolean }> = {}
): string {
  let alphabet: string
  let defaultPadding: boolean

  switch (variant) {
    case 'RFC3548':
    case 'RFC4648':
      alphabet = RFC4648
      defaultPadding = true
      break
    case 'RFC4648-HEX':
      alphabet = RFC4648_HEX
      defaultPadding = true
      break
    case 'Crockford':
      alphabet = CROCKFORD
      defaultPadding = false
      break
    default:
      throw new Error(`Unknown base32 variant: ${variant as string}`)
  }

  const padding = options.padding ?? defaultPadding
  const length = input.byteLength
  const view = new Uint8Array(input)

  let bits = 0
  let value = 0
  let output = ''

  for (let i = 0; i < length; i++) {
    value = (value << 8) | view[i]!
    bits += 8

    while (bits >= 5) {
      output += alphabet[(value >>> (bits - 5)) & 31]
      bits -= 5
    }
  }

  if (bits > 0) {
    output += alphabet[(value << (5 - bits)) & 31]
  }

  if (padding) {
    while (output.length % 8 !== 0) {
      output += '='
    }
  }

  return output
}

function readChar(alphabet: string, char: string): number {
  const idx = alphabet.indexOf(char)

  if (idx === -1) {
    throw new Error('Invalid character found: ' + char)
  }

  return idx
}

export function base32Decode(input: string, variant: Variant = 'RFC4648'): Uint8Array {
  let alphabet: string
  let cleanedInput: string

  switch (variant) {
    case 'RFC3548':
    case 'RFC4648':
      alphabet = RFC4648
      cleanedInput = input.toUpperCase().replace(/=+$/, '')
      break
    case 'RFC4648-HEX':
      alphabet = RFC4648_HEX
      cleanedInput = input.toUpperCase().replace(/=+$/, '')
      break
    case 'Crockford':
      alphabet = CROCKFORD
      cleanedInput = input.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')
      break
    default:
      throw new Error(`Unknown base32 variant: ${variant as string}`)
  }

  const { length } = cleanedInput

  let bits = 0
  let value = 0

  let index = 0
  const output = new Uint8Array(((length * 5) / 8) | 0)

  for (let i = 0; i < length; i++) {
    value = (value << 5) | readChar(alphabet, cleanedInput[i]!)
    bits += 5

    if (bits >= 8) {
      output[index++] = (value >>> (bits - 8)) & 255
      bits -= 8
    }
  }

  return output
}

/**
 * Turn a string of hexadecimal characters into an Uint8Array
 */
export function hexToUint8Array(hex: string): Uint8Array {
  if (hex.length % 2 !== 0) {
    throw new RangeError('Expected string to be an even number of characters')
  }

  const view = new Uint8Array(hex.length / 2)

  for (let i = 0; i < hex.length; i += 2) {
    view[i / 2] = Number.parseInt(hex.substring(i, i + 2), 16)
  }

  return view
}

```
-------------------------------
[packages/castle/src/helpers/crc32.ts]

```ts
export class CRC32 {
  #lookupTable = [
    0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274,
    2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548,
    1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990,
    1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096,
    1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722,
    1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980,
    1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974,
    1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192,
    31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290,
    251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444,
    476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902,
    314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960,
    984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506,
    879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948,
    654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054,
    702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384,
    2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930,
    2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580,
    2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526,
    2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888,
    2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850,
    2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804,
    3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542,
    2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920,
    3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634,
    3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012,
    4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934,
    4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896,
    3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818,
    3654703836, 1088359270, 936918000, 2847714899, 3736837829, 1202900863, 817233897, 3183342108,
    3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614,
    3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117,
  ]

  #initialCRC = 0xffffffff

  #calculateBytes(bytes: Uint8Array, accumulator?: number): number {
    let crc = accumulator || this.#initialCRC
    for (const byte of bytes) {
      const tableIndex = (crc ^ byte) & 0xff
      const tableVal = this.#lookupTable[tableIndex] as number
      crc = (crc >>> 8) ^ tableVal
    }
    return crc
  }

  #crcToUint(crc: number): number {
    return this.#toUint32(crc ^ 0xffffffff)
  }

  #strToBytes(input: string): Uint8Array {
    const encoder = new TextEncoder()
    return encoder.encode(input)
  }

  #toUint32(num: number): number {
    if (num >= 0) {
      return num
    }
    return 0xffffffff - num * -1 + 1
  }

  calculate(input: string): number {
    return this.forString(input)
  }

  forString(input: string): number {
    const bytes = this.#strToBytes(input)
    return this.forBytes(bytes)
  }

  forBytes(bytes: Uint8Array, accumulator?: number): number {
    const crc = this.#calculateBytes(bytes, accumulator)
    return this.#crcToUint(crc)
  }
}

```
-------------------------------
[packages/castle/src/helpers/get_bearer_token.ts]

```ts
import { HttpContext } from '@adonisjs/core/http'

export const getBearerToken = (ctx: HttpContext) => {
  return ctx.request.header('Authorization')?.replace('Bearer ', '')
}

```
-------------------------------
[packages/castle/src/helpers/handler.ts]

```ts
/// <reference types="@adonisjs/core/providers/vinejs_provider" />

import { HttpContext } from '@adonisjs/core/http'

export const handler = <OUT extends { message?: string; [key: string]: any }>(
  logic: (params: { ctx: HttpContext }) => Promise<OUT>
) => {
  return (ctx: HttpContext) => {
    return logic({ ctx })
  }
}

```
-------------------------------
[packages/castle/src/helpers/index.ts]

```ts
export { serializeDT, serializePage } from './serialize.js'
export { sleep } from './sleep.js'
export { slugify } from './slugify.js'
export { handler } from './handler.js'
export { inspectLog } from './inspect_log.js'

```
-------------------------------
[packages/castle/src/helpers/inspect_log.ts]

```ts
import { inspect } from 'node:util'

interface InspectLogOptions {
  depth?: number
  colors?: boolean
  showHidden?: boolean
}

export const inspectLog = (
  object: unknown, // Use 'unknown' for better type safety
  options: InspectLogOptions = {}
): void => {
  const { depth = 15, colors = true, showHidden = false } = options

  try {
    console.log(inspect(object, { showHidden, depth, colors }) + '\n') // Append newline
  } catch (error) {
    console.error('Error during inspection:', error)
  }
}

```
-------------------------------
[packages/castle/src/helpers/serialize.ts]

```ts
import { LucidRow, ModelPaginatorContract } from '@adonisjs/lucid/types/model'
import { promiseMap } from '@folie/lib'
import vine from '@vinejs/vine'
import { DateTime } from 'luxon'

const paginationMetaValidator = vine.compile(
  vine.object({
    total: vine.number(),
    perPage: vine.number(),
    currentPage: vine.number(),
    lastPage: vine.number(),
    firstPage: vine.number(),
    firstPageUrl: vine.string(),
    lastPageUrl: vine.string(),
    nextPageUrl: vine.string().optional(),
    previousPageUrl: vine.string().nullable(),
  })
)

const serializePage = async <MODAL extends LucidRow, TRANSFER>(
  paginated: ModelPaginatorContract<MODAL>,
  transferFunc: (model: MODAL) => TRANSFER | Promise<TRANSFER>
) => {
  const serialized = paginated.toJSON()

  return {
    data: await promiseMap(serialized.data, async (model) => await transferFunc(model as MODAL)),
    meta: await paginationMetaValidator.validate(serialized.meta),
  }
}

function serializeDT(dt: DateTime): string
function serializeDT(dt: DateTime | null): string | null
function serializeDT(dt: any): any {
  if (dt instanceof DateTime) {
    return dt.toISO()
  } else {
    return null
  }
}

export { serializeDT, serializePage }

```
-------------------------------
[packages/castle/src/helpers/sleep.ts]

```ts
import stringHelpers from '@adonisjs/core/helpers/string'

export const sleep = async (time: string) => {
  const parsedMs = stringHelpers.milliseconds.parse(time)
  await new Promise((resolve) => setTimeout(resolve, parsedMs))
}

```
-------------------------------
[packages/castle/src/helpers/slugify.ts]

```ts
import stringHelpers from '@adonisjs/core/helpers/string'

export const slugify = (str: string) => stringHelpers.slug(str, { lower: true })

```
-------------------------------
[packages/castle/src/miscellaneous/super_json.ts]

```ts
import { DateTime } from 'luxon'
import superjson from 'superjson'

superjson.registerCustom<DateTime, string>(
  {
    isApplicable: (v): v is DateTime => v instanceof DateTime,
    serialize: (v) => {
      const iso = v.toISO()

      if (!iso) {
        throw new Error('Invalid DateTime')
      }

      return iso
    },
    deserialize: (v) => DateTime.fromISO(v),
  },
  'DateTime'
)

export { superjson }

```
-------------------------------
[packages/castle/src/types/castle.ts]

```ts
export type PivotOptions = {
  pivotTable: string
  pivotColumns?: string[]
  localKey?: string
  pivotForeignKey?: string
  relatedKey?: string
  pivotRelatedForeignKey?: string
  pivotTimestamps?:
    | boolean
    | {
        createdAt: string | boolean
        updatedAt: string | boolean
      }
  serializeAs?: string | null
  meta?: any
}

export type ExtendedPivotOptions<Table extends Record<string, string>> = Omit<
  PivotOptions,
  'pivotTable'
> & {
  pivotTable: (table: Record<keyof Table, (column?: string) => string>) => string
}

```
-------------------------------
[packages/castle/src/types/index.ts]

```ts
export type Metadata<T = Record<string, string | number | boolean | null>> = T | null

```
-------------------------------
[packages/castle/src/types/processing_exception.ts]

```ts
import { HTTPStatusCodeKeys } from '@folie/lib'

export type ValidationError = {
  message: string
  field: string
  rule: string
  index?: number
  meta?: Record<string, any>
}

type InternalMeta = {
  reason?: string
  public?: object
  [key: string]: unknown
}

type OptionsBase = {
  /**
   * The HTTP status code applicable to this problem, expressed as a number value. Like: 200, 404
   */
  status?: HTTPStatusCodeKeys

  /**
   * A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
   */
  title?: string

  stack?: string
  error?: unknown
}

export type ProcessingExceptionOptions = OptionsBase & {
  /**
   * An containing references to the primary source of the error.
   */
  source?: string

  /**
   * a meta object containing non-standard meta-information about the error.
   */
  meta?: InternalMeta

  multiple?: {
    message: string
    source?: string
    meta?: InternalMeta
  }[]
}

export type ProcessingExceptionResponse = {
  id: string
  title: string
  status: number
  code: HTTPStatusCodeKeys
  multiple: {
    message: string
    source?: string
    meta?: Record<string, any>
  }[]
}

```
-------------------------------
[packages/castle/src/validators/index.ts]

```ts
import vine, { VineDate } from '@vinejs/vine'
import { DateTime } from 'luxon'

export const PageSchema = vine.number().range([1, 100000])

export const LimitSchema = vine.number().range([1, 100])

export const OrderDirSchema = vine.enum(['asc', 'desc'])

export const OrderSchema = <FIELDS extends readonly string[]>(...fields: FIELDS) => {
  return vine.object({
    by: vine.enum(fields),
    dir: OrderDirSchema.optional(),
  })
}

// ====================

export const MetadataSchema = vine.record(vine.string().minLength(1).maxLength(200))

export const SlugSchema = vine
  .string()
  .minLength(1)
  .maxLength(50)
  .regex(/^[a-z0-9\-]+$/)
  .transform((value) => value.toLowerCase())

export const DateSchema = (callback?: (v: VineDate) => VineDate) => {
  const base = vine.date({ formats: ['iso8601'] })

  return (callback ? callback(base) : base).transform((value) => {
    return DateTime.fromJSDate(value).toUTC()
  })
}

```
-------------------------------
[packages/castle/tests/example.spec.ts]

```ts
import { test } from '@japa/runner'

test.group('Example', () => {
  test('add two numbers', ({ assert }) => {
    assert.equal(1 + 1, 2)
  })
})

```
-------------------------------
[packages/cobalt/bin/playground.ts]

```ts
console.log('Welcome to playground!')

```
-------------------------------
[packages/cobalt/bin/test.ts]

```ts
import { assert } from '@japa/assert'
import { configure, processCLIArgs, run } from '@japa/runner'

processCLIArgs(process.argv.splice(2))

configure({
  files: ['tests/**/*.spec.ts'],
  plugins: [assert()],
})

run()

```
-------------------------------
[packages/cobalt/index.ts]

```ts
/*
|--------------------------------------------------------------------------
| Package entrypoint
|--------------------------------------------------------------------------
|
| Export values from the package entrypoint as you see fit.
|
*/

export { CobaltContext } from './src/context/index.js'
export { useCobaltContext } from './src/context/base.js'

export type { CobaltContextProps, CobaltProviderValues } from './src/context/base.js'

// CONST
export { BREAKPOINTS, ICON_SIZE } from './src/const.js'

```
-------------------------------
[packages/cobalt/package.json]

```json
{
  "name": "@folie/cobalt",
  "description": "",
  "version": "0.0.26",
  "engines": {
    "node": ">=20.6.0"
  },
  "type": "module",
  "files": [
    "build",
    "!build/bin",
    "!build/tests"
  ],
  "exports": {
    ".": "./build/index.js",
    "./types": "./build/src/types/index.js",
    "./components": "./build/src/components/index.js",
    "./helpers": "./build/src/helpers/index.js",
    "./hooks": "./build/src/hooks/index.js",
    "./cobalt.css": "./build/src/styles/cobalt.css"
  },
  "scripts": {
    "clean": "del-cli build",
    "typecheck": "tsc --noEmit",
    "lint": "eslint .",
    "format": "prettier --write \"**/*.{ts,tsx,md}\"",
    "test": "c8 nr quick:test",
    "prebuild": "nr clean",
    "build": "tsc && cpy ./src/styles ./build",
    "quick:test": "tsx bin/test.ts",
    "playground": "tsx bin/playground.ts"
  },
  "devDependencies": {
    "@adonisjs/eslint-config": "^2.0.0-beta.7",
    "@adonisjs/prettier-config": "^1.3.0",
    "@adonisjs/tsconfig": "^1.3.0",
    "@japa/assert": "^3.0.0",
    "@japa/runner": "^3.1.4",
    "@types/node": "^20.14.5",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "c8": "^10.1.2",
    "cpy-cli": "^5.0.0",
    "del-cli": "^5.1.0",
    "eslint": "^9",
    "eslint-plugin-import": "^2.31.0",
    "eslint-plugin-require-extensions": "^0.1.3",
    "prettier": "^3.3.2",
    "typescript": "^5.6"
  },
  "peerDependencies": {
    "@mantine/core": "^7.17",
    "@mantine/dates": "^7.17",
    "@mantine/form": "^7.17",
    "@mantine/hooks": "^7.17",
    "@mantine/modals": "^7.17",
    "@mantine/notifications": "^7.17",
    "@mantine/nprogress": "^7.17",
    "@tabler/icons-react": "^3.26.0",
    "dayjs": "^1.11.13",
    "react": "19",
    "react-dom": "19"
  },
  "author": "MohitXSkull, Folie",
  "license": "Apache-2.0",
  "prettier": "@adonisjs/prettier-config",
  "publishConfig": {
    "access": "public"
  },
  "c8": {
    "exclude": [
      "tests/**"
    ]
  },
  "dependencies": {
    "@folie/blueprint-lib": "workspace:*",
    "case-anything": "3.1.0",
    "dot-prop": "^9.0.0"
  }
}

```
-------------------------------
[packages/cobalt/src/components/action_menu.tsx]

```tsx
import { ICON_SIZE } from '@folie/cobalt'
import { ActionIcon, ActionIconProps, Menu, MenuProps } from '@mantine/core'
import { IconMenu2 } from '@tabler/icons-react'

type Props = {
  children: React.ReactNode
  props?: {
    root?: MenuProps
    actionIcon?: ActionIconProps
  }
}

export const ActionMenu = (props: Props) => {
  return (
    <>
      <Menu width={200} position="bottom-end" trigger="click-hover" {...props.props?.root}>
        <Menu.Target>
          <ActionIcon variant="transparent" c="dimmed" size="sm" {...props.props?.actionIcon}>
            <IconMenu2 size={ICON_SIZE.XS} />
          </ActionIcon>
        </Menu.Target>

        <Menu.Dropdown>{props.children}</Menu.Dropdown>
      </Menu>
    </>
  )
}

```
-------------------------------
[packages/cobalt/src/components/ask_confirmation.tsx]

```tsx
import { Text } from '@mantine/core'
import { modals } from '@mantine/modals'

type Props = Omit<
  Parameters<typeof modals.openConfirmModal>[0],
  'labels' | 'onConfirm' | 'onCancel'
> & {
  loading?: boolean
  title?: string
  message: string
  labels?: {
    confirm?: string
    cancel?: string
  }
}

export const askConfirmation = (props: Props): Promise<boolean> => {
  return new Promise((resolve) => {
    const { loading, title, message, labels, confirmProps, cancelProps, ...rest } = props

    modals.openConfirmModal({
      title: title || 'Please confirm your action',
      children: (
        <>
          <Text size="sm">{message}</Text>
        </>
      ),
      closeOnCancel: true,
      closeOnConfirm: true,
      closeOnEscape: true,
      centered: true,
      withCloseButton: false,
      labels: {
        confirm: labels?.confirm || 'Confirm',
        cancel: labels?.cancel || 'Cancel',
      },
      confirmProps: {
        loading: loading,
        color: 'red.9',
        ...confirmProps,
      },
      cancelProps: {
        disabled: loading,
        autoFocus: true,
        ...cancelProps,
      },
      onConfirm: () => {
        resolve(true)
      },
      onCancel: () => {
        resolve(false)
      },
      ...rest,
    })
  })
}

```
-------------------------------
[packages/cobalt/src/components/for.tsx]

```tsx
import { Children, type ReactNode } from 'react'

type RenderFn<T> = (item: T, index?: number) => ReactNode

export const For = <T,>({ children, each = [] }: { children: RenderFn<T>; each?: T[] }) =>
  Children.toArray(each.map((item, index) => children(item, index)))

```
-------------------------------
[packages/cobalt/src/components/form_wrapper.tsx]

```tsx
import { Grid } from '@mantine/core'

type Props = {
  children: React.ReactNode
  rightSection?: React.ReactNode
}

export const FormWrapper = (props: Props) => (
  <>
    <Grid columns={10}>
      <Grid.Col span={{ base: 10, md: 5, lg: 4 }}>{props.children}</Grid.Col>
      <Grid.Col span="auto">{props.rightSection}</Grid.Col>
    </Grid>
  </>
)

```
-------------------------------
[packages/cobalt/src/components/google_analytics.tsx]

```tsx
import Script from 'next/script.js'

type Props = {
  gtag: string
}

/**
 * Renders the Google Analytics script.
 * Use it in the `pages/_app.tsx` file inside the `Head` component.
 */
const GoogleAnalytics = (props: Props) => (
  <>
    <Script
      strategy="afterInteractive"
      src={`https://www.googletagmanager.com/gtag/js?id=${props.gtag}`}
    />

    <Script id="google-analytics" strategy="afterInteractive">
      {`
          window.dataLayer = window.dataLayer || [];
          function gtag(){window.dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', '${props.gtag}');
        `}
    </Script>
  </>
)

export default GoogleAnalytics

```
-------------------------------
[packages/cobalt/src/components/group.tsx]

```tsx
import { Group, GroupProps } from '@mantine/core'

export const RightGroup = (props: GroupProps) => <Group justify="right" {...props} />

export const LeftGroup = (props: GroupProps) => <Group justify="left" {...props} />

```
-------------------------------
[packages/cobalt/src/components/head_script.tsx]

```tsx
import { ColorSchemeScript } from '@mantine/core'
import { CobaltConfig } from '../types/index.js'

export const HeadScript = (params: CobaltConfig) => (
  <ColorSchemeScript
    defaultColorScheme={params.theme}
    {...(params.forceTheme && {
      forceColorScheme: params.theme === 'dark' ? 'dark' : 'light',
    })}
  />
)

```
-------------------------------
[packages/cobalt/src/components/horizontal_input.tsx]

```tsx
import {
  Collapse,
  Divider,
  Grid,
  GridProps,
  InputDescription,
  InputLabel,
  MantineSpacing,
  Stack,
  StackProps,
} from '@mantine/core'

type Props<T> = {
  label: string
  description: string
  children: React.ReactNode
  expand?: {
    active: boolean
    children: React.ReactNode
  }
  value?: T
  defaultValue?: T
  onChange?: (value: T) => void
  rightAlign?: boolean
  gutter?: MantineSpacing
  props?: {
    root?: StackProps
    grid?: GridProps
  }
}

export const HorizontalInput = <T,>(props: Props<T>) => {
  return (
    <Stack w="100%" {...props.props?.root}>
      <Grid columns={12} gutter={{ base: 'xs', md: props.gutter ?? 100 }} {...props.props?.grid}>
        <Grid.Col span={{ base: 12, md: 6 }}>
          <Stack gap={0}>
            <InputLabel>{props.label}</InputLabel>
            <InputDescription>{props.description}</InputDescription>
          </Stack>
        </Grid.Col>
        <Grid.Col span={{ base: 12, md: 'auto' }}>
          <Stack h="100%" justify="center" align={props.rightAlign ? 'end' : undefined} w="100%">
            {props.children}
          </Stack>
        </Grid.Col>
      </Grid>

      {props.expand && (
        <Collapse in={props.expand?.active === true}>{props.expand?.children}</Collapse>
      )}

      <Divider />
    </Stack>
  )
}

```
-------------------------------
[packages/cobalt/src/components/if.tsx]

```tsx
import { ReactNode } from 'react'

type Props = {
  isTrue: boolean
  children: ReactNode
}

export const If = ({ isTrue, children }: Props) => (isTrue ? children : null)

```
-------------------------------
[packages/cobalt/src/components/index.ts]

```ts
export { HeadScript } from './head_script.js'

export { QueryLoader } from './query_loader.js'
export type { QueryLoaderProps } from './query_loader.js'

export { For } from './for.js'
export { If } from './if.js'
export { RenderAfter } from './render_after.js'
export { Show } from './show.js'

export { FormWrapper } from './form_wrapper.js'
export { LeftGroup, RightGroup } from './group.js'
export { NavigationLoadingBase } from './navigation_loading_base.js'
export { PageContainer } from './page_container.js'
export { PageHeader } from './page_header.js'
export { TriggeredModal } from './triggered_modal.js'
export { VerticalTable } from './vertical_table.js'
export { LogoBase, type LogoBaseProps } from './logo_base.js'
export { ActionMenu } from './action_menu.js'
export { HorizontalInput } from './horizontal_input.js'
export { askConfirmation } from './ask_confirmation.js'

```
-------------------------------
[packages/cobalt/src/components/logo_base.tsx]

```tsx
import { Button, ButtonProps } from '@mantine/core'
import Link from 'next/link.js'

export type LogoBaseProps = ButtonProps & {
  href?: string
  onClick?: () => void
}

export const LogoBase = (props: LogoBaseProps) => {
  const { href, children, onClick, ...restProps } = props

  return (
    <>
      <Button
        size="compact-md"
        w="fit-content"
        p="0"
        variant="transparent"
        {...(onClick ? { onClick } : { renderRoot: (p) => <Link {...p} href={href ?? '/'} /> })}
        {...restProps}
      >
        {children}
      </Button>
    </>
  )
}

```
-------------------------------
[packages/cobalt/src/components/navigation_loading_base.tsx]

```tsx
import { Center, Modal, ModalProps } from '@mantine/core'

type Props = Omit<ModalProps, 'onClose' | 'fullScreen' | 'withCloseButton'> & {
  opened: boolean
  children: React.ReactNode
  center: React.ReactNode
}

export const NavigationLoadingBase = (props: Props) => {
  const { opened, children, center, bg, ...rest } = props

  return (
    <>
      <Modal
        opened={opened}
        fullScreen
        onClose={() => {}}
        withCloseButton={false}
        transitionProps={{ transition: 'fade', duration: 500, exitDelay: 1500 }}
        styles={{
          body: {
            padding: 0,
          },
        }}
        bg={bg}
        {...rest}
      >
        <Center h="100vh" bg={bg}>
          {center}
        </Center>
      </Modal>

      <div
        style={{
          opacity: props.opened ? 0 : 1,
        }}
      >
        {children}
      </div>
    </>
  )
}

```
-------------------------------
[packages/cobalt/src/components/page_container.tsx]

```tsx
import { Container, ContainerProps, Stack, StackProps } from '@mantine/core'

type Props = ContainerProps & {
  props?: {
    stack?: StackProps
  }
}

export const PageContainer = (props: Props) => {
  const { children, props: internalProps, ...restProps } = props

  return (
    <>
      <Container size="xl" w="100%" h="100%" mt="xl" {...restProps}>
        <Stack h="100%" {...internalProps?.stack}>
          {children}
        </Stack>
      </Container>
    </>
  )
}

```
-------------------------------
[packages/cobalt/src/components/page_header.tsx]

```tsx
import { ICON_SIZE } from '@folie/cobalt'
import { Button, Group, Stack, Text, Title, TitleOrder } from '@mantine/core'
import { IconArrowNarrowLeft } from '@tabler/icons-react'
import { useRouter } from 'next/router.js'

type Props = {
  title: string
  description?: string
  children?: React.ReactNode
  withBackBtn?: boolean
  order?: TitleOrder
}

export const PageHeader = (props: Props) => {
  const router = useRouter()

  return (
    <>
      <Stack gap="xs">
        {props.withBackBtn && (
          <Button
            size="compact-xs"
            variant="transparent"
            onClick={() => router.back()}
            w="fit-content"
            p={0}
            leftSection={<IconArrowNarrowLeft size={ICON_SIZE.SM} />}
          >
            Go Back
          </Button>
        )}

        <Group justify="space-between" align="start">
          <Stack gap="0">
            <Title order={props.order || 3}>{props.title}</Title>

            <Text c="dimmed" size="sm">
              {props.description}
            </Text>
          </Stack>

          {props.children}
        </Group>
      </Stack>
    </>
  )
}

```
-------------------------------
[packages/cobalt/src/components/query_loader.tsx]

```tsx
import { UseQueryResult } from '@tanstack/react-query'

export type QueryLoaderProps<OUT> = {
  children: (data: NonNullable<OUT>) => React.ReactNode
  conditions?: (data: NonNullable<OUT>) => React.ReactNode
  query: UseQueryResult<OUT, unknown>
  isLoading?: React.ReactNode
  isError?: React.ReactNode
  noData?: React.ReactNode
}

export const QueryLoader = <OUT,>(props: QueryLoaderProps<OUT>) => {
  if (props.query.isLoading) {
    return props.isLoading ?? 'Loading...'
  }

  if (props.query.isError) {
    return props.isError ?? 'Error'
  }

  const { data } = props.query

  if (!data) {
    return props.noData ?? 'No data'
  }

  if (props.conditions) {
    const conditions = props.conditions(data)

    if (conditions !== null || conditions !== undefined) {
      return conditions
    }
  }

  return props.children(data)
}

```
-------------------------------
[packages/cobalt/src/components/render_after.tsx]

```tsx
import { type ReactNode, useEffect, useState } from 'react'

type Props = {
  delay?: number
  children: ReactNode
}

export function RenderAfter({ delay = 1000, children }: Props) {
  const [ready, setReady] = useState(false)

  useEffect(() => {
    const timer = setTimeout(() => setReady(true), delay)
    return () => clearTimeout(timer)
  }, [ready])

  return ready ? children : null
}

```
-------------------------------
[packages/cobalt/src/components/show.tsx]

```tsx
import { Children } from 'react'
import { If } from './if.js'

import { type ReactNode } from 'react'

type Props = {
  children: (ReactNode & {
    props: {
      isTrue?: boolean
    }
  })[]
}

type ElseProps = {
  render?: () => ReactNode
  children?: ReactNode
}

export const Show = ({ children }: Props) => {
  let when: ReactNode | null = null
  let otherwise: ReactNode | null = null

  Children.forEach(children, (child) => {
    if (child.props.isTrue === undefined) {
      otherwise = child
    } else if (!when && child.props.isTrue === true) {
      when = child
    }
  })

  return (when || otherwise) as ReactNode
}

Show.When = If
Show.Else = ({ render, children }: ElseProps) => (render ? render() : children)

```
-------------------------------
[packages/cobalt/src/components/triggered_modal.tsx]

```tsx
import { Modal, ModalProps, Stack } from '@mantine/core'

type Props = Omit<ModalProps, 'onClose'> & {
  children: React.ReactNode
  opened: boolean
  close: () => void
  open: () => void
  target: React.ReactNode
}

export const TriggeredModal = (props: Props) => {
  const { children, opened, close, open, target, ...rest } = props

  return (
    <>
      <Modal {...rest} withCloseButton={false} centered opened={opened} onClose={close}>
        <Stack>{children}</Stack>
      </Modal>

      {target}
    </>
  )
}

```
-------------------------------
[packages/cobalt/src/components/vertical_table.tsx]

```tsx
import { DefaultMantineColor, InputLabel, Stack, Table, TableProps, Text } from '@mantine/core'
import { randomId } from '@mantine/hooks'
import { capitalCase } from 'case-anything'

export const VerticalTable = (props: {
  value: Record<string, unknown> | null
  autoCase?: boolean
  props?: TableProps
  label?: string
  bg?: DefaultMantineColor
  noTableBorder?: boolean
  emptyValue?: string
}) => {
  if (!props.value || Object.keys(props.value).length === 0) {
    return props.emptyValue ?? '-'
  }

  return (
    <>
      <Stack gap={0}>
        {props.label && (
          <>
            <InputLabel>{props.label}</InputLabel>
          </>
        )}
        <Table
          {...props.props}
          variant="vertical"
          layout="fixed"
          withTableBorder={!props.noTableBorder}
          bg={props.bg || 'white'}
        >
          <Table.Tbody bg="white">
            {Object.entries(props.value).map(([key, value]) => (
              <Table.Tr key={randomId()}>
                <Table.Th w={160} bg="transparent">
                  <Text size="sm" c="dimmed">
                    {props.autoCase ? capitalCase(key) : key}
                  </Text>
                </Table.Th>
                <Table.Td>
                  {(() => {
                    switch (typeof value) {
                      case null:
                      case 'undefined': {
                        return (
                          <>
                            <Text size="sm">-</Text>
                          </>
                        )
                      }

                      case 'string':
                      case 'number':
                      case 'boolean': {
                        return (
                          <>
                            <Text size="sm">{capitalCase(String(value))}</Text>
                          </>
                        )
                      }

                      default:
                        return value as React.ReactNode
                    }
                  })()}
                </Table.Td>
              </Table.Tr>
            ))}
          </Table.Tbody>
        </Table>
      </Stack>
    </>
  )
}

```
-------------------------------
[packages/cobalt/src/const.ts]

```ts
export const BREAKPOINTS = {
  XS: '36em',
  SM: '48em',
  MD: '62em',
  LG: '75em',
  XL: '87.5em',
}

export const ICON_SIZE = {
  XS: 16,
  SM: 20,
  MD: 24,
  LG: 32,
  XL: 40,
}

```
-------------------------------
[packages/cobalt/src/context/base.tsx]

```tsx
import { createSafeContext, MantineThemeOverride } from '@mantine/core'
import { NextRouter } from 'next/router.js'
import { CobaltConfig } from '../types/cobalt_config.js'

export type CobaltContextProps = {
  children: React.ReactNode
  mantine: MantineThemeOverride
  config: CobaltConfig
  router: NextRouter
  navigation?: {
    started: (url: string) => void
    completed: () => void
  }
}

export type CobaltProviderValues = {}

export const [CobaltProvider, useCobaltContext] = createSafeContext<CobaltProviderValues>(
  'The component was not found in the tree under the "CobaltProvider"'
)

```
-------------------------------
[packages/cobalt/src/context/index.tsx]

```tsx
import { CobaltContextProps, CobaltProvider } from './base.js'
import { MantineProvider } from '@mantine/core'
import { ModalsProvider } from '@mantine/modals'
import { NavigationProgress, nprogress } from '@mantine/nprogress'
import { Notifications } from '@mantine/notifications'
import { useEffect } from 'react'

export const CobaltContext = (props: CobaltContextProps) => {
  const startProgress = (url: string) => {
    if (props.navigation?.started) {
      props.navigation.started(url)
    } else {
      nprogress.start()
    }
  }

  const completeProgress = () => {
    if (props.navigation?.completed) {
      props.navigation.completed()
    } else {
      nprogress.complete()
    }
  }

  useEffect(() => {
    props.router.events.on('routeChangeStart', startProgress)
    props.router.events.on('routeChangeComplete', completeProgress)
    props.router.events.on('routeChangeError', completeProgress)

    return () => {
      props.router.events.off('routeChangeStart', startProgress)
      props.router.events.off('routeChangeComplete', completeProgress)
      props.router.events.off('routeChangeError', completeProgress)
    }
  }, [props.router.events])

  return (
    <>
      <CobaltProvider value={{}}>
        <MantineProvider
          theme={props.mantine}
          defaultColorScheme={props.config.theme}
          {...(props.config.forceTheme && {
            forceColorScheme: props.config.theme === 'dark' ? 'dark' : 'light',
          })}
        >
          <ModalsProvider>
            {!props.navigation && <NavigationProgress size={5} />}

            <Notifications />

            {props.children}
          </ModalsProvider>
        </MantineProvider>
      </CobaltProvider>
    </>
  )
}

```
-------------------------------
[packages/cobalt/src/helpers/if_props.ts]

```ts
export const ifProps = <PROPS extends object>(params: {
  condition: boolean
  true: PROPS
  false?: PROPS
  merge?: PROPS[]
}) => {
  const merge = params.merge?.reduce((acc, prop) => ({ ...acc, ...prop }), {}) || {}

  if (params.condition) {
    return {
      ...params.true,
      ...merge,
    }
  }

  return params.false ? { ...params.false, ...merge } : merge
}

export const ifProp = <PROPS extends string | number | boolean>(
  condition: boolean,
  cTrue: PROPS,
  cFalse?: PROPS
) => {
  if (condition) {
    return cTrue
  }

  return cFalse
}

```
-------------------------------
[packages/cobalt/src/helpers/index.ts]

```ts
export { ifProp, ifProps } from './if_props.js'

```
-------------------------------
[packages/cobalt/src/hooks/index.ts]

```ts
export * from './use_page_visibility.js'

```
-------------------------------
[packages/cobalt/src/hooks/use_page_visibility.ts]

```ts
import { useState, useEffect } from 'react'

export type VisibilityState = 'visible' | 'hidden' | 'prerender' | 'unloaded' | undefined

const usePageVisibility = (): VisibilityState => {
  const [visibilityState, setVisibilityState] = useState<VisibilityState>(
    typeof document !== 'undefined' ? document.visibilityState : undefined
  )

  useEffect(() => {
    const handleVisibilityChange = () => {
      setVisibilityState(document.visibilityState)
    }

    if (typeof document !== 'undefined') {
      document.addEventListener('visibilitychange', handleVisibilityChange)
    }

    return () => {
      if (typeof document !== 'undefined') {
        document.removeEventListener('visibilitychange', handleVisibilityChange)
      }
    }
  })

  return visibilityState
}

export default usePageVisibility

```
-------------------------------
[packages/cobalt/src/styles/cobalt.css]

```css
* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;

  scrollbar-width: none;
  -ms-overflow-style: none;

  -webkit-tap-highlight-color: transparent;
}

*::-webkit-scrollbar {
  display: none;
}

a {
  color: inherit;
  text-decoration: none;
}

/* ::-moz-selection {
  color: var(--mantine-color-white);
  background: var(--mantine-color-red-7);
}

::selection {
  color: var(--mantine-color-white);
  background: var(--mantine-color-red-7);
} */

html,
body {
  user-select: none;
  scroll-behavior: smooth;
  max-width: 100vw;
  overflow-x: hidden;
}

body {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

```
-------------------------------
[packages/cobalt/src/types/cobalt_config.ts]

```ts
import { MantineColorScheme } from '@mantine/core'

export type CobaltConfig = {
  theme: MantineColorScheme
  forceTheme: boolean
}

```
-------------------------------
[packages/cobalt/src/types/index.ts]

```ts
export type { CobaltConfig } from './cobalt_config.js'

```
-------------------------------
[packages/cobalt/tests/example.spec.ts]

```ts
import { test } from '@japa/runner'

test.group('Example', () => {
  test('add two numbers', ({ assert }) => {
    assert.equal(1 + 1, 2)
  })
})

```
-------------------------------
[packages/cobalt_animation/bin/playground.ts]

```ts
console.log('Welcome to playground!')

```
-------------------------------
[packages/cobalt_animation/bin/test.ts]

```ts
import { assert } from '@japa/assert'
import { configure, processCLIArgs, run } from '@japa/runner'

processCLIArgs(process.argv.splice(2))

configure({
  files: ['tests/**/*.spec.ts'],
  plugins: [assert()],
})

run()

```
-------------------------------
[packages/cobalt_animation/index.ts]

```ts
/*
|--------------------------------------------------------------------------
| Package entrypoint
|--------------------------------------------------------------------------
|
| Export values from the package entrypoint as you see fit.
|
*/

export { Reveal } from './src/components/reveal.js'
export { Breathing } from './src/components/breathing.js'
export { GradientBG } from './src/components/gradient_bg.js'
export { CharacterSwap } from './src/components/character_swap.js'

```
-------------------------------
[packages/cobalt_animation/package.json]

```json
{
  "name": "@folie/cobalt-animation",
  "description": "",
  "version": "0.0.7",
  "engines": {
    "node": ">=20.6.0"
  },
  "type": "module",
  "files": [
    "build",
    "!build/bin",
    "!build/tests"
  ],
  "exports": {
    ".": "./build/index.js",
    "./cobalt-animation.css": "./build/cobalt-animation.css"
  },
  "scripts": {
    "clean": "del-cli build",
    "typecheck": "tsc --noEmit",
    "lint": "eslint .",
    "format": "prettier --write \"**/*.{ts,tsx,md}\"",
    "test": "c8 nr quick:test",
    "prebuild": "nr clean",
    "build": "tsc && npx tailwindcss -i ./src/styles/global.css -o ./build/cobalt-animation.css -m",
    "quick:test": "tsx bin/test.ts",
    "playground": "tsx bin/playground.ts"
  },
  "devDependencies": {
    "@adonisjs/eslint-config": "^2.0.0-beta.7",
    "@adonisjs/prettier-config": "^1.3.0",
    "@adonisjs/tsconfig": "^1.3.0",
    "@japa/assert": "^3.0.0",
    "@japa/runner": "^3.1.4",
    "@types/lodash": "^4.17.14",
    "@types/node": "^20.14.5",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "c8": "^10.1.2",
    "del-cli": "^5.1.0",
    "eslint": "^9",
    "eslint-plugin-import": "^2.31.0",
    "prettier": "^3.3.2",
    "tailwindcss": "^3.4.17",
    "typescript": "^5.6"
  },
  "peerDependencies": {
    "motion": "^11.16.0",
    "next": "15.1.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0"
  },
  "author": "MohitXSkull, Folie",
  "license": "Apache-2.0",
  "prettier": "@adonisjs/prettier-config",
  "publishConfig": {
    "access": "public"
  },
  "c8": {
    "exclude": [
      "tests/**"
    ]
  },
  "dependencies": {
    "clsx": "^2.1.1",
    "tailwind-merge": "^2.6.0"
  }
}

```
-------------------------------
[packages/cobalt_animation/postcss.config.js]

```js
export default {
  plugins: {
    autoprefixer: {},
    tailwindcss: {},
  },
}

```
-------------------------------
[packages/cobalt_animation/src/components/breathing.tsx]

```tsx
'use client'

import { motion, Transition, Variants } from 'motion/react'

type Props = {
  label: string
  fromFontVariationSettings: string
  toFontVariationSettings: string
  transition?: Transition
  staggerDuration?: number
  staggerFrom?: 'first' | 'last' | 'center' | number
  repeatDelay?: number
  className?: string
  onClick?: () => void
}

export const Breathing = ({
  label,
  fromFontVariationSettings,
  toFontVariationSettings,
  transition = {
    duration: 1.5,
    ease: 'easeInOut',
  },
  staggerDuration = 0.1,
  staggerFrom = 'first',
  repeatDelay = 0.1,
  className,
  onClick,
  ...props
}: Props) => {
  const letterVariants: Variants = {
    initial: { fontVariationSettings: fromFontVariationSettings },
    animate: (i) => ({
      fontVariationSettings: toFontVariationSettings,
      transition: {
        ...transition,
        repeat: Infinity,
        repeatType: 'mirror',
        delay: i * staggerDuration,
        repeatDelay: repeatDelay,
      },
    }),
  }

  const getCustomIndex = (index: number, total: number) => {
    if (typeof staggerFrom === 'number') {
      return Math.abs(index - staggerFrom)
    }
    switch (staggerFrom) {
      case 'first':
        return index
      case 'last':
        return total - 1 - index
      case 'center':
      default:
        return Math.abs(index - Math.floor(total / 2))
    }
  }

  const letters = label.split('')

  return (
    <span className={`${className}`} onClick={onClick} {...props}>
      {letters.map((letter: string, i: number) => (
        <motion.span
          key={i}
          className="inline-block whitespace-pre"
          aria-hidden="true"
          variants={letterVariants}
          initial="initial"
          animate="animate"
          custom={getCustomIndex(i, letters.length)}
        >
          {letter}
        </motion.span>
      ))}
      <span className="sr-only">{label}</span>
    </span>
  )
}

```
-------------------------------
[packages/cobalt_animation/src/components/character_swap.tsx]

```tsx
import { useState } from 'react'
import { AnimationOptions, motion, stagger, useAnimate } from 'motion/react'

type Props = {
  label: string
  reverse?: boolean
  transition?: AnimationOptions
  staggerDuration?: number
  staggerFrom?: 'first' | 'last' | 'center' | number
  className?: string
  onClick?: () => void
}
export const CharacterSwap = ({
  label,
  reverse = true,
  transition = {
    type: 'spring',
    duration: 0.7,
  },
  staggerDuration = 0.03,
  staggerFrom = 'first',
  className,
  onClick,
  ...props
}: Props) => {
  const [scope, animate] = useAnimate()
  const [blocked, setBlocked] = useState(false)

  const hoverStart = () => {
    if (blocked) return

    setBlocked(true)

    const mergeTransition = (baseTransition: AnimationOptions) => ({
      ...baseTransition,
      delay: stagger(staggerDuration, {
        from: staggerFrom,
      }),
    })

    animate('.letter', { y: reverse ? '100%' : '-100%' }, mergeTransition(transition)).then(() => {
      animate(
        '.letter',
        {
          y: 0,
        },
        {
          duration: 0,
        }
      ).then(() => {
        setBlocked(false)
      })
    })

    animate(
      '.letter-secondary',
      {
        top: '0%',
      },
      mergeTransition(transition)
    ).then(() => {
      animate(
        '.letter-secondary',
        {
          top: reverse ? '-100%' : '100%',
        },
        {
          duration: 0,
        }
      )
    })
  }

  return (
    <span
      className={`flex justify-center items-center relative overflow-hidden  ${className} `}
      onMouseEnter={hoverStart}
      onClick={onClick}
      ref={scope}
      {...props}
    >
      <span className="sr-only">{label}</span>

      {label.split('').map((letter: string, i: number) => {
        return (
          <span className="whitespace-pre relative flex" key={i}>
            <motion.span className={`relative letter`} style={{ top: 0 }}>
              {letter}
            </motion.span>
            <motion.span
              className="absolute letter-secondary "
              aria-hidden={true}
              style={{ top: reverse ? '-100%' : '100%' }}
            >
              {letter}
            </motion.span>
          </span>
        )
      })}
    </span>
  )
}

```
-------------------------------
[packages/cobalt_animation/src/components/gradient_bg.tsx]

```tsx
import React, { useMemo, useRef } from 'react'
import { useDimensions } from '../lib/hooks/use_dimensions.js'
import { cn } from '../lib/helpers.js'

type Props = {
  colors: string[]
  speed?: number
  blur?: 'light' | 'medium' | 'heavy'
}

const randomInt = (min: number, max: number) => {
  return Math.floor(Math.random() * (max - min + 1)) + min
}

export const GradientBG: React.FC<Props> = ({ colors, speed = 5, blur = 'light' }) => {
  const containerRef = useRef<HTMLDivElement>(null)
  const dimensions = useDimensions(containerRef)

  const circleSize = useMemo(
    () => Math.max(dimensions.width, dimensions.height),
    [dimensions.width, dimensions.height]
  )

  const blurClass = blur === 'light' ? 'blur-2xl' : blur === 'medium' ? 'blur-3xl' : 'blur-[100px]'

  return (
    <div ref={containerRef} className="absolute inset-0 overflow-hidden">
      <div className={cn(`absolute inset-0`, blurClass)}>
        {colors.map((color, index) => (
          <svg
            key={index}
            className="absolute animate-background-gradient"
            style={
              {
                'top': `${Math.random() * 50}%`,
                'left': `${Math.random() * 50}%`,
                '--background-gradient-speed': `${1 / speed}s`,
                '--tx-1': Math.random() - 0.5,
                '--ty-1': Math.random() - 0.5,
                '--tx-2': Math.random() - 0.5,
                '--ty-2': Math.random() - 0.5,
                '--tx-3': Math.random() - 0.5,
                '--ty-3': Math.random() - 0.5,
                '--tx-4': Math.random() - 0.5,
                '--ty-4': Math.random() - 0.5,
              } as React.CSSProperties
            }
            width={circleSize * randomInt(0.5, 1.5)}
            height={circleSize * randomInt(0.5, 1.5)}
            viewBox="0 0 100 100"
          >
            <circle cx="50" cy="50" r="50" fill={color} />
          </svg>
        ))}
      </div>
    </div>
  )
}

```
-------------------------------
[packages/cobalt_animation/src/components/reveal.tsx]

```tsx
import {
  forwardRef,
  useCallback,
  useEffect,
  useImperativeHandle,
  useMemo,
  useRef,
  useState,
} from 'react'
import { AnimationOptions, motion } from 'motion/react'
import { cn } from '../lib/helpers.js'

interface TextProps {
  children: React.ReactNode
  reverse?: boolean
  transition?: AnimationOptions
  splitBy?: 'words' | 'characters' | 'lines' | string
  staggerDuration?: number
  staggerFrom?: 'first' | 'last' | 'center' | 'random' | number
  containerClassName?: string
  wordLevelClassName?: string
  elementLevelClassName?: string
  onClick?: () => void
  onStart?: () => void
  onComplete?: () => void
  autoStart?: boolean // Whether to start the animation automatically
}

// Ref interface to allow external control of the animation
export interface RevealRef {
  startAnimation: () => void
  reset: () => void
}

interface WordObject {
  characters: string[]
  needsSpace: boolean
}

export const Reveal = forwardRef<RevealRef, TextProps>(
  (
    {
      children,
      reverse = false,
      transition = {
        type: 'spring',
        stiffness: 190,
        damping: 22,
      },
      splitBy = 'words',
      staggerDuration = 0.2,
      staggerFrom = 'first',
      containerClassName,
      wordLevelClassName,
      elementLevelClassName,
      onClick,
      onStart,
      onComplete,
      autoStart = true,
      ...props
    },
    ref
  ) => {
    const containerRef = useRef<HTMLSpanElement>(null)
    const text = typeof children === 'string' ? children : children?.toString() || ''
    const [isAnimating, setIsAnimating] = useState(false)

    // handy function to split text into characters with support for unicode and emojis
    const splitIntoCharacters = (text: string): string[] => {
      if (typeof Intl !== 'undefined' && 'Segmenter' in Intl) {
        const segmenter = new Intl.Segmenter('en', { granularity: 'grapheme' })
        return Array.from(segmenter.segment(text), ({ segment }) => segment)
      }
      // Fallback for browsers that don't support Intl.Segmenter
      return Array.from(text)
    }

    // Split text based on splitBy parameter
    const elements = useMemo(() => {
      const words = text.split(' ')
      if (splitBy === 'characters') {
        return words.map((word, i) => ({
          characters: splitIntoCharacters(word),
          needsSpace: i !== words.length - 1,
        }))
      }
      return splitBy === 'words'
        ? text.split(' ')
        : splitBy === 'lines'
          ? text.split('\n')
          : text.split(splitBy)
    }, [text, splitBy])

    // Calculate stagger delays based on staggerFrom
    const getStaggerDelay = useCallback(
      (index: number) => {
        const total =
          splitBy === 'characters'
            ? elements.reduce(
                (acc, word) =>
                  acc +
                  (typeof word === 'string'
                    ? 1
                    : word.characters.length + (word.needsSpace ? 1 : 0)),
                0
              )
            : elements.length
        if (staggerFrom === 'first') return index * staggerDuration
        if (staggerFrom === 'last') return (total - 1 - index) * staggerDuration
        if (staggerFrom === 'center') {
          const center = Math.floor(total / 2)
          return Math.abs(center - index) * staggerDuration
        }
        if (staggerFrom === 'random') {
          const randomIndex = Math.floor(Math.random() * total)
          return Math.abs(randomIndex - index) * staggerDuration
        }
        return Math.abs(staggerFrom - index) * staggerDuration
      },
      [elements.length, staggerFrom, staggerDuration]
    )

    const startAnimation = useCallback(() => {
      setIsAnimating(true)
      onStart?.()
    }, [onStart])

    // Expose the startAnimation function via ref
    useImperativeHandle(ref, () => ({
      startAnimation,
      reset: () => setIsAnimating(false),
    }))

    // Auto start animation
    useEffect(() => {
      if (autoStart) {
        startAnimation()
      }
    }, [autoStart])

    const variants = {
      hidden: { y: reverse ? '-100%' : '100%' },
      visible: (i: number) => ({
        y: 0,
        transition: {
          ...transition,
          delay: ((transition?.delay as number) || 0) + getStaggerDelay(i),
        },
      }),
    }

    return (
      <span
        className={cn(
          containerClassName,
          'flex flex-wrap whitespace-pre-wrap',
          splitBy === 'lines' && 'flex-col'
        )}
        onClick={onClick}
        ref={containerRef}
        {...props}
      >
        <span className="sr-only">{text}</span>

        {(splitBy === 'characters'
          ? (elements as WordObject[])
          : (elements as string[]).map((el, i) => ({
              characters: [el],
              needsSpace: i !== elements.length - 1,
            }))
        ).map((wordObj, wordIndex, array) => {
          const previousCharsCount = array
            .slice(0, wordIndex)
            .reduce((sum, word) => sum + word.characters.length, 0)

          return (
            <span
              key={wordIndex}
              aria-hidden="true"
              className={cn('inline-flex overflow-hidden', wordLevelClassName)}
            >
              {wordObj.characters.map((char, charIndex) => (
                <span
                  className={cn(elementLevelClassName, 'whitespace-pre-wrap relative')}
                  key={charIndex}
                >
                  <motion.span
                    custom={previousCharsCount + charIndex}
                    initial="hidden"
                    animate={isAnimating ? 'visible' : 'hidden'}
                    variants={variants}
                    onAnimationComplete={
                      wordIndex === elements.length - 1 &&
                      charIndex === wordObj.characters.length - 1
                        ? onComplete
                        : undefined
                    }
                    className="inline-block"
                  >
                    {char}
                  </motion.span>
                </span>
              ))}
              {wordObj.needsSpace && <span> </span>}
            </span>
          )
        })}
      </span>
    )
  }
)

```
-------------------------------
[packages/cobalt_animation/src/lib/helpers.ts]

```ts
import { clsx, type ClassValue } from 'clsx'
import { twMerge } from 'tailwind-merge'

export const cn = (...inputs: ClassValue[]) => {
  return twMerge(clsx(inputs))
}

```
-------------------------------
[packages/cobalt_animation/src/lib/hooks/use_dimensions.tsx]

```tsx
import { RefObject, useEffect, useState } from 'react'

type Dimensions = {
  width: number
  height: number
}

export const useDimensions = (ref: RefObject<HTMLElement | SVGElement | null>): Dimensions => {
  const [dimensions, setDimensions] = useState<Dimensions>({
    width: 0,
    height: 0,
  })

  useEffect(() => {
    const updateDimensions = () => {
      if (ref.current) {
        const { width, height } = ref.current.getBoundingClientRect()
        setDimensions({ width, height })
      }
    }

    updateDimensions()
    window.addEventListener('resize', updateDimensions)

    return () => window.removeEventListener('resize', updateDimensions)
  }, [ref])

  return dimensions
}

```
-------------------------------
[packages/cobalt_animation/src/styles/global.css]

```css
@import 'tailwindcss/base';
@import 'tailwindcss/components';
@import 'tailwindcss/utilities';

```
-------------------------------
[packages/cobalt_animation/tailwind.config.js]

```js
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./src/**/*.tsx'],
  theme: {
    extend: {},
    animation: {
      'background-gradient':
        'background-gradient var(--background-gradient-speed, 15s) cubic-bezier(0.445, 0.05, 0.55, 0.95) infinite',
    },
    keyframes: {
      'background-gradient': {
        '0%, 100%': {
          transform: 'translate(0, 0)',
          animationDelay: 'var(--background-gradient-delay, 0s)',
        },
        '20%': {
          transform: 'translate(calc(100% * var(--tx-1, 1)), calc(100% * var(--ty-1, 1)))',
        },
        '40%': {
          transform: 'translate(calc(100% * var(--tx-2, -1)), calc(100% * var(--ty-2, 1)))',
        },
        '60%': {
          transform: 'translate(calc(100% * var(--tx-3, 1)), calc(100% * var(--ty-3, -1)))',
        },
        '80%': {
          transform: 'translate(calc(100% * var(--tx-4, -1)), calc(100% * var(--ty-4, -1)))',
        },
      },
    },
  },
  plugins: [],
}

```
-------------------------------
[packages/cobalt_animation/tests/example.spec.ts]

```ts
import { test } from '@japa/runner'

test.group('Example', () => {
  test('add two numbers', ({ assert }) => {
    assert.equal(1 + 1, 2)
  })
})

```
-------------------------------
[packages/gate/bin/playground.ts]

```ts
console.log('Welcome to playground!')

```
-------------------------------
[packages/gate/bin/test.ts]

```ts
import { assert } from '@japa/assert'
import { configure, processCLIArgs, run } from '@japa/runner'

processCLIArgs(process.argv.splice(2))

configure({
  files: ['tests/**/*.spec.ts'],
  plugins: [assert()],
})

run()

```
-------------------------------
[packages/gate/index.ts]

```ts
/*
|--------------------------------------------------------------------------
| Package entrypoint
|--------------------------------------------------------------------------
|
| Export values from the package entrypoint as you see fit.
|
*/

export { GateError } from './src/error.js'
export { Gate } from './src/client.js'

```
-------------------------------
[packages/gate/package.json]

```json
{
  "name": "@folie/gate",
  "description": "",
  "version": "0.0.8",
  "engines": {
    "node": ">=20.6.0"
  },
  "type": "module",
  "files": [
    "build",
    "!build/bin",
    "!build/tests"
  ],
  "exports": {
    ".": "./build/index.js",
    "./types": {
      "types": "./build/src/types/index.d.ts",
      "default": "./build/src/types/index.js"
    }
  },
  "scripts": {
    "clean": "del-cli build",
    "typecheck": "tsc --noEmit",
    "lint": "eslint .",
    "format": "prettier --write \"**/*.{ts,tsx,md}\"",
    "test": "c8 nr quick:test",
    "prebuild": "nr clean",
    "build": "tsc",
    "quick:test": "tsx bin/test.ts",
    "playground": "tsx bin/playground.ts"
  },
  "devDependencies": {
    "@adonisjs/eslint-config": "^2.0.0-beta.7",
    "@adonisjs/prettier-config": "^1.3.0",
    "@adonisjs/tsconfig": "^1.3.0",
    "@japa/assert": "^3.0.0",
    "@japa/runner": "^3.1.4",
    "@types/node": "^20.14.5",
    "@types/qs": "^6.9.17",
    "c8": "^10.1.2",
    "del-cli": "^5.1.0",
    "eslint": "^9",
    "prettier": "^3.3.2",
    "typescript": "^5.6"
  },
  "author": "MohitXSkull, Folie",
  "license": "Apache-2.0",
  "prettier": "@adonisjs/prettier-config",
  "publishConfig": {
    "access": "public"
  },
  "c8": {
    "exclude": [
      "tests/**"
    ]
  },
  "dependencies": {
    "@folie/blueprint-lib": "workspace:*",
    "@folie/lib": "workspace:*",
    "axios": "^1.8.2",
    "zod": "^3.24.1"
  }
}

```
-------------------------------
[packages/gate/src/client.ts]

```ts
import { Header, Token } from './types.js'
import axios, { type AxiosRequestConfig, AxiosInstance, AxiosResponse, isAxiosError } from 'axios'
import qs from 'qs'
import { GateError } from './error.js'
import { ApiEndpoints } from '@folie/blueprint-lib'

export class Gate<const Endpoints extends ApiEndpoints> {
  #axios: AxiosInstance

  #endpoints: Endpoints
  #baseURL: string

  #token?: Token
  #header?: Header

  constructor(config: { baseURL: URL; endpoints: Endpoints; token?: Token; header?: Header }) {
    this.#endpoints = config.endpoints
    this.#baseURL = config.baseURL.origin

    if (config.token) {
      this.#token = config.token
    }

    if (config.header) {
      this.#header = config.header
    }

    this.#axios = axios.create({
      baseURL: config.baseURL.origin,
      headers: {
        'Content-Type': 'application/json',
      },
      paramsSerializer: (p) => qs.stringify(p),
    })
  }

  setToken(token: Token) {
    this.#token = token
  }

  setHeader(header: Header) {
    this.#header = header
  }

  token(custom?: Token) {
    const target = custom || this.#token

    if (typeof target === 'string') {
      return target
    } else if (typeof target === 'function') {
      return target()
    } else {
      return null
    }
  }

  header(custom?: Header) {
    const target = custom || this.#header

    if (typeof target === 'object') {
      return target
    } else if (typeof target === 'function') {
      return target()
    } else {
      return null
    }
  }

  async #call<
    EK extends keyof Endpoints,
    EP extends Endpoints[EK],
    IN extends EP['io']['input'],
    OUT extends EP['io']['output'],
  >(
    endpointKey: EK,
    input: IN,
    options?: {
      token?: Token
      headers?: Header
    }
  ): Promise<OUT> {
    try {
      const endpoint = this.#endpoints[endpointKey]

      const [token, header] = await Promise.all([
        this.token(options?.token),
        this.header(options?.headers),
      ])

      let config: AxiosRequestConfig = {
        method: endpoint.method,
        url: endpoint.url(),
        headers: {
          ...header,
          'Authorization': token ? `Bearer ${token}` : undefined,
          'Content-Type': endpoint.form ? 'multipart/form-data' : 'application/json',
        },
      }

      if (input) {
        const { query, params, ...rest } = input

        config = {
          ...config,
          url: endpoint.url({ params, query }),
          data: rest,
        }
      }

      const res: AxiosResponse<OUT, IN> = await this.#axios.request(config)

      return res.data
    } catch (error) {
      if (error instanceof GateError) {
        throw error
      } else if (isAxiosError(error)) {
        throw GateError.fromAxiosError(error)
      } else {
        throw new GateError('Unknown error in client error handler', {
          cause: error,
        })
      }
    }
  }

  async #safeCall<EK extends keyof Endpoints, EP extends Endpoints[EK]>(
    endpointKey: EK,
    input: EP['io']['input']
  ): Promise<[EP['io']['output'], null] | [null, GateError]> {
    try {
      const res = await this.#call(endpointKey, input)

      return [res, null]
    } catch (err) {
      if (err instanceof GateError) {
        return [null, err]
      } else {
        throw err
      }
    }
  }

  endpoint<EK extends keyof Endpoints>(endpointKey: EK) {
    return {
      call: (input: Endpoints[EK]['io']['input']) => this.#call(endpointKey, input),
      safeCall: (input: Endpoints[EK]['io']['input']) => this.#safeCall(endpointKey, input),
    } as const
  }

  url<EK extends keyof Endpoints, EP extends Endpoints[EK]>(
    endpointKey: EK,
    options?: Parameters<EP['url']>[0]
  ) {
    return new URL(this.#endpoints[endpointKey].url(options), this.#baseURL)
  }
}

```
-------------------------------
[packages/gate/src/error.ts]

```ts
import { AxiosError } from 'axios'
import { z } from 'zod'

const ErrorResponseSchema = z.object({
  id: z.string(),
  title: z.string(),
  code: z.string(),
  status: z.number(),
  multiple: z.array(
    z.object({
      message: z.string(),
      source: z.string().optional(),
      meta: z.record(z.any()).optional(),
    })
  ),
})

export class GateError extends Error {
  #response?: z.infer<typeof ErrorResponseSchema>

  #trace?: string[]

  constructor(
    message: string,
    options?: {
      cause?: unknown
      stack?: string
      response?: z.infer<typeof ErrorResponseSchema>
    }
  ) {
    super(message, { cause: options?.cause })

    this.name = 'GateError'

    Object.setPrototypeOf(this, new.target.prototype)

    this.#response = options?.response

    let stack = options?.stack || this.stack

    if (!stack) {
      Error.captureStackTrace(this, this.constructor)
      stack = this.stack
    }

    if (stack) {
      this.#trace = stack.split('\n').map((line) => line.trim())
    }
  }

  toJSON() {
    return {
      name: this.name,
      message: this.message,
      trace: this.#trace,
      cause: this.cause,
      response: this.#response,
    }
  }

  static fromAxiosError(error: AxiosError): GateError {
    const data = ErrorResponseSchema.safeParse(error.response?.data)

    const response = data.success ? data.data : undefined

    return new GateError(error.message, { cause: error, stack: error.stack, response })
  }
}

```
-------------------------------
[packages/gate/src/types.ts]

```ts
export type MaybePromise<T> = T | Promise<T>

export type Token = string | (() => MaybePromise<string | null>)

export type Header = Record<string, string> | (() => MaybePromise<Record<string, string> | null>)

```
-------------------------------
[packages/gate/tests/example.spec.ts]

```ts
import { test } from '@japa/runner'

test.group('Example', () => {
  test('add two numbers', ({ assert }) => {
    assert.equal(1 + 1, 2)
  })
})

```
-------------------------------
[packages/gate_next/bin/playground.ts]

```ts
console.log('Welcome to playground!')

```
-------------------------------
[packages/gate_next/bin/test.ts]

```ts
import { assert } from '@japa/assert'
import { configure, processCLIArgs, run } from '@japa/runner'

processCLIArgs(process.argv.splice(2))

configure({
  files: ['tests/**/*.spec.ts'],
  plugins: [assert()],
})

run()

```
-------------------------------
[packages/gate_next/index.ts]

```ts
/*
|--------------------------------------------------------------------------
| Package entrypoint
|--------------------------------------------------------------------------
|
| Export values from the package entrypoint as you see fit.
|
*/

export { GateNextServer } from './src/server.js'
export { GateNextClient } from './src/client.js'
export { NextServerError } from './src/next_server_error.js'

```
-------------------------------
[packages/gate_next/package.json]

```json
{
  "name": "@folie/gate-next",
  "description": "",
  "version": "0.0.0",
  "engines": {
    "node": ">=20.6.0"
  },
  "type": "module",
  "files": [
    "build",
    "!build/bin",
    "!build/tests"
  ],
  "exports": {
    ".": "./build/index.js"
  },
  "scripts": {
    "clean": "del-cli build",
    "typecheck": "tsc --noEmit",
    "lint": "eslint .",
    "format": "prettier --write \"**/*.{ts,tsx,md}\"",
    "test": "c8 nr quick:test",
    "prebuild": "nr clean",
    "build": "tsc",
    "quick:test": "tsx bin/test.ts",
    "playground": "tsx bin/playground.ts"
  },
  "devDependencies": {
    "@adonisjs/eslint-config": "^2.0.0-beta.7",
    "@adonisjs/prettier-config": "^1.3.0",
    "@adonisjs/tsconfig": "^1.3.0",
    "@japa/assert": "^3.0.0",
    "@japa/runner": "^3.1.4",
    "@types/node": "^20.14.5",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "c8": "^10.1.2",
    "del-cli": "^5.1.0",
    "eslint": "^9",
    "eslint-plugin-import": "^2.31.0",
    "eslint-plugin-require-extensions": "^0.1.3",
    "prettier": "^3.3.2",
    "typescript": "^5.6"
  },
  "peerDependencies": {
    "@folie/gate": "workspace:*",
    "next": "15"
  },
  "author": "MohitXSkull, Folie",
  "license": "Apache-2.0",
  "prettier": "@adonisjs/prettier-config",
  "publishConfig": {
    "access": "public"
  },
  "c8": {
    "exclude": [
      "tests/**"
    ]
  },
  "dependencies": {
    "@folie/blueprint-lib": "workspace:*",
    "cookies-next": "^5.1.0"
  }
}

```
-------------------------------
[packages/gate_next/src/client.ts]

```ts
import {
  getCookie as getCook,
  setCookie as setCook,
  deleteCookie as removeCook,
} from 'cookies-next'
import { useRouter } from 'next/router.js'

export class GateNextClient<CookieKeys extends Record<string, string>, ParamKeys extends string[]> {
  cookieKeys: CookieKeys
  paramKeys: ParamKeys

  constructor(params: { cookieKeys: CookieKeys; paramKeys: ParamKeys }) {
    this.cookieKeys = params.cookieKeys
    this.paramKeys = params.paramKeys
  }

  useParams = () => {
    const router = useRouter()

    return {
      isReady: router.isReady,
      param: <K extends ParamKeys[number]>(key: K): string => {
        if (!router.isReady) {
          return ''
        }

        const value = router.query[key]

        if (typeof value !== 'string') {
          return ''
        }

        return value
      },
    }
  }

  getCookie = (key: keyof CookieKeys) => {
    const cook = getCook(this.cookieKeys[key])

    if (typeof cook !== 'string') {
      return null
    }

    return cook
  }

  removeCookie = (key: keyof CookieKeys) => removeCook(this.cookieKeys[key])

  setCookie = (key: keyof CookieKeys, value: string) => {
    setCook(this.cookieKeys[key], value)
  }
}

```
-------------------------------
[packages/gate_next/src/next_server_error.ts]

```ts
import { GateError } from '@folie/gate'
import { GetServerSidePropsResult, Redirect } from 'next'
import { NextServerErrorResponse } from './types.js'

export class NextServerError extends Error {
  override name = 'Next Server Error'

  #response: NextServerErrorResponse
  #trace?: string[]

  constructor(response: NextServerErrorResponse, cause?: unknown) {
    super('Next Server Error') // Call super constructor with a default message and cause

    this.#response = response // Store the provided error response

    let stack = this.stack // Get the initial stack trace

    // If stack trace is not available (in some environments), capture it explicitly
    if (!stack) {
      Error.captureStackTrace(this, this.constructor)
      stack = this.stack // Re-assign stack after capturing it
    }

    // If stack trace is available, parse and store it
    if (stack) {
      this.#trace = stack.split('\n').map((line) => line.trim())
    }

    if (cause) {
      if (cause instanceof GateError) {
        this.cause = cause.toJSON()
      } else {
        this.cause = cause
      }
    }
  }

  handle<T>(): GetServerSidePropsResult<T> {
    switch (this.#response.type) {
      case '404':
        return { notFound: true }
      case 'redirect':
        return {
          redirect: this.#response.redirect,
        }
      default:
        throw new Error(`Unknown Error Type`, {
          cause: {
            response: this.#response,
          },
        })
    }
  }

  report(): void {
    console.error(this.toJSON())
  }

  static notFound(cause?: Error): NextServerError {
    return new NextServerError({ type: '404' }, cause)
  }

  static redirect(redirect: Redirect, cause?: Error): NextServerError {
    return new NextServerError({ type: 'redirect', redirect }, cause)
  }

  static fromError(error: unknown): NextServerError {
    if (error instanceof NextServerError) {
      return error
    } else {
      return new NextServerError({ type: '404' }, error)
    }
  }

  toJSON(): { response: NextServerErrorResponse; trace?: string[]; cause: unknown } {
    return {
      response: this.#response,
      trace: this.#trace,
      cause: this.cause,
    }
  }
}

```
-------------------------------
[packages/gate_next/src/server.ts]

```ts
// eslint-disable-next-line import/extensions
import { deleteCookie } from 'cookies-next/server'
import { Gate } from '@folie/gate'
import { GetServerSideProps, GetServerSidePropsContext, GetServerSidePropsResult } from 'next'
import { ApiEndpoints, EndpointKeys } from '@folie/blueprint-lib'
import { CheckpointParams } from './types.js'
import { NextServerError } from './next_server_error.js'

export class GateNextServer<
  const Endpoints extends ApiEndpoints,
  SessionEndpointKey extends EndpointKeys<Endpoints>,
> {
  api: Gate<Endpoints>
  endpoints: Endpoints

  sessionConfig: {
    cookie: string
    endpoint: SessionEndpointKey
  }

  checkpointConfig: {
    redirect: string
  }

  constructor(params: {
    gate: Gate<Endpoints>
    endpoints: Endpoints
    session: {
      /** Cookie name used for session */
      cookie: string
      endpoint: SessionEndpointKey
    }
    checkpoint: {
      redirect: string
    }
  }) {
    this.api = params.gate
    this.endpoints = params.endpoints

    this.sessionConfig = params.session
    this.checkpointConfig = params.checkpoint
  }

  #session = async (
    ctx: GetServerSidePropsContext
  ): Promise<Endpoints[SessionEndpointKey]['io']['output'] | null> => {
    const sessionCookie = ctx.req.cookies[this.sessionConfig.cookie]

    if (!sessionCookie) {
      return null
    }

    this.api.setToken(sessionCookie)

    const [res] = await this.api.endpoint(this.sessionConfig.endpoint).safeCall(undefined)

    return res
  }

  checkpoint = (params?: {
    condition?: (params: {
      ctx: GetServerSidePropsContext
      session: Endpoints[SessionEndpointKey]['io']['output'] | null
    }) => CheckpointParams
  }): GetServerSideProps<{
    session: Endpoints[SessionEndpointKey]['io']['output'] | null
  }> => {
    return async (ctx: GetServerSidePropsContext) => {
      const session = await this.#session(ctx)

      if (!session) {
        deleteCookie(this.sessionConfig.cookie, ctx)
      }

      const condition = params?.condition
        ? params.condition({ ctx, session })
        : { allow: session !== null, redirect: this.checkpointConfig.redirect }

      if (condition.allow === false) {
        return {
          redirect: {
            destination: condition.redirect,
            permanent: false,
          },
        }
      }

      return {
        props: {
          session,
        },
      }
    }
  }

  server = <T extends { [key: string]: any }>(
    callback: (params: {
      session: Endpoints[SessionEndpointKey]['io']['output'] | null
      ctx: GetServerSidePropsContext
      api: Gate<Endpoints>
    }) => Promise<GetServerSidePropsResult<T>>,
    options?: {
      checkpoint?:
        | ((params: {
            ctx: GetServerSidePropsContext
            session: Endpoints[SessionEndpointKey]['io']['output'] | null
          }) => CheckpointParams)
        | true
    }
  ): GetServerSideProps<T> => {
    return async (ctx: GetServerSidePropsContext): Promise<GetServerSidePropsResult<T>> => {
      try {
        const session = await this.#session(ctx)

        if (!session) {
          deleteCookie(this.sessionConfig.cookie, ctx)
        }

        if (options?.checkpoint) {
          if (typeof options?.checkpoint === 'function') {
            const condition = options?.checkpoint({ ctx, session })

            if (condition.allow === false) {
              return {
                redirect: {
                  destination: condition.redirect,
                  permanent: false,
                },
              }
            }
          } else {
            if (session === null) {
              return {
                redirect: {
                  destination: this.checkpointConfig.redirect,
                  permanent: false,
                },
              }
            }
          }
        }

        const res = await callback({ session, ctx, api: this.api })

        return res
      } catch (error) {
        const e = NextServerError.fromError(error)

        e.report()

        return e.handle<T>()
      }
    }
  }
}

```
-------------------------------
[packages/gate_next/src/types.ts]

```ts
import { Redirect } from 'next'

export type NextServerErrorResponse = { type: '404' } | { type: 'redirect'; redirect: Redirect }

export type CheckpointParams =
  | {
      allow: true
    }
  | {
      allow: false
      redirect: string
    }

```
-------------------------------
[packages/gate_next/tests/example.spec.ts]

```ts
import { test } from '@japa/runner'

test.group('Example', () => {
  test('add two numbers', ({ assert }) => {
    assert.equal(1 + 1, 2)
  })
})

```
-------------------------------
[packages/gate_tan/bin/playground.ts]

```ts
console.log('Welcome to playground!')

```
-------------------------------
[packages/gate_tan/bin/test.ts]

```ts
import { assert } from '@japa/assert'
import { configure, processCLIArgs, run } from '@japa/runner'

processCLIArgs(process.argv.splice(2))

configure({
  files: ['tests/**/*.spec.ts'],
  plugins: [assert()],
})

run()

```
-------------------------------
[packages/gate_tan/index.ts]

```ts
/*
|--------------------------------------------------------------------------
| Package entrypoint
|--------------------------------------------------------------------------
|
| Export values from the package entrypoint as you see fit.
|
*/
export { GateTan } from './src/tan.js'

```
-------------------------------
[packages/gate_tan/package.json]

```json
{
  "name": "@folie/gate-tan",
  "description": "",
  "version": "0.0.0",
  "engines": {
    "node": ">=20.6.0"
  },
  "type": "module",
  "files": [
    "build",
    "!build/bin",
    "!build/tests"
  ],
  "exports": {
    ".": "./build/index.js",
    "./components": "./build/src/components/index.js",
    "./types": "./build/src/types.js"
  },
  "scripts": {
    "clean": "del-cli build",
    "typecheck": "tsc --noEmit",
    "lint": "eslint .",
    "format": "prettier --write \"**/*.{ts,tsx,md}\"",
    "test": "c8 nr quick:test",
    "prebuild": "nr clean",
    "build": "tsc",
    "quick:test": "tsx bin/test.ts",
    "playground": "tsx bin/playground.ts"
  },
  "devDependencies": {
    "@adonisjs/eslint-config": "^2.0.0-beta.7",
    "@adonisjs/prettier-config": "^1.3.0",
    "@adonisjs/tsconfig": "^1.3.0",
    "@japa/assert": "^3.0.0",
    "@japa/runner": "^3.1.4",
    "@types/node": "^20.14.5",
    "@types/qs": "^6.9.17",
    "c8": "^10.1.2",
    "del-cli": "^5.1.0",
    "eslint": "^9",
    "eslint-plugin-import": "^2.31.0",
    "eslint-plugin-require-extensions": "^0.1.3",
    "prettier": "^3.3.2",
    "typescript": "^5.6"
  },
  "author": "MohitXSkull, Folie",
  "license": "Apache-2.0",
  "prettier": "@adonisjs/prettier-config",
  "publishConfig": {
    "access": "public"
  },
  "c8": {
    "exclude": [
      "tests/**"
    ]
  },
  "peerDependencies": {
    "@folie/gate": "workspace:*",
    "@tanstack/react-query": "^5.52.2",
    "@mantine/form": "^7.16.1"
  },
  "dependencies": {
    "@folie/blueprint-lib": "workspace:*"
  }
}

```
-------------------------------
[packages/gate_tan/src/components/form.tsx]

```tsx
import { Stack, StackProps } from '@mantine/core'
import { UseFormReturnType } from '@mantine/form'
import { UseMutationResult } from '@tanstack/react-query'
import React from 'react'

const Form = <
  MUTATION extends Omit<UseMutationResult<any, any, any, any>, 'mutate' | 'mutateAsync'>,
  INPUT extends Exclude<MUTATION['variables'], undefined>,
  FORM extends UseFormReturnType<INPUT>,
>(props: {
  mutation: MUTATION
  form: FORM

  children: (params: { loading: boolean; dirty: boolean }) => React.ReactNode
  submit: (input: INPUT) => void

  props?: {
    stack?: StackProps
  }

  ref?: React.Ref<HTMLFormElement>
}) => {
  return (
    <>
      <form
        ref={props.ref}
        onSubmit={props.form.onSubmit((values) => {
          props.submit(values)
        })}
      >
        <Stack {...props.props?.stack}>
          {props.children({
            loading: props.mutation.isPending,
            dirty: props.form.isDirty(),
          })}
        </Stack>
      </form>
    </>
  )
}

export { Form }

```
-------------------------------
[packages/gate_tan/src/components/index.ts]

```ts
export { Form } from './form.js'

```
-------------------------------
[packages/gate_tan/src/error_handler.ts]

```ts
import { UseFormReturnType } from '@mantine/form'
import { GateError } from '@folie/gate'
import { capitalCase } from 'case-anything'
import { getProperty } from 'dot-prop'

export const ErrorHandler = (params: {
  error: unknown
  form?: UseFormReturnType<any>
  notification: (params: { title: string; message: string }) => void
}) => {
  if (params.error instanceof GateError) {
    const errorJSON = params.error.toJSON()

    if (errorJSON.response) {
      const formValues = params.form ? params.form.getValues() : {}

      for (const multi of errorJSON.response.multiple) {
        if (params.form && multi.source && getProperty(formValues, multi.source) !== undefined) {
          params.form.setFieldError(multi.source, multi.message)
        } else {
          params.notification({
            title: capitalCase(errorJSON.response.title),
            message: multi.message,
          })
        }
      }
    } else {
      console.error(params.error.toJSON())

      params.notification({
        title: 'Client Error',
        message: params.error.message,
      })
    }
  } else {
    console.error(params.error)

    params.notification({
      title: 'Unrecognized Error',
      message: 'An unrecognized error has occurred. Please try again.',
    })
  }
}

```
-------------------------------
[packages/gate_tan/src/tan.ts]

```ts
import { ApiEndpoints } from '@folie/blueprint-lib'
import { Gate } from '@folie/gate'
import {
  UndefinedInitialDataOptions,
  useQuery,
  useMutation,
  useQueryClient,
  UseMutationResult,
} from '@tanstack/react-query'
import { useForm, UseFormInput } from '@mantine/form'
import { useDebouncedValue } from '@mantine/hooks'
import {
  CobaltUseMutationParams,
  GetInputPropOptions,
  GetInputPropsReturnType,
  NotificationFunction,
  OnValuesChangeParams,
} from './types.js'
import { ErrorHandler } from './error_handler.js'
import { useCallback, useRef, useState } from 'react'

export class GateTan<const Endpoints extends ApiEndpoints> {
  gate: Gate<Endpoints>
  endpoints: Endpoints

  notification: NotificationFunction

  constructor(params: {
    gate: Gate<Endpoints>
    endpoints: Endpoints
    notification: NotificationFunction
  }) {
    this.gate = params.gate
    this.endpoints = params.endpoints
    this.notification = params.notification
  }

  queryKey = <EK extends keyof Endpoints, EP extends Endpoints[EK]>(
    endpointKey: EK,
    options?: Parameters<EP['url']>[0]
  ) => {
    const endpoint = this.endpoints[endpointKey]

    return [endpoint.method, endpoint.url(options)]
  }

  useQuery = <EK extends keyof Endpoints, EP extends Endpoints[EK]['io']>(
    params: {
      endpoint: EK
      input?: EP['input']
    } & Omit<UndefinedInitialDataOptions<EP['input'], Error, EP['output']>, 'queryFn' | 'queryKey'>
  ) => {
    const { endpoint, input, ...rest } = params

    const internalQuery = useQuery({
      // Temporary
      ...rest,

      // Permanent
      queryKey: this.queryKey(endpoint, {
        params: input?.params,
        query: input?.query,
      }),
      queryFn: () => this.gate.endpoint(endpoint).call(input),
    })

    return internalQuery
  }

  useMutation = <EK extends keyof Endpoints, EP extends Endpoints[EK]['io']>(
    params: CobaltUseMutationParams<Endpoints, EK, EP>
  ) => {
    const { endpoint, form, onSuccess, onError, ...rest } = params

    const queryClient = useQueryClient()

    const internalMutation = useMutation({
      // Temporary
      ...rest,

      // Permanent
      mutationFn: this.gate.endpoint(params.endpoint).call,

      onSuccess: (output, input) => {
        const res = params.onSuccess(output, input)

        if (res?.queryKeys) {
          const queryKeys = res.queryKeys(this.queryKey)

          for (const queryKey of queryKeys) {
            queryClient.invalidateQueries({
              queryKey,
              exact: true,
              type: 'active',
            })
          }
        }

        if (params.form && res?.input) {
          params.form.setValues(res.input)
          params.form.resetDirty()
        }

        if (res?.after) {
          res.after()
        }
      },
      onError: (error, variables) => {
        if (onError) {
          onError({ error, input: variables, form: params.form, notification: this.notification })
        } else {
          ErrorHandler({ error, form: params.form, notification: this.notification })
        }

        if (params.onErrorHook?.after) {
          params.onErrorHook.after()
        }
      },
    })

    return internalMutation
  }

  useList = <EK extends keyof Endpoints, EP extends Endpoints[EK]['io']>(
    params: {
      endpoint: EK
      input?: EP['input']
      debounce?: {
        timeout?: number
        leading?: boolean
      }
    } & Omit<UndefinedInitialDataOptions<EP['input'], Error, EP['output']>, 'queryFn' | 'queryKey'>
  ) => {
    const { endpoint, input, debounce, ...rest } = params

    const [internalBody, setInternalBody] = useState<NonNullable<EP['input']>>(input ?? {})

    const [debouncedBody] = useDebouncedValue(internalBody, debounce?.timeout || 1000, {
      leading: debounce?.leading || false,
    })

    const internalQueryCall = this.useQuery({
      ...rest,

      endpoint: params.endpoint,
      input: debouncedBody,
    })

    return {
      query: internalQueryCall,
      debouncedBody: debouncedBody,
      body: internalBody,
      setBody: setInternalBody,
    }
  }

  useForm = <EK extends keyof Endpoints, EP extends Endpoints[EK]['io']>(
    params: Omit<UseFormInput<NonNullable<EP['input']>>, 'onValuesChange'> & {
      endpoint: EK

      onSuccess: CobaltUseMutationParams<Endpoints, EK, EP>['onSuccess']

      mutation?: Omit<CobaltUseMutationParams<Endpoints, EK, EP>, 'form' | 'onSuccess' | 'endpoint'>

      onValuesChange?: (params: OnValuesChangeParams<EP>) => void
    }
  ) => {
    const { endpoint, onSuccess, mutation, onValuesChange, ...rest } = params

    const mutationRef = useRef<UseMutationResult<
      EP['output'],
      unknown,
      EP['input'],
      unknown
    > | null>(null)

    const internalForm = useForm<NonNullable<EP['input']>>({
      mode: 'uncontrolled',
      onValuesChange: onValuesChange
        ? (values, previousValues) => {
            if (mutationRef.current) {
              onValuesChange({
                values,
                previousValues,
                mutation: mutationRef.current,
              })
            }
          }
        : undefined,
      ...rest,
    })

    const internalMutation = this.useMutation({
      ...mutation,

      endpoint: params.endpoint,
      onSuccess: params.onSuccess,
      form: internalForm,
    })

    mutationRef.current = internalMutation

    const getExtendedInputProps = useCallback(
      (
        key: string,
        options?: GetInputPropOptions<EP['input']>
      ): GetInputPropsReturnType<EP['input']> => {
        const base = {
          ...internalForm.getInputProps(key, {
            type: options?.type,
            withError: options?.withError,
            withFocus: options?.withFocus,
          }),
          disabled: options?.disabled
            ? options.disabled(internalMutation.isPending)
            : internalMutation.isPending,
        }

        return base
      },
      [internalForm, internalMutation.isPending]
    )

    return {
      form: internalForm,
      mutation: internalMutation,
      inputProps: getExtendedInputProps,
    } as const
  }
}

```
-------------------------------
[packages/gate_tan/src/types.ts]

```ts
import { UseFormReturnType } from '@mantine/form'
import { QueryKey, UseMutationOptions, UseMutationResult } from '@tanstack/react-query'
import { ApiEndpoints, EndpointKeys, EndpointIO } from '@folie/blueprint-lib'
import { GateTan } from './tan.js'

export type NotificationFunction = (params: { title: string; message: string }) => void

export type CobaltUseMutationParams<
  Endpoints extends ApiEndpoints,
  EK extends EndpointKeys<Endpoints>,
  EP extends Endpoints[EK]['io'],
> = Omit<
  UseMutationOptions<EP['output'], unknown, EP['input'], unknown>,
  'mutationFn' | 'onSuccess' | 'onError'
> & {
  endpoint: EK

  onSuccess: (
    output: EP['output'],
    input: EP['input']
  ) => {
    input?: EP['input']
    queryKeys?: (qk: GateTan<Endpoints>['queryKey']) => QueryKey[]
    after?: () => void
  } | void

  form?: UseFormReturnType<NonNullable<EP['input']>>

  onError?: (params: {
    error: unknown
    input: EP['input']
    form?: UseFormReturnType<NonNullable<EP['input']>>
    notification: GateTan<Endpoints>['notification']
  }) => void

  onErrorHook?: {
    after?: () => void
  }
}

export type FormInputTransformType = 'default'

export type GetInputPropOptions<Values> = NonNullable<
  Parameters<UseFormReturnType<Values>['getInputProps']>[1]
> & {
  // transform?: FormInputTransformType
  disabled?: (disabled: boolean) => boolean
}

export type GetInputPropsReturnType<Values> = ReturnType<
  UseFormReturnType<Values>['getInputProps']
> & {
  disabled: boolean
  [key: string]: any
}

export type SetPartialState<T extends Record<string, unknown>> = (
  statePartial: Partial<T> | ((currentState: T) => Partial<T>)
) => void

export type OnValuesChangeParams<T extends EndpointIO> = {
  values: NonNullable<T['input']>
  previousValues: NonNullable<T['input']>
  mutation: UseMutationResult<T['output'], unknown, T['input'], unknown>
}

```
-------------------------------
[packages/gate_tan/tests/example.spec.ts]

```ts
import { test } from '@japa/runner'

test.group('Example', () => {
  test('add two numbers', ({ assert }) => {
    assert.equal(1 + 1, 2)
  })
})

```
-------------------------------
[packages/lib/bin/playground.ts]

```ts
console.log('Welcome to playground!')

```
-------------------------------
[packages/lib/bin/test.ts]

```ts
import { assert } from '@japa/assert'
import { configure, processCLIArgs, run } from '@japa/runner'

processCLIArgs(process.argv.splice(2))

configure({
  files: ['tests/**/*.spec.ts'],
  plugins: [assert()],
})

run()

```
-------------------------------
[packages/lib/index.ts]

```ts
/*
|--------------------------------------------------------------------------
| Package entrypoint
|--------------------------------------------------------------------------
|
| Export values from the package entrypoint as you see fit.
|
*/

export { DotProp } from './src/dot_prop.js'

export { XEnum } from './src/x_enum.js'
export { interpolate } from './src/interpolate.js'
export { pick } from './src/pick.js'
export { promiseMap } from './src/promise_map.js'
export { sleep } from './src/sleep.js'
export {
  HTTPStatusCodes,
  getHTTPStatusByCode,
  getHTTPStatusByKey,
  type HTTPStatusCodeKeys,
} from './src/http_status_codes.js'

```
-------------------------------
[packages/lib/package.json]

```json
{
  "name": "@folie/lib",
  "description": "",
  "version": "0.0.4",
  "engines": {
    "node": ">=20.6.0"
  },
  "type": "module",
  "files": [
    "build",
    "!build/bin",
    "!build/tests"
  ],
  "exports": {
    ".": "./build/index.js"
  },
  "scripts": {
    "clean": "del-cli build",
    "typecheck": "tsc --noEmit",
    "lint": "eslint .",
    "format": "prettier --write \"**/*.{ts,tsx,md}\"",
    "test": "c8 nr quick:test",
    "prebuild": "nr clean",
    "build": "tsc",
    "quick:test": "tsx bin/test.ts",
    "playground": "tsx bin/playground.ts"
  },
  "devDependencies": {
    "@adonisjs/eslint-config": "^2.0.0-beta.7",
    "@adonisjs/prettier-config": "^1.3.0",
    "@adonisjs/tsconfig": "^1.3.0",
    "@japa/assert": "^3.0.0",
    "@japa/runner": "^3.1.4",
    "@types/node": "^20.14.5",
    "c8": "^10.1.2",
    "del-cli": "^5.1.0",
    "eslint": "^9",
    "prettier": "^3.3.2",
    "typescript": "^5.6"
  },
  "author": "MohitXSkull, Folie",
  "license": "Apache-2.0",
  "prettier": "@adonisjs/prettier-config",
  "publishConfig": {
    "access": "public"
  },
  "c8": {
    "exclude": [
      "tests/**"
    ]
  },
  "dependencies": {
    "dot-prop": "^9.0.0"
  }
}

```
-------------------------------
[packages/lib/src/dot_prop.ts]

```ts
import {
  deleteProperty as deletePropertyOriginal,
  getProperty as getPropertyOriginal,
  setProperty as setPropertyOriginal,
} from 'dot-prop'

export class DotProp {
  static omit = <T extends object>(obj: T, path: string): T => {
    const res = { ...obj }

    deletePropertyOriginal(res, path)

    return res
  }

  static assign = <T extends object, V extends any>(obj: T, path: string, value: V): T => {
    const res = { ...obj }

    setPropertyOriginal(res, path, value)

    return res
  }

  static lookup = <T extends object, V extends unknown>(
    obj: T,
    path: string,
    defaultValue: V
  ): V => {
    return getPropertyOriginal(obj, path, defaultValue) as V
  }

  static rawLookup = getPropertyOriginal

  static assignOrOmit = <T extends object, V extends string | number | boolean>(
    obj: T,
    path: string,
    value: V,
    defaultValue: V
  ): T => {
    let res = { ...obj }

    if (value === defaultValue) {
      res = this.omit(res, path)
    } else {
      res = this.assign(res, path, value)
    }

    const parentPath = path.split('.').slice(0, -1).join('.')

    const parentObj = this.lookup(res, parentPath, {})

    if (Object.keys(parentObj).length < 1) {
      res = this.omit(res, parentPath)
    }

    return res
  }
}

```
-------------------------------
[packages/lib/src/http_status_codes.ts]

```ts
export const HTTPStatusCodes = {
  OK: 200,
  CREATED: 201,
  ACCEPTED: 202,
  NO_CONTENT: 204,
  MOVED_PERMANENTLY: 301,
  FOUND: 302,
  SEE_OTHER: 303,
  NOT_MODIFIED: 304,
  TEMPORARY_REDIRECT: 307,
  PERMANENT_REDIRECT: 308,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  PAYMENT_REQUIRED: 402,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  METHOD_NOT_ALLOWED: 405,
  NOT_ACCEPTABLE: 406,
  PROXY_AUTHENTICATION_REQUIRED: 407,
  REQUEST_TIMEOUT: 408,
  CONFLICT: 409,
  GONE: 410,
  LENGTH_REQUIRED: 411,
  PRECONDITION_FAILED: 412,
  PAYLOAD_TOO_LARGE: 413,
  URI_TOO_LONG: 414,
  UNSUPPORTED_MEDIA_TYPE: 415,
  RANGE_NOT_SATISFIABLE: 416,
  EXPECTATION_FAILED: 417,
  IM_A_TEAPOT: 418,
  MISDIRECTED_REQUEST: 421,
  UNPROCESSABLE_ENTITY: 422,
  LOCKED: 423,
  FAILED_DEPENDENCY: 424,
  TOO_EARLY: 425,
  UPGRADE_REQUIRED: 426,
  PRECONDITION_REQUIRED: 428,
  TOO_MANY_REQUESTS: 429,
  REQUEST_HEADER_FIELDS_TOO_LARGE: 431,
  UNAVAILABLE_FOR_LEGAL_REASONS: 451,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501,
  BAD_GATEWAY: 502,
  SERVICE_UNAVAILABLE: 503,
  GATEWAY_TIMEOUT: 504,
  HTTP_VERSION_NOT_SUPPORTED: 505,
  VARIANT_ALSO_NEGOTIATES: 506,
  INSUFFICIENT_STORAGE: 507,
  LOOP_DETECTED: 508,
  NOT_EXTENDED: 510,
  NETWORK_AUTHENTICATION_REQUIRED: 511,
} as const

export type HTTPStatusCodeKeys = keyof typeof HTTPStatusCodes

export const getHTTPStatusByKey = (key: HTTPStatusCodeKeys) => ({
  status: HTTPStatusCodes[key],
  code: key,
})

export const getHTTPStatusByCode = (code: number) => {
  const key = Object.keys(HTTPStatusCodes).find(
    (k: string) => HTTPStatusCodes[k as HTTPStatusCodeKeys] === code
  )

  if (!key) throw new Error(`Invalid status code: ${code}`)

  return getHTTPStatusByKey(key as HTTPStatusCodeKeys)
}

```
-------------------------------
[packages/lib/src/interpolate.ts]

```ts
/**
 * Parses a nested property from an object.
 */
const getNestedProperty = (data: unknown, key: string): unknown => {
  if (data === null || typeof data !== 'object') {
    return undefined
  }

  try {
    // Attempt direct access if no dots
    if (!key.includes('.')) {
      return (data as Record<string, unknown>)[key]
    }

    return key.split('.').reduce((acc: any, part) => {
      if (acc === null || typeof acc !== 'object' || !Object.hasOwn(acc, part)) {
        return undefined
      }
      return acc[part]
    }, data)
  } catch (error) {
    // Catch potential type errors during property access.
    return undefined
  }
}

/**
 * Interpolates values inside double curly braces.
 * Supports escaping with backslashes.
 *
 * Example:
 * interpolate('hello {{ username }}', { username: 'skull' }) // 'hello skull'
 * interpolate('hello \\{{ username }}', { username: 'skull' }) // 'hello {{ username }}'
 * interpolate('{{ user.profile.name }}', { user: { profile: { name: 'Skull' } } }) // 'Skull'
 * interpolate('{{ user.profile.age }}', { user: { profile: { name: 'Skull' } } }) // undefined
 */
export const interpolate = (input: string, data: unknown): string => {
  if (typeof input !== 'string') {
    return '' // Or throw an error, depending on your needs.
  }
  return input.replace(/(\\)?{{(.*?)}}/g, (_, escapeChar, key) => {
    if (escapeChar) {
      return `{{${key}}}`
    }

    const value = getNestedProperty(data, key.trim())

    return value !== undefined && value !== null ? String(value) : ''
  })
}

```
-------------------------------
[packages/lib/src/pick.ts]

```ts
export const pick = <T, K extends keyof T>(object: T, keys: K[]): Pick<T, K> => {
  return Object.assign(
    {},
    ...keys.map((key) => {
      if (object && Object.prototype.hasOwnProperty.call(object, key)) {
        return { [key]: object[key] }
      }
    })
  )
}

```
-------------------------------
[packages/lib/src/promise_map.ts]

```ts
export const promiseMap = <T, U>(array: T[], callback: (item: T) => Promise<U>) => {
  return Promise.all(array.map(callback))
}

```
-------------------------------
[packages/lib/src/sleep.ts]

```ts
/**
 * Asynchronous sleep function using Promises.
 *
 * @param ms The number of milliseconds to sleep.
 * @returns A Promise that resolves after the specified time.
 */
export const sleep = (ms: number): Promise<void> => {
  return new Promise((resolve) => setTimeout(resolve, ms))
}

```
-------------------------------
[packages/lib/src/x_enum.ts]

```ts
/**
 * Represents an enhanced enum with additional utility methods.
 * Provides access to keys, values, reverse lookup, and iteration.
 * @template T A type representing the enum object, where keys are strings and values are strings or numbers.
 */
export class XEnum<T extends Record<string, string | number>> {
  /**
   * An array of the enum keys.
   * @readonly
   */
  public readonly keys: (keyof T)[]

  /**
   * An array of the enum values.
   * @readonly
   */
  public readonly values: T[keyof T][]

  /**
   * The original enum object.
   * @readonly
   */
  public readonly enum: Readonly<T>

  private readonly reverseMap: Map<T[keyof T], keyof T>

  /**
   * Creates a new XEnum instance.
   * @param enumObj The enum object to enhance.
   * @example
   * ```typescript
   * const Color = new XEnum({ RED: 'red', GREEN: 'green', BLUE: 'blue' });
   * ```
   */
  constructor(enumObj: T) {
    this.enum = Object.freeze({ ...enumObj })
    this.keys = Object.keys(enumObj) as (keyof T)[]
    this.values = Object.values(enumObj) as T[keyof T][]
    this.reverseMap = new Map()

    this.values.forEach((value, index) => {
      this.reverseMap.set(value, this.keys[index])
    })
  }

  /**
   * Gets the value associated with a given key.
   * @param key The enum key.
   * @returns The corresponding enum value.
   * @example
   * ```typescript
   * const value = Color.keyof('RED'); // 'red'
   * ```
   */
  keyof(key: keyof T): T[keyof T] {
    return this.enum[key]
  }

  key(key: keyof T) {
    return key
  }

  /**
   * Gets the key associated with a given value.
   * @param value The enum value.
   * @returns The corresponding enum key, or undefined if the value is not found.
   * @example
   * ```typescript
   * const key = Color.valueof('green'); // 'GREEN'
   * const unknownKey = Color.valueof('purple'); // undefined
   * ```
   */
  valueof(value: T[keyof T]): keyof T | undefined {
    return this.reverseMap.get(value)
  }

  /**
   * Checks if the enum has a given key (or one of the utility properties).
   * @param key The key to check.
   * @returns True if the enum has the key, false otherwise.
   * @example
   * ```typescript
   * console.log("RED" in Color); // true
   * console.log("random" in Color); // false
   * console.log("keys" in Color); // true
   * ```
   */
  has(key: string | symbol): boolean {
    return (
      key in this.enum || key === 'keys' || key === 'values' || key === 'keyof' || key === 'valueof'
    )
  }

  /**
   * Gets the value associated with a given key. Alias for keyof().
   * @param key The enum key.
   * @returns The corresponding enum value.
   * @example
   * ```typescript
   * const value = Color.get('RED'); // 'red'
   * ```
   */
  get(key: keyof T): T[keyof T] {
    return this.enum[key]
  }

  /**
   * Iterates over the enum entries.
   * @returns An iterator that yields [key, value] pairs.
   * @example
   * ```typescript
   * for (const [key, value] of Color) {
   *   console.log(`${key}: ${value}`);
   * }
   * // RED: red
   * // GREEN: green
   * // BLUE: blue
   * ```
   */
  *[Symbol.iterator](): IterableIterator<[keyof T, T[keyof T]]> {
    for (const key of this.keys) {
      yield [key, this.enum[key]]
    }
  }
}

```
-------------------------------
[packages/lib/tests/example.spec.ts]

```ts
import { test } from '@japa/runner'

test.group('Example', () => {
  test('add two numbers', ({ assert }) => {
    assert.equal(1 + 1, 2)
  })
})

```
-------------------------------
[packages/squid/bin/playground.ts]

```ts
console.log('Welcome to playground!')

```
-------------------------------
[packages/squid/bin/test.ts]

```ts
import { assert } from '@japa/assert'
import { configure, processCLIArgs, run } from '@japa/runner'

processCLIArgs(process.argv.splice(2))

configure({
  files: ['tests/**/*.spec.ts'],
  plugins: [assert()],
})

run()

```
-------------------------------
[packages/squid/index.ts]

```ts
/*
|--------------------------------------------------------------------------
| Package entrypoint
|--------------------------------------------------------------------------
|
| Export values from the package entrypoint as you see fit.
|
*/

export * from './src/index.js'
export * from './src/module.js'

```
-------------------------------
[packages/squid/package.json]

```json
{
  "name": "@folie/squid",
  "description": "",
  "version": "0.0.4",
  "engines": {
    "node": ">=20.6.0"
  },
  "type": "module",
  "files": [
    "build",
    "!build/bin",
    "!build/tests"
  ],
  "exports": {
    ".": "./build/index.js"
  },
  "scripts": {
    "clean": "del-cli build",
    "typecheck": "tsc --noEmit",
    "lint": "eslint .",
    "format": "prettier --write \"**/*.{ts,tsx,md}\"",
    "test": "c8 nr quick:test",
    "prebuild": "nr clean",
    "build": "tsc",
    "quick:test": "tsx bin/test.ts",
    "playground": "tsx bin/playground.ts"
  },
  "devDependencies": {
    "@adonisjs/eslint-config": "^2.0.0-beta.7",
    "@adonisjs/prettier-config": "^1.3.0",
    "@adonisjs/tsconfig": "^1.3.0",
    "@japa/assert": "^3.0.0",
    "@japa/runner": "^3.1.4",
    "@types/node": "^20.14.5",
    "c8": "^10.1.2",
    "del-cli": "^5.1.0",
    "eslint": "^9",
    "prettier": "^3.3.2",
    "typescript": "^5.6"
  },
  "peerDependencies": {
    "@adonisjs/core": "^6.15.2",
    "@vinejs/vine": "^3.0.0"
  },
  "author": "MohitXSkull, Folie",
  "license": "Apache-2.0",
  "prettier": "@adonisjs/prettier-config",
  "publishConfig": {
    "access": "public"
  },
  "c8": {
    "exclude": [
      "tests/**"
    ]
  },
  "dependencies": {
    "rand-seed": "^2.1.7",
    "sqids": "^0.3.0"
  }
}

```
-------------------------------
[packages/squid/src/index.ts]

```ts
import Sqids from 'sqids'
import { shuffleString } from './shuffle_string.js'
import vine from '@vinejs/vine'
import { createHash } from 'node:crypto'
import { Secret } from '@adonisjs/core/helpers'
import { SquidParams } from './types.js'

const defaultDictionary = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'

export class Squid {
  private minLength: number
  private client: Sqids

  finalMinLength: number
  prefixConnector: string
  prefixBase: string
  dictionary: string

  get prefix() {
    return `${this.prefixBase}${this.prefixConnector}`
  }

  /**
   * Initializes a new instance of the Squid class.
   *
   * @param secret - A secret key used for initializing and seeding the hashing process.
   * @param params - Configuration parameters for the Squid instance.
   * @param params.prefix - The base prefix for generated IDs.
   * @param params.minLength - Optional minimum length for generated IDs, default is 22.
   * @param params.prefixConnector - Optional connector string between prefix parts, default is '_'.
   * @param params.dictionary - Optional custom dictionary for encoding, default is alphanumeric.
   */
  constructor(secret: Secret<string>, params: SquidParams) {
    this.prefixBase = params.prefixBase
    this.prefixConnector = params.prefixConnector ?? '_'

    if (this.prefixBase.includes(this.prefixConnector)) {
      throw new Error('Prefix should not contain the connector character')
    }

    this.minLength = params.minLength ?? 22

    this.dictionary = params.dictionary ?? defaultDictionary

    if (this.dictionary.length < 5) {
      throw new Error('Dictionary must contain at least 5 characters')
    }

    const uniqueChars = new Set(this.dictionary).size

    if (this.dictionary && uniqueChars < 5) {
      throw new Error('Dictionary must have at least 5 unique characters')
    }

    this.finalMinLength = this.prefix.length + this.minLength

    const seed = createHash('sha256')
      .update(this.prefix + secret.release)
      .digest('hex')

    const dictionary = shuffleString(this.dictionary, seed)

    try {
      this.client = new Sqids({ alphabet: dictionary, minLength: this.minLength })
    } catch (error) {
      throw new Error(`Failed to initialize Sqids: ${error.message}`)
    }
  }

  /**
   * Encodes a given numerical ID into a UUID string.
   *
   * @param id - Numerical ID to be encoded.
   * @returns Encoded UUID string.
   */
  encode(id: number): string {
    return `${this.prefix}${this.client.encode([id])}`
  }

  /**
   * Decodes a given UUID string into its original numerical ID.
   *
   * @param uuid - UUID string to be decoded.
   * @returns Original numerical ID.
   *
   * @throws {Error} If the UUID length is less than configured minLength.
   * @throws {Error} If the UUID does not start with the configured prefix.
   * @throws {Error} If the UUID is invalid or cannot be decoded.
   */
  decode(uuid: string): number {
    if (typeof uuid !== 'string') {
      throw new Error('Invalid UUID', {
        cause: {
          uuid,
          minLength: this.finalMinLength,
          prefix: this.prefix,
        },
      })
    }

    if (uuid.length < this.finalMinLength) {
      throw new Error('Invalid UUID Length', {
        cause: {
          uuid,
          minLength: this.finalMinLength,
          length: uuid.length,
        },
      })
    }

    if (!uuid.startsWith(this.prefix)) {
      throw new Error('Invalid UUID Prefix', {
        cause: {
          uuid,
          prefix: this.prefix,
        },
      })
    }

    const idPart = uuid.replace(new RegExp(`^${this.prefix}`), '')

    if (!idPart) {
      throw new Error('Invalid UUID (empty ID part)')
    }

    const id = this.client.decode(idPart)[0]

    if (!id) {
      throw new Error('Invalid UUID', {
        cause: {
          uuid,
          minLength: this.finalMinLength,
          length: uuid.length,
          prefix: this.prefix,
          response: {
            id,
          },
        },
      })
    }

    return id
  }

  /**
   * A schema for validating Squid UUIDs.
   */
  get schema() {
    return vine
      .string()
      .minLength(this.finalMinLength)
      .startsWith(this.prefix)
      .transform(this.decode.bind(this))
  }
}

```
-------------------------------
[packages/squid/src/module.ts]

```ts
import { Secret } from '@adonisjs/core/helpers'
import { Squid } from './index.js'
import { SquidParams } from './types.js'

export class SquidModule {
  private secret: Secret<string>

  constructor(secret: string) {
    this.secret = new Secret(secret)
  }

  create(params: SquidParams) {
    return new Squid(this.secret, params)
  }

  /**
   * Creates a group of Squid instances with the provided parameters.
   */
  group<T extends Record<string, SquidParams>>(params: T) {
    return Object.fromEntries(
      Object.entries(params).map(([key, value]) => [key, this.create(value)])
    ) as Record<keyof T, Squid>
  }
}

```
-------------------------------
[packages/squid/src/shuffle_string.ts]

```ts
import { cuid } from '@adonisjs/core/helpers'
import Rand, { PRNG } from 'rand-seed'

export const seedRand = (seed: string): number => {
  const rand = new Rand(seed, PRNG.xoshiro128ss)
  return rand.next()
}

export const seedRandRange = (min: number, max: number, seed: string | number): number => {
  const seededRandom = typeof seed === 'string' ? seedRand(seed) : seed

  return Math.floor(seededRandom * (max - min) + min)
}

const shuffle = (array: string[], seed: string) => {
  const rand = new Rand(seed, PRNG.xoshiro128ss)
  let currentIndex = array.length
  while (currentIndex > 0) {
    const randomIndex = Math.floor(rand.next() * currentIndex)
    currentIndex--
    ;[array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]]
  }
  return array
}

export const shuffleString = (data: string, seed?: string): string => {
  const selectedSeed = seed ?? cuid()

  const dataLength = data.length

  if (dataLength < 10) {
    return data
  }

  const splittedData = [...data.split('')]

  const intSeed = seedRand(selectedSeed)

  const newLength = seedRandRange(Math.ceil(dataLength / 2), dataLength, intSeed)

  return shuffle(splittedData, selectedSeed).slice(0, newLength).join('')
}

```
-------------------------------
[packages/squid/src/types.ts]

```ts
export type SquidParams = {
  prefixBase: string
  minLength?: number
  prefixConnector?: string
  dictionary?: string
}

```
-------------------------------
[packages/squid/tests/example.spec.ts]

```ts
import { test } from '@japa/runner'

test.group('Example', () => {
  test('add two numbers', ({ assert }) => {
    assert.equal(1 + 1, 2)
  })
})

```
-------------------------------
[playground/backend/ace.js]

```js
/*
|--------------------------------------------------------------------------
| JavaScript entrypoint for running ace commands
|--------------------------------------------------------------------------
|
| DO NOT MODIFY THIS FILE AS IT WILL BE OVERRIDDEN DURING THE BUILD
| PROCESS.
|
| See docs.adonisjs.com/guides/typescript-build-process#creating-production-build
|
| Since, we cannot run TypeScript source code using "node" binary, we need
| a JavaScript entrypoint to run ace commands.
|
| This file registers the "ts-node/esm" hook with the Node.js module system
| and then imports the "bin/console.ts" file.
|
*/

process.env.NODE_ENV = process.env.ENV === 'pro' ? 'production' : 'development'

/**
 * Register hook to process TypeScript files using ts-node
 */
import 'ts-node-maintained/register/esm'

/**
 * Import ace console entrypoint
 */
await import('./bin/console.js')

```
-------------------------------
[playground/backend/adonisrc.ts]

```ts
import { defineConfig } from '@adonisjs/core/app'

export default defineConfig({
  /*
  |--------------------------------------------------------------------------
  | Commands
  |--------------------------------------------------------------------------
  |
  | List of ace commands to register from packages. The application commands
  | will be scanned automatically from the "./commands" directory.
  |
  */
  commands: [
    () => import('@adonisjs/core/commands'),
    () => import('@adonisjs/lucid/commands'),
    () => import('@adonisjs/bouncer/commands'),
    () => import('@folie/blueprint/commands'),
    () => import('@adonisjs/cache/commands'),
    () => import('@adonisjs/mail/commands'),
  ],

  /*
  |--------------------------------------------------------------------------
  | Service providers
  |--------------------------------------------------------------------------
  |
  | List of service providers to import and register when booting the
  | application
  |
  */
  providers: [
    () => import('@adonisjs/core/providers/app_provider'),
    () => import('@adonisjs/core/providers/hash_provider'),
    {
      file: () => import('@adonisjs/core/providers/repl_provider'),
      environment: ['repl', 'test'],
    },
    () => import('@adonisjs/core/providers/vinejs_provider'),
    () => import('@adonisjs/cors/cors_provider'),
    () => import('@adonisjs/lucid/database_provider'),
    () => import('#providers/boot_provider'),
    () => import('@folie/castle/provider/migration_provider'),
    () => import('@folie/castle/provider/request_validator_provider'),
    () => import('@adonisjs/bouncer/bouncer_provider'),
    () => import('@adonisjs/limiter/limiter_provider'),
    () => import('@adonisjs/core/providers/edge_provider'),
    () => import('@adonisjs/cache/cache_provider'),
    () => import('@adonisjs/mail/mail_provider'),
  ],

  /*
  |--------------------------------------------------------------------------
  | Preloads
  |--------------------------------------------------------------------------
  |
  | List of modules to import before starting the application.
  |
  */
  preloads: [() => import('#start/routes'), () => import('#start/kernel')],

  /*
  |--------------------------------------------------------------------------
  | Tests
  |--------------------------------------------------------------------------
  |
  | List of test suites to organize tests by their type. Feel free to remove
  | and add additional suites.
  |
  */
  tests: {
    suites: [
      {
        files: ['tests/unit/**/*.spec(.ts|.js)'],
        name: 'unit',
        timeout: 2000,
      },
      {
        files: ['tests/functional/**/*.spec(.ts|.js)'],
        name: 'functional',
        timeout: 30000,
      },
    ],
    forceExit: false,
  },
  metaFiles: [
    {
      pattern: 'resources/views/**/*.edge',
      reloadServer: false,
    },
  ],
})

```
-------------------------------
[playground/backend/app/abilities/main.ts]

```ts
import { Bouncer } from '@adonisjs/bouncer'

export const editPost = Bouncer.ability(() => {
  return true
})

```
-------------------------------
[playground/backend/app/boot.ts]

```ts
import logger from '@adonisjs/core/services/logger'
import User from '#models/user'
import { DateTime } from 'luxon'

export const boot = async () => {
  logger.info('Initializing app...')

  await User.firstOrCreate(
    {
      email: 'mohitxskull@gmail.com',
    },
    {
      email: 'mohitxskull@gmail.com',
      password: 'master$master',
      firstName: 'Skull',
      lastName: 'Dot',
      verifiedAt: DateTime.utc(),
    }
  )

  logger.info('App initialized')
}

```
-------------------------------
[playground/backend/app/controllers/auth/password/update_controller.ts]

```ts
import { acceptablePassword } from '#helpers/acceptable_password'
import { PasswordSchema } from '#validators/index'
import hash from '@adonisjs/core/services/hash'
import { ProcessingException } from '@folie/castle/exception'
import { handler } from '@folie/castle/helpers'
import vine from '@vinejs/vine'

export default class Controller {
  input = vine.compile(
    vine.object({
      oldPassword: PasswordSchema,
      newPassword: PasswordSchema,
    })
  )

  handle = handler(async ({ ctx }) => {
    const [payload, user] = await Promise.all([
      ctx.request.validateUsing(this.input),
      ctx.auth.session.getUser(),
    ])

    if (payload.oldPassword === payload.newPassword) {
      throw new ProcessingException('New password cannot be the same as old password', {
        source: 'newPassword',
      })
    }

    if (!(await hash.verify(user.password, payload.oldPassword))) {
      throw new ProcessingException('Invalid password', {
        source: 'oldPassword',
      })
    }

    const passRes = acceptablePassword(payload.newPassword, [
      user.firstName,
      user.lastName,
      user.email,
    ])

    if (!passRes.result) {
      throw new ProcessingException(passRes.reason, {
        source: 'newPassword',
      })
    }

    user.password = payload.newPassword

    await user.save()

    return {
      message: 'You have successfully updated your password',
    }
  })
}

```
-------------------------------
[playground/backend/app/controllers/auth/profile/update_controller.ts]

```ts
import { NameSchema } from '#validators/index'
import { handler } from '@folie/castle/helpers'
import vine from '@vinejs/vine'

export default class Controller {
  input = vine.compile(
    vine.object({
      firstName: NameSchema.optional(),
      lastName: NameSchema.optional(),
    })
  )

  handle = handler(async ({ ctx }) => {
    const [payload, user] = await Promise.all([
      ctx.request.validateUsing(this.input),
      ctx.auth.session.getUser(),
    ])

    if (payload.firstName) {
      user.firstName = payload.firstName
    }

    if (payload.lastName) {
      user.lastName = payload.lastName
    }

    await user.save()

    return { user: user.$serialize(), message: 'Your profile has been updated' }
  })
}

```
-------------------------------
[playground/backend/app/controllers/auth/session_controller.ts]

```ts
import { handler } from '@folie/castle/helpers'

export default class Controller {
  handle = handler(async ({ ctx }) => {
    const user = await ctx.auth.session.getUser()

    return { session: user.$serialize() }
  })
}

```
-------------------------------
[playground/backend/app/controllers/auth/sign_in_controller.ts]

```ts
import { setting } from '#config/setting'
import Session from '#models/session'
import User from '#models/user'
import { GmailSchema, PasswordSchema } from '#validators/index'
import hash from '@adonisjs/core/services/hash'
import vine from '@vinejs/vine'
import limiter from '@adonisjs/limiter/services/main'
import mail from '@adonisjs/mail/services/main'
import EmailVerificationMail from '#mails/email_verification'
import { handler } from '@folie/castle/helpers'
import { ProcessingException } from '@folie/castle/exception'

export default class Controller {
  input = vine.compile(
    vine.object({
      email: GmailSchema,
      password: PasswordSchema,
    })
  )

  handle = handler(async ({ ctx }) => {
    if (!setting.signIn.enabled) {
      throw new ProcessingException('Sign-in is disabled', {
        status: 'FORBIDDEN',
      })
    }

    const payload = await ctx.request.validateUsing(this.input)

    const user = await User.findBy('email', payload.email)

    if (!user) {
      await hash.make(payload.password)

      throw new ProcessingException('Invalid credentials', {
        meta: {
          email: payload.email,
          message: "User doesn't exist",
        },
      })
    }

    if (!(await hash.verify(user.password, payload.password))) {
      throw new ProcessingException('Invalid credentials', {
        meta: {
          email: payload.email,
          message: 'Invalid password',
        },
      })
    }

    if (!user.verifiedAt) {
      if (!setting.signUp.verification.enabled) {
        throw new ProcessingException('Email not verified', {
          source: 'email',
        })
      }

      const mailLimiter = limiter.use({
        requests: 3,
        duration: '1 hour',
      })

      const key = `resend_verification_mail_${user.id}`

      const mailRes = await mailLimiter.attempt(key, async () => {
        return mail.send(new EmailVerificationMail(user))
      })

      if (!mailRes) {
        const availableIn = await mailLimiter.availableIn(key)

        throw new ProcessingException(
          `You have exceeded the rate limit for sending verification emails. Please try again in ${availableIn} seconds.`,
          {
            source: 'email',
          }
        )
      }

      throw new ProcessingException("We've sent you an email to verify your account.", {
        source: 'email',
      })
    }

    const session = await Session.manager.create(user)

    return {
      token: session.value.release(),
      message: `You have successfully signed in!`,
    }
  })
}

```
-------------------------------
[playground/backend/app/controllers/auth/sign_up_controller.ts]

```ts
import { setting } from '#config/setting'
import EmailVerificationMail from '#mails/email_verification'
import User from '#models/user'
import { GmailSchema, NameSchema, PasswordSchema } from '#validators/index'
import vine from '@vinejs/vine'
import { DateTime } from 'luxon'
import mail from '@adonisjs/mail/services/main'
import { acceptablePassword } from '#helpers/acceptable_password'
import db from '@adonisjs/lucid/services/db'
import { ProcessingException } from '@folie/castle/exception'
import { handler } from '@folie/castle/helpers'

export default class Controller {
  input = vine.compile(
    vine.object({
      firstName: NameSchema,
      lastName: NameSchema,
      email: GmailSchema,
      password: PasswordSchema,
      confirmPassword: PasswordSchema.sameAs('password'),
    })
  )

  handle = handler(async ({ ctx }) => {
    if (!setting.signUp.enabled) {
      throw new ProcessingException('Sign-up is disabled', {
        status: 'FORBIDDEN',
      })
    }

    const payload = await ctx.request.validateUsing(this.input)

    const exist = await User.findBy('email', payload.email)

    if (exist) {
      throw new ProcessingException('Email already exists', {
        source: 'email',
      })
    }

    const passRes = acceptablePassword(payload.password, [
      payload.firstName,
      payload.lastName,
      payload.email,
    ])

    if (!passRes.result) {
      throw new ProcessingException(passRes.reason, {
        source: 'password',
      })
    }

    const trx = await db.transaction()

    try {
      const user = await User.create(
        {
          firstName: payload.firstName,
          lastName: payload.lastName,
          email: payload.email,
          password: payload.password,
          verifiedAt: setting.signUp.verification.enabled ? null : DateTime.utc(),
        },
        {
          client: trx,
        }
      )

      let message = 'You have successfully signed up!'

      if (setting.signUp.verification.enabled) {
        await mail.send(new EmailVerificationMail(user))

        message = 'An email has been sent to your email address'
      }

      await trx.commit()

      return {
        message,
      }
    } catch (error) {
      await trx.rollback()

      throw error
    }
  })
}

```
-------------------------------
[playground/backend/app/controllers/auth/verify_controller.ts]

```ts
import { setting } from '#config/setting'
import vine from '@vinejs/vine'
import encryption from '@adonisjs/core/services/encryption'
import User from '#models/user'
import { DateTime } from 'luxon'
import { handler } from '@folie/castle/helpers'
import { ProcessingException } from '@folie/castle/exception'

export default class Controller {
  input = vine.compile(
    vine.object({
      token: vine.string().minLength(150).maxLength(300),
    })
  )

  handle = handler(async ({ ctx }) => {
    if (!setting.signUp.verification.enabled) {
      throw new ProcessingException('Email verification is disabled', {
        status: 'FORBIDDEN',
      })
    }

    const payload = await ctx.request.validateUsing(this.input)

    const decryptedToken = encryption.decrypt<{ email: string }>(
      payload.token,
      setting.signUp.verification.purpose
    )

    if (!decryptedToken) {
      throw new ProcessingException('Invalid token', {
        meta: {
          reason: 'Token decryption failed',
        },
      })
    }

    const user = await User.findBy('email', decryptedToken.email)

    if (!user) {
      throw new ProcessingException('Invalid token', {
        meta: {
          reason: 'User not found',
        },
      })
    }

    if (user.verifiedAt) {
      throw new ProcessingException('Invalid token', {
        meta: {
          reason: 'User already verified',
        },
      })
    }

    user.verifiedAt = DateTime.utc()

    await user.save()

    return {
      message: 'Email verified successfully',
    }
  })
}

```
-------------------------------
[playground/backend/app/controllers/note/create_controller.ts]

```ts
import { setting } from '#config/setting'
import { ProcessingException } from '@folie/castle/exception'
import { handler } from '@folie/castle/helpers'

export default class Controller {
  handle = handler(async ({ ctx }) => {
    const user = await ctx.auth.session.getUser()

    const metrics = await user.$metric()

    if (metrics.notes >= setting.notes.perUser) {
      throw new ProcessingException('Maximum notes reached')
    }

    const note = await user.related('notes').create({
      title: 'Untitled',
      body: '',
    })

    return { note: note.$serialize(), message: 'Note created successfully' }
  })
}

```
-------------------------------
[playground/backend/app/controllers/note/delete_controller.ts]

```ts
import { squid } from '#config/squid'
import Note from '#models/note'
import { ProcessingException } from '@folie/castle/exception'
import { handler } from '@folie/castle/helpers'
import vine from '@vinejs/vine'

export default class Controller {
  input = vine.compile(
    vine.object({
      params: vine.object({
        noteId: squid.note.schema,
      }),
    })
  )

  handle = handler(async ({ ctx }) => {
    const payload = await ctx.request.validateUsing(this.input)

    const { userId } = ctx.auth.session

    const note = await Note.query()
      .where('id', payload.params.noteId)
      .andWhere('userId', userId)
      .first()

    if (!note) {
      throw new ProcessingException('Note not found', {
        status: 'NOT_FOUND',
      })
    }

    await note.delete()

    return {
      note: note.$serialize(),
      message: `Note "${note.title}" deleted successfully`,
    }
  })
}

```
-------------------------------
[playground/backend/app/controllers/note/list_controller.ts]

```ts
import vine from '@vinejs/vine'
import { PageSchema, LimitSchema, OrderSchema } from '@folie/castle/validator'
import { handler, serializePage } from '@folie/castle/helpers'
import Note from '#models/note'
import { NoteTitleSchema } from '#validators/index'
import { setting } from '#config/setting'

export default class Controller {
  input = vine.compile(
    vine.object({
      query: vine
        .object({
          page: PageSchema.optional(),
          limit: LimitSchema.optional(),

          order: OrderSchema('createdAt', 'updatedAt', 'title', 'id').optional(),

          filter: vine
            .object({
              value: NoteTitleSchema.optional(),
            })
            .optional(),
        })
        .optional(),
    })
  )

  handle = handler(async ({ ctx }) => {
    const payload = await ctx.request.validateUsing(this.input)

    const { userId } = ctx.auth.session

    // Start building the query to fetch tags
    let listQuery = Note.query().where('userId', userId)

    // Filter by note title if provided
    if (payload.query?.filter?.value) {
      const filterValue = payload.query.filter.value

      if (filterValue.startsWith('tag:')) {
        const tagFilterValue = filterValue.slice(4)

        if (tagFilterValue.length > 0) {
          listQuery.andWhereHas('tags', (ta) => {
            ta.whereLike('name', `%${tagFilterValue}%`)
          })
        }
      } else {
        listQuery = listQuery.andWhereLike('title', `%${payload.query.filter.value}%`)
      }
    }

    listQuery = listQuery.preload('tags', (ta) => {
      ta.limit(setting.tags.perNote).orderBy('name', 'asc')
    })

    // Execute the query and paginate results
    const list = await listQuery
      .orderBy(payload.query?.order?.by ?? 'createdAt', payload.query?.order?.dir ?? 'desc')
      .paginate(payload.query?.page ?? 1, payload.query?.limit ?? 10)

    return serializePage(list, (d) => ({
      ...d.$serialize(),
      tags: d.tags.map((tag) => tag.$serialize()),
    }))
  })
}

```
-------------------------------
[playground/backend/app/controllers/note/show_controller.ts]

```ts
import { squid } from '#config/squid'
import Note from '#models/note'
import { ProcessingException } from '@folie/castle/exception'
import { handler } from '@folie/castle/helpers'
import vine from '@vinejs/vine'

export default class Controller {
  input = vine.compile(
    vine.object({
      params: vine.object({
        noteId: squid.note.schema,
      }),
    })
  )

  handle = handler(async ({ ctx }) => {
    const payload = await ctx.request.validateUsing(this.input)

    const { userId } = ctx.auth.session

    const note = await Note.query()
      .where('id', payload.params.noteId)
      .andWhere('userId', userId)
      .first()

    if (!note) {
      throw new ProcessingException('Note not found', {
        status: 'NOT_FOUND',
      })
    }

    return { note: note.$serialize() }
  })
}

```
-------------------------------
[playground/backend/app/controllers/note/tag/update_controller.ts]

```ts
import { setting } from '#config/setting'
import { squid } from '#config/squid'
import Note from '#models/note'
import Tag from '#models/tag'
import { ProcessingException } from '@folie/castle/exception'
import { handler } from '@folie/castle/helpers'
import vine from '@vinejs/vine'
import { DateTime } from 'luxon'

export default class Controller {
  input = vine.compile(
    vine.object({
      params: vine.object({
        noteId: squid.note.schema,
      }),
      tagId: squid.tag.schema,
      action: vine.enum(['add', 'remove']),
    })
  )

  handle = handler(async ({ ctx }) => {
    const payload = await ctx.request.validateUsing(this.input)

    const { userId } = ctx.auth.session

    const note = await Note.query()
      .where('id', payload.params.noteId)
      .andWhere('userId', userId)
      .preload('tags', (ta) => {
        ta.limit(setting.tags.perUser)
      })
      .first()

    if (!note) {
      throw new ProcessingException('Note not found', {
        status: 'NOT_FOUND',
      })
    }

    const isTagPresent = (tagIdToCheck: number) => note.tags.some((tag) => tag.id === tagIdToCheck)

    if (payload.action === 'add') {
      if (note.tags.length >= setting.tags.perNote) {
        throw new ProcessingException(`Only ${setting.tags.perNote} tags allowed per note`, {
          status: 'BAD_REQUEST',
        })
      }

      if (isTagPresent(payload.tagId)) {
        throw new ProcessingException('Tag already added')
      }

      const exist = await Tag.query().where('userId', userId).andWhere('id', payload.tagId).first()

      if (!exist) {
        throw new ProcessingException('Tag not found')
      }

      note.updatedAt = DateTime.utc()

      await Promise.all([
        note.related('tags').attach([payload.tagId]),
        note.save(),
        exist.$cache().expire('metric'),
      ])

      return { message: 'Tag added successfully' }
    } else {
      if (!isTagPresent(payload.tagId)) {
        throw new ProcessingException('Tag not found')
      }

      note.updatedAt = DateTime.utc()

      await Promise.all([
        note.related('tags').detach([payload.tagId]),
        note.save(),
        Tag.$cache().expire({
          id: payload.tagId,
          key: 'metric',
        }),
      ])

      return { message: 'Tag removed successfully' }
    }
  })
}

```
-------------------------------
[playground/backend/app/controllers/note/update_controller.ts]

```ts
import { squid } from '#config/squid'
import Note from '#models/note'
import { NoteBodySchema, NoteTitleSchema } from '#validators/index'
import { ProcessingException } from '@folie/castle/exception'
import { handler } from '@folie/castle/helpers'
import vine from '@vinejs/vine'

export default class Controller {
  input = vine.compile(
    vine.object({
      params: vine.object({
        noteId: squid.note.schema,
      }),
      title: NoteTitleSchema.optional(),
      body: NoteBodySchema.optional(),
    })
  )

  handle = handler(async ({ ctx }) => {
    const payload = await ctx.request.validateUsing(this.input)

    const { userId } = ctx.auth.session

    const note = await Note.query()
      .where('id', payload.params.noteId)
      .andWhere('userId', userId)
      .first()

    if (!note) {
      throw new ProcessingException('Note not found', {
        status: 'NOT_FOUND',
      })
    }

    if (payload.title) {
      note.title = payload.title
    }

    if (payload.body) {
      note.body = payload.body
    }

    await note.save()

    return { note: note.$serialize(), message: `Note "${note.title}" updated successfully` }
  })
}

```
-------------------------------
[playground/backend/app/controllers/ping_controller.ts]

```ts
import { handler } from '@folie/castle/helpers'

export default class Controller {
  handle = handler(async () => {
    return { message: 'pong' }
  })
}

```
-------------------------------
[playground/backend/app/controllers/tag/create_controller.ts]

```ts
import { setting } from '#config/setting'
import { TagDescriptionSchema, TagNameSchema } from '#validators/index'
import { ProcessingException } from '@folie/castle/exception'
import { handler, slugify } from '@folie/castle/helpers'
import vine from '@vinejs/vine'

export default class Controller {
  input = vine.compile(
    vine.object({
      name: TagNameSchema,
      description: TagDescriptionSchema.optional(),
    })
  )

  handle = handler(async ({ ctx }) => {
    const [payload, user] = await Promise.all([
      ctx.request.validateUsing(this.input),
      ctx.auth.session.getUser(),
    ])

    const metrics = await user.$metric()

    if (metrics.notes >= setting.notes.perUser) {
      throw new ProcessingException('Maximum notes reached')
    }

    const slug = slugify(payload.name)

    const exist = await user.related('tags').query().where('slug', slug).first()

    if (exist) {
      throw new ProcessingException('Tag already exists')
    }

    const tag = await user.related('tags').create({
      slug,
      name: payload.name,
      description: payload.description,
    })

    return { tag: tag.$serialize(), message: `Tag "${tag.name}" created successfully` }
  })
}

```
-------------------------------
[playground/backend/app/controllers/tag/delete_controller.ts]

```ts
import { squid } from '#config/squid'
import Tag from '#models/tag'
import { ProcessingException } from '@folie/castle/exception'
import { handler } from '@folie/castle/helpers'
import vine from '@vinejs/vine'

export default class Controller {
  input = vine.compile(
    vine.object({
      params: vine.object({
        tagId: squid.tag.schema,
      }),
    })
  )

  handle = handler(async ({ ctx }) => {
    const payload = await ctx.request.validateUsing(this.input)

    const { userId } = ctx.auth.session

    const tag = await Tag.query()
      .where('id', payload.params.tagId)
      .andWhere('userId', userId)
      .first()

    if (!tag) {
      throw new ProcessingException('Tag not found', {
        status: 'NOT_FOUND',
      })
    }

    await tag.delete()

    return {
      tag: tag.$serialize(),
      message: `Tag "${tag.name}" deleted successfully`,
    }
  })
}

```
-------------------------------
[playground/backend/app/controllers/tag/list_controller.ts]

```ts
import vine from '@vinejs/vine'
import { PageSchema, LimitSchema, OrderSchema } from '@folie/castle/validator'
import { handler, serializePage } from '@folie/castle/helpers'
import Tag from '#models/tag'
import { squid } from '#config/squid'
import { TagNameSchema } from '#validators/index'
import { castle } from '#config/castle'

export default class Controller {
  // Define input validation schema
  input = vine.compile(
    vine.object({
      query: vine
        .object({
          page: PageSchema.optional(),
          limit: LimitSchema.optional(),

          // Allow ordering by these fields
          order: OrderSchema('createdAt', 'updatedAt', 'name', 'id').optional(),

          filter: vine
            .object({
              noteId: squid.note.schema.optional(),
              value: TagNameSchema.optional(),
            })
            .optional(),

          properties: vine
            .object({
              metric: vine.boolean().optional(),
            })
            .optional(),
        })
        .optional(),
    })
  )

  handle = handler(async ({ ctx }) => {
    // Validate the request input
    const payload = await ctx.request.validateUsing(this.input)

    const { userId } = ctx.auth.session

    // Start building the query to fetch tags
    let listQuery = Tag.query().where('userId', userId)

    // Filter by noteId if provided
    if (payload.query?.filter?.noteId) {
      const noteId = payload.query.filter.noteId

      listQuery = listQuery.andWhereHas('notes', (query) => {
        query.where(castle.table.note('id'), noteId)
      })
    }

    // Filter by tag name if provided
    if (payload.query?.filter?.value) {
      listQuery = listQuery.andWhereLike('name', `%${payload.query.filter.value}%`)
    }

    // Execute the query and paginate results
    const list = await listQuery
      .orderBy(payload.query?.order?.by ?? 'createdAt', payload.query?.order?.dir ?? 'desc')
      .paginate(payload.query?.page ?? 1, payload.query?.limit ?? 10)

    // Serialize and return the paginated results
    return serializePage(list, async (d) => {
      const addMetric = payload.query?.properties?.metric

      return {
        ...d.$serialize(),
        metric: addMetric ? await d.$metric() : null,
      }
    })
  })
}

```
-------------------------------
[playground/backend/app/controllers/tag/show_controller.ts]

```ts
import { squid } from '#config/squid'
import Tag from '#models/tag'
import { ProcessingException } from '@folie/castle/exception'
import { handler } from '@folie/castle/helpers'
import vine from '@vinejs/vine'

export default class Controller {
  input = vine.compile(
    vine.object({
      params: vine.object({
        tagId: squid.tag.schema,
      }),
    })
  )

  handle = handler(async ({ ctx }) => {
    const payload = await ctx.request.validateUsing(this.input)

    const { userId } = ctx.auth.session

    const tag = await Tag.query()
      .where('id', payload.params.tagId)
      .andWhere('userId', userId)
      .first()

    if (!tag) {
      throw new ProcessingException('Tag not found', {
        status: 'NOT_FOUND',
      })
    }

    return { tag: tag.$serialize() }
  })
}

```
-------------------------------
[playground/backend/app/controllers/tag/update_controller.ts]

```ts
import { squid } from '#config/squid'
import Tag from '#models/tag'
import { TagDescriptionSchema, TagNameSchema } from '#validators/index'
import { ProcessingException } from '@folie/castle/exception'
import { handler } from '@folie/castle/helpers'
import vine from '@vinejs/vine'

export default class Controller {
  input = vine.compile(
    vine.object({
      params: vine.object({
        tagId: squid.tag.schema,
      }),
      name: TagNameSchema.optional(),
      description: TagDescriptionSchema.optional(),
    })
  )

  handle = handler(async ({ ctx }) => {
    const payload = await ctx.request.validateUsing(this.input)

    const { userId } = ctx.auth.session

    const tag = await Tag.query()
      .where('id', payload.params.tagId)
      .andWhere('userId', userId)
      .first()

    if (!tag) {
      throw new ProcessingException('Tag not found', {
        status: 'NOT_FOUND',
      })
    }

    if (payload.name) {
      tag.name = payload.name
    }

    if (payload.description) {
      tag.description = payload.description
    }

    await tag.save()

    return { tag: tag.$serialize(), message: `Tag "${tag.name}" updated successfully` }
  })
}

```
-------------------------------
[playground/backend/app/exceptions/handler.ts]

```ts
import app from '@adonisjs/core/services/app'
import { HttpContext, ExceptionHandler } from '@adonisjs/core/http'
import env from '#start/env'
import { ProcessingException } from '@folie/castle/exception'

export default class HttpExceptionHandler extends ExceptionHandler {
  /**
   * In debug mode, the exception handler will display verbose errors
   * with pretty printed stack traces.
   */
  protected debug = !!app.inProduction

  protected shouldReport(): boolean {
    return env.get('REPORT_ERRORS', true)
  }

  /**
   * The method is used for handling errors and returning
   * response to the client
   */
  async handle(error: unknown, ctx: HttpContext) {
    return super.handle(ProcessingException.fromError(error), ctx)
  }

  /**
   * The method is used to report error to the logging service or
   * the third party error monitoring service.
   *
   * @note You should not attempt to send a response from this method.
   */
  async report(error: unknown, ctx: HttpContext) {
    return super.report(ProcessingException.fromError(error), ctx)
  }
}

```
-------------------------------
[playground/backend/app/helpers/acceptable_password.ts]

```ts
import { setting } from '#config/setting'
import { zxcvbn } from '#config/zxcvbn'
import string from '@adonisjs/core/helpers/string'

/**
 * Validates a password against defined security requirements.
 */
export const acceptablePassword = (
  password: string,
  userInputs?: string[]
): { result: true } | { result: false; reason: string } => {
  // Check if password length is less than the minimum required length.
  if (password.length < setting.passwordRequirement.size.min) {
    return {
      result: false,
      reason: `Too short (min length ${setting.passwordRequirement.size.min})`,
    }
  } // Check if password length exceeds the maximum allowed length.

  if (password.length > setting.passwordRequirement.size.max) {
    return {
      result: false,
      reason: `Too long (max length ${setting.passwordRequirement.size.max})`,
    }
  } // Analyze password strength using zxcvbn library.

  const result = zxcvbn(password, userInputs) // Check if the password can be cracked too quickly.

  if (
    result.crackTimesSeconds.offlineSlowHashing1e4PerSecond < setting.passwordRequirement.crackTime
  ) {
    return {
      result: false,
      reason: `Can be cracked in ${result.crackTimesDisplay.offlineSlowHashing1e4PerSecond} (min ${string.seconds.format(setting.passwordRequirement.crackTime, true)})`,
    }
  } // Check if the password score is below the minimum required score.

  if (result.score <= setting.passwordRequirement.score) {
    return {
      result: false,
      reason: `Too weak (min score ${setting.passwordRequirement.score})`,
    }
  } // If all checks pass, the password is considered acceptable.

  return {
    result: true,
  }
}

```
-------------------------------
[playground/backend/app/mails/email_verification.ts]

```ts
import { setting } from '#config/setting'
import User from '#models/user'
import env from '#start/env'
import logger from '@adonisjs/core/services/logger'
import router from '@adonisjs/core/services/router'
import { BaseMail } from '@adonisjs/mail'
import encryption from '@adonisjs/core/services/encryption'

export default class EmailVerificationMail extends BaseMail {
  subject = 'Verify your email'

  constructor(private user: User) {
    super()
  }

  prepare() {
    const encryptedToken = encryption.encrypt(
      { email: this.user.email },
      setting.signUp.verification.expiresIn,
      setting.signUp.verification.purpose
    )

    const url = router
      .builder()
      .disableRouteLookup()
      .prefixUrl(new URL(env.get('APP_URL')).origin)
      .qs({ token: encryptedToken })
      .make('/verify')

    logger.debug({ url }, `Verify email for user ${this.user.id}`)

    this.message.to(this.user.email)
    this.message.htmlView('emails/email_verification', {
      url,
    })
  }
}

```
-------------------------------
[playground/backend/app/middleware/auth_middleware.ts]

```ts
import Session from '#models/session'
import type { HttpContext } from '@adonisjs/core/http'
import type { NextFn } from '@adonisjs/core/types/http'

export default class AuthMiddleware {
  async handle(ctx: HttpContext, next: NextFn, options?: { bypass?: true }) {
    try {
      const session = await Session.manager.authenticate(ctx)

      ctx.auth = {
        ...ctx.auth,
        session,
      }

      return next()
    } catch (error) {
      if (options?.bypass === true) {
        return next()
      }

      throw error
    }
  }
}

```
-------------------------------
[playground/backend/app/middleware/captcha_middleware.ts]

```ts
import { captcha } from '#config/captcha'
import env from '#start/env'
import type { HttpContext } from '@adonisjs/core/http'
import type { NextFn } from '@adonisjs/core/types/http'
import vine from '@vinejs/vine'
import { ProcessingException } from '@folie/castle/exception'

const schema = vine.compile(
  vine.object({
    headers: vine.object({
      token: vine.string().maxLength(2048).minLength(10),
    }),
  })
)

export default class CaptchaMiddleware {
  async handle(ctx: HttpContext, next: NextFn) {
    if (env.get('NODE_ENV') === 'test') {
      return next()
    }

    const payload = await ctx.request.validateUsing(schema)

    const [isValid] = await captcha
      .use()
      .verify({ token: payload.headers.token, ip: ctx.request.ip() })

    if (!isValid) {
      throw new ProcessingException('Invalid captcha', {
        meta: {
          token: payload.headers.token,
          ip: ctx.request.ip(),
        },
      })
    }

    return next()
  }
}

```
-------------------------------
[playground/backend/app/middleware/container_bindings_middleware.ts]

```ts
import { Logger } from '@adonisjs/core/logger'
import { HttpContext } from '@adonisjs/core/http'
import type { NextFn } from '@adonisjs/core/types/http'
import Session from '#models/session'

/**
 * The container bindings middleware binds classes to their request
 * specific value using the container resolver.
 *
 * - We bind "HttpContext" class to the "ctx" object
 * - And bind "Logger" class to the "ctx.logger" object
 */
export default class ContainerBindingsMiddleware {
  handle(ctx: HttpContext, next: NextFn) {
    ctx.containerResolver.bindValue(HttpContext, ctx)
    ctx.containerResolver.bindValue(Logger, ctx.logger)

    return next()
  }
}

declare module '@adonisjs/core/http' {
  export interface HttpContext {
    auth: {
      session: Session
    }
  }
}

```
-------------------------------
[playground/backend/app/middleware/initialize_bouncer_middleware.ts]

```ts
import * as abilities from '#abilities/main'

import { Bouncer } from '@adonisjs/bouncer'
import type { HttpContext } from '@adonisjs/core/http'
import type { NextFn } from '@adonisjs/core/types/http'

/**
 * Init bouncer middleware is used to create a bouncer instance
 * during an HTTP request
 */
export default class InitializeBouncerMiddleware {
  async handle(ctx: HttpContext, next: NextFn) {
    /**
     * Create bouncer instance for the ongoing HTTP request.
     * We will pull the user from the HTTP context.
     */
    ctx.bouncer = new Bouncer(() => ctx, abilities).setContainerResolver(ctx.containerResolver)

    return next()
  }
}

declare module '@adonisjs/core/http' {
  export interface HttpContext {
    bouncer: Bouncer<Exclude<HttpContext, undefined>, typeof abilities>
  }
}

```
-------------------------------
[playground/backend/app/models/note.ts]

```ts
import { DateTime } from 'luxon'
import { BaseModel, belongsTo, column, manyToMany } from '@adonisjs/lucid/orm'
import type { BelongsTo, ManyToMany } from '@adonisjs/lucid/types/relations'
import { squid } from '#config/squid'
import cache from '@adonisjs/cache/services/main'
import User from './user.js'
import { castle } from '#config/castle'
import { serializeDT } from '@folie/castle/helpers'
import { ModelCache } from '@folie/castle'
import Tag from './tag.js'

export default class Note extends BaseModel {
  static table = castle.table.note()

  // Serialize =============================

  static $serialize(row: Note) {
    return {
      id: squid.note.encode(row.id),

      userId: squid.user.encode(row.userId),
      title: row.title,
      body: row.body,

      createdAt: serializeDT(row.createdAt),
      updatedAt: serializeDT(row.updatedAt),
    }
  }

  $serialize() {
    return Note.$serialize(this)
  }

  $toJSON() {
    return {
      id: this.id,

      userId: this.userId,
      title: this.title,
      body: this.body,

      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    }
  }

  // Cache =============================

  static $cache() {
    return new ModelCache(Note, cache.namespace(this.table))
  }

  $cache() {
    return Note.$cache().row(this)
  }

  // Columns =============================

  @column({ isPrimary: true })
  declare id: number

  @column()
  declare userId: number

  @column()
  declare title: string

  @column()
  declare body: string

  // DateTime =============================

  @column.dateTime({ autoCreate: true })
  declare createdAt: DateTime

  @column.dateTime({ autoCreate: true, autoUpdate: true })
  declare updatedAt: DateTime

  // Hooks =============================

  // Relations =============================

  @belongsTo(() => User)
  declare user: BelongsTo<typeof User>

  @manyToMany(() => Tag, castle.pivot.noteTags)
  declare tags: ManyToMany<typeof Tag>

  // Extra ======================================
}

```
-------------------------------
[playground/backend/app/models/session.ts]

```ts
import { DateTime } from 'luxon'
import { BaseModel, belongsTo, column } from '@adonisjs/lucid/orm'
import User from './user.js'
import type { BelongsTo } from '@adonisjs/lucid/types/relations'
import { squid } from '#config/squid'
import { castle } from '#config/castle'
import { serializeDT } from '@folie/castle/helpers'
import { Secret } from '@adonisjs/core/helpers'
import { SessionManager } from '@folie/castle'

export default class Session extends BaseModel {
  static table = castle.table.session()

  static manager = new SessionManager(Session)

  // ====================================

  static $serialize(row: Session) {
    return {
      id: squid.session.encode(row.id),
      createdAt: serializeDT(row.createdAt),
      updatedAt: serializeDT(row.updatedAt),
      expiresAt: serializeDT(row.expiresAt),

      /**
       * Last used at
       */
      usedAt: serializeDT(row.usedAt),
    }
  }

  $serialize(this: Session) {
    return Session.$serialize(this)
  }

  $toJSON(this: Session) {
    return {
      id: this.id,
      hash: this.hash,
      userId: this.userId,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
      expiresAt: this.expiresAt,
      usedAt: this.usedAt,
    }
  }

  // ====================================

  @column({ isPrimary: true })
  declare id: number

  @column()
  declare hash: string

  @column()
  declare userId: number

  @belongsTo(() => User)
  declare user: BelongsTo<typeof User>

  async getUser(this: Session) {
    await this.load('user')

    return this.user
  }

  @column.dateTime({ autoCreate: true })
  declare createdAt: DateTime

  @column.dateTime({ autoCreate: true, autoUpdate: true })
  declare updatedAt: DateTime

  @column.dateTime()
  declare expiresAt: DateTime | null

  @column.dateTime()
  declare usedAt: DateTime | null

  declare value: Secret<string> | null
  declare secret: Secret<string> | null
}

```
-------------------------------
[playground/backend/app/models/tag.ts]

```ts
import { DateTime } from 'luxon'
import { BaseModel, belongsTo, column, manyToMany } from '@adonisjs/lucid/orm'
import type { BelongsTo, ManyToMany } from '@adonisjs/lucid/types/relations'
import { squid } from '#config/squid'
import cache from '@adonisjs/cache/services/main'
import User from './user.js'
import { castle } from '#config/castle'
import { serializeDT } from '@folie/castle/helpers'
import { ModelCache } from '@folie/castle'
import Note from './note.js'

export default class Tag extends BaseModel {
  static table = castle.table.tag()

  // Serialize =============================

  static $serialize(row: Tag) {
    return {
      id: squid.tag.encode(row.id),

      userId: squid.user.encode(row.userId),
      slug: row.slug,
      name: row.name,
      description: row.description,

      createdAt: serializeDT(row.createdAt),
      updatedAt: serializeDT(row.updatedAt),
    }
  }

  $serialize() {
    return Tag.$serialize(this)
  }

  $toJSON() {
    return {
      id: this.id,

      userId: this.userId,
      slug: this.slug,
      name: this.name,
      description: this.description,

      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    }
  }

  // Cache =============================

  static $cache() {
    return new ModelCache(Tag, cache.namespace(this.table), ['metric'])
  }

  $cache() {
    return Tag.$cache().row(this)
  }

  $metric(this: Tag) {
    return this.$cache().get({
      key: 'metric',
      factory: async () => {
        const notes = await this.related('notes').query().count('* as total')

        return { notes: notes[0].$extras.total }
      },
      parser: async (p) => p,
    })
  }

  // Columns =============================

  @column({ isPrimary: true })
  declare id: number

  @column()
  declare userId: number

  @column()
  declare slug: string

  @column()
  declare name: string

  @column()
  declare description: string | null

  // DateTime =============================

  @column.dateTime({ autoCreate: true })
  declare createdAt: DateTime

  @column.dateTime({ autoCreate: true, autoUpdate: true })
  declare updatedAt: DateTime

  // Hooks =============================

  // Relations =============================

  @belongsTo(() => User)
  declare user: BelongsTo<typeof User>

  @manyToMany(() => Note, castle.pivot.noteTags)
  declare notes: ManyToMany<typeof Note>

  // Extra ======================================
}

```
-------------------------------
[playground/backend/app/models/user.ts]

```ts
import { DateTime } from 'luxon'
import { BaseModel, beforeSave, column, hasMany } from '@adonisjs/lucid/orm'
import hash from '@adonisjs/core/services/hash'
import Session from './session.js'
import type { HasMany } from '@adonisjs/lucid/types/relations'
import { squid } from '#config/squid'
import cache from '@adonisjs/cache/services/main'
import Note from './note.js'
import { castle } from '#config/castle'
import { serializeDT } from '@folie/castle/helpers'
import { ModelCache } from '@folie/castle'
import Tag from './tag.js'

export default class User extends BaseModel {
  static table = castle.table.user()

  // Serialize =============================

  static $serialize(row: User) {
    return {
      id: squid.user.encode(row.id),

      firstName: row.firstName,
      lastName: row.lastName,

      email: row.email,

      createdAt: serializeDT(row.createdAt),
      updatedAt: serializeDT(row.updatedAt),
      verifiedAt: serializeDT(row.verifiedAt),
    }
  }

  $serialize() {
    return User.$serialize(this)
  }

  $toJSON() {
    return {
      id: this.id,

      firstName: this.firstName,
      lastName: this.lastName,

      email: this.email,
      password: this.password,

      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
      verifiedAt: this.verifiedAt,
    }
  }

  // Cache =============================

  static $cache() {
    return new ModelCache(User, cache.namespace(this.table), ['metric'])
  }

  $cache() {
    return User.$cache().row(this)
  }

  $metric(this: User) {
    return this.$cache().get({
      key: 'metric',
      factory: async () => {
        const [notes, tags] = await Promise.all([
          this.related('notes').query().count('* as total'),
          this.related('tags').query().count('* as total'),
        ])

        return { notes: notes[0].$extras.total, tags: tags[0].$extras.total }
      },
      parser: async (p) => p,
    })
  }

  // Columns =============================

  @column({ isPrimary: true })
  declare id: number

  @column()
  declare firstName: string

  @column()
  declare lastName: string

  @column()
  declare email: string

  @column()
  declare password: string

  // DateTime =============================

  @column.dateTime({ autoCreate: true })
  declare createdAt: DateTime

  @column.dateTime({ autoCreate: true, autoUpdate: true })
  declare updatedAt: DateTime

  @column.dateTime()
  declare verifiedAt: DateTime | null

  // Hooks =============================

  @beforeSave()
  static async hashPassword(row: User) {
    if (row.$dirty.password) {
      row.password = await hash.make(row.password)
    }
  }

  // Relations =============================

  @hasMany(() => Session)
  declare sessions: HasMany<typeof Session>

  @hasMany(() => Note)
  declare notes: HasMany<typeof Note>

  @hasMany(() => Tag)
  declare tags: HasMany<typeof Tag>

  // Extra ======================================
}

```
-------------------------------
[playground/backend/app/validators/index.ts]

```ts
import { setting } from '#config/setting'
import vine from '@vinejs/vine'

export const NameSchema = vine.string().minLength(2).maxLength(100)

export const GmailSchema = vine.string().email({
  host_whitelist: ['gmail.com'],
})

export const PasswordSchema = vine
  .string()
  .minLength(setting.passwordRequirement.size.min)
  .maxLength(setting.passwordRequirement.size.max)

export const NoteTitleSchema = vine.string().minLength(1).maxLength(100)

export const NoteBodySchema = vine.string().minLength(1).maxLength(10000)

export const TagNameSchema = vine.string().minLength(1).maxLength(20)

export const TagDescriptionSchema = vine.string().minLength(1).maxLength(100)

```
-------------------------------
[playground/backend/bin/console.ts]

```ts
/*
|--------------------------------------------------------------------------
| Ace entry point
|--------------------------------------------------------------------------
|
| The "console.ts" file is the entrypoint for booting the AdonisJS
| command-line framework and executing commands.
|
| Commands do not boot the application, unless the currently running command
| has "options.startApp" flag set to true.
|
*/

import 'reflect-metadata'
import { Ignitor, prettyPrintError } from '@adonisjs/core'

/**
 * URL to the application root. AdonisJS need it to resolve
 * paths to file and directories for scaffolding commands
 */
const APP_ROOT = new URL('../', import.meta.url)

/**
 * The importer is used to import files in context of the
 * application.
 */
const IMPORTER = (filePath: string) => {
  if (filePath.startsWith('./') || filePath.startsWith('../')) {
    return import(new URL(filePath, APP_ROOT).href)
  }
  return import(filePath)
}

new Ignitor(APP_ROOT, { importer: IMPORTER })
  .tap((app) => {
    app.booting(async () => {
      await import('#start/env')
    })
    app.listen('SIGTERM', () => app.terminate())
    app.listenIf(app.managedByPm2, 'SIGINT', () => app.terminate())
  })
  .ace()
  .handle(process.argv.splice(2))
  .catch((error) => {
    process.exitCode = 1
    prettyPrintError(error)
  })

```
-------------------------------
[playground/backend/bin/server.ts]

```ts
/*
|--------------------------------------------------------------------------
| HTTP server entrypoint
|--------------------------------------------------------------------------
|
| The "server.ts" file is the entrypoint for starting the AdonisJS HTTP
| server. Either you can run this file directly or use the "serve"
| command to run this file and monitor file changes
|
*/

import 'reflect-metadata'
import { Ignitor, prettyPrintError } from '@adonisjs/core'

/**
 * URL to the application root. AdonisJS need it to resolve
 * paths to file and directories for scaffolding commands
 */
const APP_ROOT = new URL('../', import.meta.url)

/**
 * The importer is used to import files in context of the
 * application.
 */
const IMPORTER = (filePath: string) => {
  if (filePath.startsWith('./') || filePath.startsWith('../')) {
    return import(new URL(filePath, APP_ROOT).href)
  }
  return import(filePath)
}

new Ignitor(APP_ROOT, { importer: IMPORTER })
  .tap((app) => {
    app.booting(async () => {
      await import('#start/env')
    })
    app.listen('SIGTERM', () => app.terminate())
    app.listenIf(app.managedByPm2, 'SIGINT', () => app.terminate())
  })
  .httpServer()
  .start()
  .catch((error) => {
    process.exitCode = 1
    prettyPrintError(error)
  })

```
-------------------------------
[playground/backend/bin/test.ts]

```ts
/*
|--------------------------------------------------------------------------
| Test runner entrypoint
|--------------------------------------------------------------------------
|
| The "test.ts" file is the entrypoint for running tests using Japa.
|
| Either you can run this file directly or use the "test"
| command to run this file and monitor file changes.
|
*/

process.env.NODE_ENV = 'test'

import 'reflect-metadata'
import { Ignitor, prettyPrintError } from '@adonisjs/core'
import { configure, processCLIArgs, run } from '@japa/runner'

/**
 * URL to the application root. AdonisJS need it to resolve
 * paths to file and directories for scaffolding commands
 */
const APP_ROOT = new URL('../', import.meta.url)

/**
 * The importer is used to import files in context of the
 * application.
 */
const IMPORTER = (filePath: string) => {
  if (filePath.startsWith('./') || filePath.startsWith('../')) {
    return import(new URL(filePath, APP_ROOT).href)
  }
  return import(filePath)
}

new Ignitor(APP_ROOT, { importer: IMPORTER })
  .tap((app) => {
    app.booting(async () => {
      await import('#start/env')
    })
    app.listen('SIGTERM', () => app.terminate())
    app.listenIf(app.managedByPm2, 'SIGINT', () => app.terminate())
  })
  .testRunner()
  .configure(async (app) => {
    const { runnerHooks, ...config } = await import('../tests/bootstrap.js')

    processCLIArgs(process.argv.splice(2))
    configure({
      ...app.rcFile.tests,
      ...config,
      ...{
        setup: runnerHooks.setup,
        teardown: runnerHooks.teardown.concat([() => app.terminate()]),
      },
    })
  })
  .run(() => run())
  .catch((error) => {
    process.exitCode = 1
    prettyPrintError(error)
  })

```
-------------------------------
[playground/backend/blueprint/api/schema.ts]

```ts
/// <reference path="../reference.ts" />

import { InferController, endpoint } from '@folie/blueprint-lib'

/*
 * This is an auto-generated file. Changes made to this file will be lost.
 * Run `nr ace blueprint:generate` to update it.
 */

export type V1AuthSessionRoute = InferController<
  (typeof import('../../app/controllers/auth/session_controller.ts'))['default']
>
export type V1AuthSignOutRoute = InferController<
  (typeof import('../../app/controllers/auth/sign_out_controller.ts'))['default']
>
export type V1AuthSignInRoute = InferController<
  (typeof import('../../app/controllers/auth/sign_in_controller.ts'))['default']
>
export type V1AuthSignUpRoute = InferController<
  (typeof import('../../app/controllers/auth/sign_up_controller.ts'))['default']
>
export type V1AuthVerifyRoute = InferController<
  (typeof import('../../app/controllers/auth/verify_controller.ts'))['default']
>
export type V1AuthPasswordUpdateRoute = InferController<
  (typeof import('../../app/controllers/auth/password/update_controller.ts'))['default']
>
export type V1AuthProfileUpdateRoute = InferController<
  (typeof import('../../app/controllers/auth/profile/update_controller.ts'))['default']
>
export type V1NoteListRoute = InferController<
  (typeof import('../../app/controllers/note/list_controller.ts'))['default']
>
export type V1NoteShowRoute = InferController<
  (typeof import('../../app/controllers/note/show_controller.ts'))['default']
>
export type V1NoteCreateRoute = InferController<
  (typeof import('../../app/controllers/note/create_controller.ts'))['default']
>
export type V1NoteUpdateRoute = InferController<
  (typeof import('../../app/controllers/note/update_controller.ts'))['default']
>
export type V1NoteDeleteRoute = InferController<
  (typeof import('../../app/controllers/note/delete_controller.ts'))['default']
>
export type V1NoteTagUpdateRoute = InferController<
  (typeof import('../../app/controllers/note/tag/update_controller.ts'))['default']
>
export type V1TagListRoute = InferController<
  (typeof import('../../app/controllers/tag/list_controller.ts'))['default']
>
export type V1TagShowRoute = InferController<
  (typeof import('../../app/controllers/tag/show_controller.ts'))['default']
>
export type V1TagCreateRoute = InferController<
  (typeof import('../../app/controllers/tag/create_controller.ts'))['default']
>
export type V1TagUpdateRoute = InferController<
  (typeof import('../../app/controllers/tag/update_controller.ts'))['default']
>
export type V1TagDeleteRoute = InferController<
  (typeof import('../../app/controllers/tag/delete_controller.ts'))['default']
>
export type V1PingRoute = InferController<
  (typeof import('../../app/controllers/ping_controller.ts'))['default']
>

export const endpoints = {
  V1_AUTH_SESSION: endpoint<V1AuthSessionRoute>({
    form: false,
    url: '/api/v1/auth/session',
    method: 'GET',
  }),
  V1_AUTH_SIGN_OUT: endpoint<V1AuthSignOutRoute>({
    form: false,
    url: '/api/v1/auth/sign-out',
    method: 'POST',
  }),
  V1_AUTH_SIGN_IN: endpoint<V1AuthSignInRoute>({
    form: false,
    url: '/api/v1/auth/sign-in',
    method: 'POST',
  }),
  V1_AUTH_SIGN_UP: endpoint<V1AuthSignUpRoute>({
    form: false,
    url: '/api/v1/auth/sign-up',
    method: 'POST',
  }),
  V1_AUTH_VERIFY: endpoint<V1AuthVerifyRoute>({
    form: false,
    url: '/api/v1/auth/verify',
    method: 'POST',
  }),
  V1_AUTH_PASSWORD_UPDATE: endpoint<V1AuthPasswordUpdateRoute>({
    form: false,
    url: '/api/v1/auth/password',
    method: 'PUT',
  }),
  V1_AUTH_PROFILE_UPDATE: endpoint<V1AuthProfileUpdateRoute>({
    form: false,
    url: '/api/v1/auth/profile',
    method: 'PUT',
  }),
  V1_NOTE_LIST: endpoint<V1NoteListRoute>({ form: false, url: '/api/v1/note', method: 'GET' }),
  V1_NOTE_SHOW: endpoint<V1NoteShowRoute>({
    form: false,
    url: '/api/v1/note/{{ noteId }}',
    method: 'GET',
  }),
  V1_NOTE_CREATE: endpoint<V1NoteCreateRoute>({ form: false, url: '/api/v1/note', method: 'POST' }),
  V1_NOTE_UPDATE: endpoint<V1NoteUpdateRoute>({
    form: false,
    url: '/api/v1/note/{{ noteId }}',
    method: 'PUT',
  }),
  V1_NOTE_DELETE: endpoint<V1NoteDeleteRoute>({
    form: false,
    url: '/api/v1/note/{{ noteId }}',
    method: 'DELETE',
  }),
  V1_NOTE_TAG_UPDATE: endpoint<V1NoteTagUpdateRoute>({
    form: false,
    url: '/api/v1/note/tag/{{ noteId }}',
    method: 'PUT',
  }),
  V1_TAG_LIST: endpoint<V1TagListRoute>({ form: false, url: '/api/v1/tag', method: 'GET' }),
  V1_TAG_SHOW: endpoint<V1TagShowRoute>({
    form: false,
    url: '/api/v1/tag/{{ tagId }}',
    method: 'GET',
  }),
  V1_TAG_CREATE: endpoint<V1TagCreateRoute>({ form: false, url: '/api/v1/tag', method: 'POST' }),
  V1_TAG_UPDATE: endpoint<V1TagUpdateRoute>({
    form: false,
    url: '/api/v1/tag/{{ tagId }}',
    method: 'PUT',
  }),
  V1_TAG_DELETE: endpoint<V1TagDeleteRoute>({
    form: false,
    url: '/api/v1/tag/{{ tagId }}',
    method: 'DELETE',
  }),
  V1_PING: endpoint<V1PingRoute>({ form: false, url: '/api/v1/ping', method: 'GET' }),
} as const

```
-------------------------------
[playground/backend/blueprint/reference.ts]

```ts
/// <reference path="../adonisrc.ts" />

/* Add the required types here */

```
-------------------------------
[playground/backend/commands/playground.ts]

```ts
import { BaseCommand } from '@adonisjs/core/ace'
import type { CommandOptions } from '@adonisjs/core/types/ace'
import mail from '@adonisjs/mail/services/main'

export default class Playground extends BaseCommand {
  static commandName = 'playground'
  static description = 'Playground for your application'

  static options: CommandOptions = {
    startApp: true,
  }

  async run() {
    this.logger.info('Welcome to playground!')

    await mail.send((message) => {
      message.subject('Test mail')
      message.to('servicexskull@gmail.com')
      message.text('Test mail')
    })
  }
}

```
-------------------------------
[playground/backend/config/app.ts]

```ts
import env from '#start/env'
import app from '@adonisjs/core/services/app'
import { Secret } from '@adonisjs/core/helpers'
import { defineConfig } from '@adonisjs/core/http'

/**
 * The app key is used for encrypting cookies, generating signed URLs,
 * and by the "encryption" module.
 *
 * The encryption module will fail to decrypt data if the key is lost or
 * changed. Therefore it is recommended to keep the app key secure.
 */
export const appKey = new Secret(env.get('APP_KEY'))

/**
 * The configuration settings used by the HTTP server
 */
export const http = defineConfig({
  generateRequestId: true,
  allowMethodSpoofing: false,

  /**
   * Enabling async local storage will let you access HTTP context
   * from anywhere inside your application.
   */
  useAsyncLocalStorage: false,

  /**
   * Manage cookies configuration. The settings for the session id cookie are
   * defined inside the "config/session.ts" file.
   */
  cookie: {
    domain: '',
    path: '/',
    maxAge: '2h',
    httpOnly: true,
    secure: app.inProduction,
    sameSite: 'lax',
  },
})

```
-------------------------------
[playground/backend/config/blueprint.ts]

```ts
import { defineConfig } from '@folie/blueprint'

const config = defineConfig({
  groups: {
    api: /^\/api\//,
  },
  key: (k) => k.replace(/^\sapi\s+/, ''),
})

export default config

```
-------------------------------
[playground/backend/config/bodyparser.ts]

```ts
import { defineConfig } from '@adonisjs/core/bodyparser'

const bodyParserConfig = defineConfig({
  /**
   * The bodyparser middleware will parse the request body
   * for the following HTTP methods.
   */
  allowedMethods: ['POST', 'PUT', 'PATCH', 'DELETE'],

  /**
   * Config for the "application/x-www-form-urlencoded"
   * content-type parser
   */
  form: {
    convertEmptyStringsToNull: true,
    types: ['application/x-www-form-urlencoded'],
  },

  /**
   * Config for the JSON parser
   */
  json: {
    convertEmptyStringsToNull: true,
    types: ['application/json', 'application/vnd.api+json'],
  },

  /**
   * Config for the "multipart/form-data" content-type parser.
   * File uploads are handled by the multipart parser.
   */
  multipart: {
    /**
     * Enabling auto process allows bodyparser middleware to
     * move all uploaded files inside the tmp folder of your
     * operating system
     */
    autoProcess: true,
    convertEmptyStringsToNull: true,
    processManually: [],

    /**
     * Maximum limit of data to parse including all files
     * and fields
     */
    limit: '5mb',
    types: ['multipart/form-data'],
  },
})

export default bodyParserConfig

```
-------------------------------
[playground/backend/config/cache.ts]

```ts
import { defineConfig, store, drivers } from '@adonisjs/cache'
import { superjson } from '@folie/castle/miscellaneous/super_json'

const cacheConfig = defineConfig({
  default: 'default',

  stores: {
    default: store().useL1Layer(drivers.memory()),
  },

  serializer: {
    deserialize: superjson.parse,
    serialize: superjson.stringify,
  },
})

export default cacheConfig

declare module '@adonisjs/cache/types' {
  interface CacheStores extends InferStores<typeof cacheConfig> {}
}

```
-------------------------------
[playground/backend/config/captcha.ts]

```ts
import env from '#start/env'
import { CaptchaManager } from '@folie/captcha'
import { TurnstileDriver } from '@folie/captcha/drivers'

export const captcha = new CaptchaManager({
  drivers: {
    default: new TurnstileDriver({
      privateKey: env.get('CAPTCHA_PRIVATE_KEY'),
    }),
  },
  defaultDriver: 'default',
})

```
-------------------------------
[playground/backend/config/castle.ts]

```ts
import { CastleModule } from '@folie/castle'

export const castle = new CastleModule({
  config: {
    table: {
      user: 'users',
      session: 'sessions',
      note: 'notes',
      tag: 'tags',
      noteTags: 'note_tags',
    },
    pivot: {
      noteTags: {
        pivotTable: (t) => t.noteTags(),
      },
    },
  },
})

```
-------------------------------
[playground/backend/config/cors.ts]

```ts
import { defineConfig } from '@adonisjs/cors'

/**
 * Configuration options to tweak the CORS policy. The following
 * options are documented on the official documentation website.
 *
 * https://docs.adonisjs.com/guides/security/cors
 */
const corsConfig = defineConfig({
  enabled: true,
  origin: true,
  methods: ['GET', 'HEAD', 'POST', 'PUT', 'DELETE'],
  headers: true,
  exposeHeaders: [],
  credentials: true,
  maxAge: 90,
})

export default corsConfig

```
-------------------------------
[playground/backend/config/database.ts]

```ts
import env from '#start/env'
import app from '@adonisjs/core/services/app'
import { defineConfig } from '@adonisjs/lucid'

const dbConfig = defineConfig({
  connection: env.get('DB_TYPE'),
  connections: {
    sqlite: {
      client: 'better-sqlite3',
      connection: {
        filename: app.tmpPath(`${env.get('NODE_ENV')}_db.sqlite3`),
      },
      useNullAsDefault: true,
      migrations: {
        naturalSort: true,
        paths: ['database/migrations'],
      },
    },

    mysql: {
      client: 'mysql2',
      connection: {
        host: env.get('DB_HOST'),
        port: env.get('DB_PORT'),
        user: env.get('DB_USER'),
        password: env.get('DB_PASSWORD'),
        database: 'production',
        ssl: env.get('DB_SSL') === false ? undefined : {},
      },
      migrations: {
        naturalSort: true,
        paths: ['database/migrations'],
        disableRollbacksInProduction: true,
      },
    },
  },
})

export default dbConfig

```
-------------------------------
[playground/backend/config/hash.ts]

```ts
import { defineConfig, drivers } from '@adonisjs/core/hash'

const hashConfig = defineConfig({
  default: 'scrypt',

  list: {
    scrypt: drivers.scrypt({
      cost: 16384,
      blockSize: 8,
      parallelization: 1,
      maxMemory: 33554432,
    }),
  },
})

export default hashConfig

/**
 * Inferring types for the list of hasher you have configured
 * in your application.
 */
declare module '@adonisjs/core/types' {
  export interface HashersList extends InferHashers<typeof hashConfig> {}
}

```
-------------------------------
[playground/backend/config/limiter.ts]

```ts
import env from '#start/env'
import { defineConfig, stores } from '@adonisjs/limiter'

const limiterConfig = defineConfig({
  default: env.get('LIMITER_STORE'),
  stores: {
    /**
     * Database store to save rate limiting data inside a
     * MYSQL or PostgreSQL database.
     */
    database: stores.database({
      tableName: 'rate_limits',
    }),

    /**
     * Memory store could be used during
     * testing
     */
    memory: stores.memory({}),
  },
})

export default limiterConfig

declare module '@adonisjs/limiter/types' {
  export interface LimitersList extends InferLimiters<typeof limiterConfig> {}
}

```
-------------------------------
[playground/backend/config/logger.ts]

```ts
import env from '#start/env'
import app from '@adonisjs/core/services/app'
import { defineConfig, targets } from '@adonisjs/core/logger'

const loggerConfig = defineConfig({
  default: 'app',

  /**
   * The loggers object can be used to define multiple loggers.
   * By default, we configure only one logger (named "app").
   */
  loggers: {
    app: {
      enabled: true,
      name: env.get('APP_NAME'),
      level: env.get('LOG_LEVEL'),
      transport: {
        targets: targets()
          .pushIf(!app.inProduction, targets.pretty())
          .pushIf(app.inProduction, targets.file({ destination: 1 }))
          .toArray(),
      },
    },
  },
})

export default loggerConfig

/**
 * Inferring types for the list of loggers you have configured
 * in your application.
 */
declare module '@adonisjs/core/types' {
  export interface LoggersList extends InferLoggers<typeof loggerConfig> {}
}

```
-------------------------------
[playground/backend/config/mail.ts]

```ts
import env from '#start/env'
import { defineConfig, transports } from '@adonisjs/mail'

const mailConfig = defineConfig({
  default: 'smtp',

  from: 'blackbox@mail.mohitxskull.com',

  /**
   * The mailers object can be used to configure multiple mailers
   * each using a different transport or same transport with different
   * options.
   */
  mailers: {
    smtp: transports.smtp({
      host: env.get('SMTP_HOST'),
      port: env.get('SMTP_PORT'),

      auth: {
        type: 'login',
        user: env.get('SMTP_USERNAME'),
        pass: env.get('SMTP_PASSWORD'),
      },

      tls: {},
    }),
  },
})

export default mailConfig

declare module '@adonisjs/mail/types' {
  export interface MailersList extends InferMailers<typeof mailConfig> {}
}

```
-------------------------------
[playground/backend/config/setting.ts]

```ts
import string from '@adonisjs/core/helpers/string'

export const setting = {
  signUp: {
    enabled: true,
    verification: {
      enabled: true,
      expiresIn: string.milliseconds.parse('1 hour')!,
      purpose: 'email_verification',
    },
  },

  signIn: {
    enabled: true,
  },

  passwordRequirement: {
    crackTime: string.seconds.parse('1 year')!,
    score: 3,
    size: {
      min: 8,
      max: 32,
    },
  },

  notes: {
    perUser: 20,
  },
  tags: {
    perUser: 10,
    perNote: 5,
  },
}

```
-------------------------------
[playground/backend/config/squid.ts]

```ts
import env from '#start/env'
import { SquidModule } from '@folie/squid'

const squidModule = new SquidModule(env.get('SQUID_KEY'))

export const squid = squidModule.group({
  user: {
    prefixBase: 'usr',
  },
  session: {
    prefixBase: 'ses',
  },
  note: {
    prefixBase: 'not',
  },
  tag: {
    prefixBase: 'tag',
  },
})

```
-------------------------------
[playground/backend/config/zxcvbn.ts]

```ts
import { zxcvbn, zxcvbnOptions } from '@zxcvbn-ts/core'
import * as zxcvbnCommonPackage from '@zxcvbn-ts/language-common'
import * as zxcvbnEnPackage from '@zxcvbn-ts/language-en'

const zxcvbnConfig = {
  translations: zxcvbnEnPackage.translations,
  graphs: zxcvbnCommonPackage.adjacencyGraphs,
  dictionary: {
    ...zxcvbnCommonPackage.dictionary,
    ...zxcvbnEnPackage.dictionary,
  },
}

zxcvbnOptions.setOptions(zxcvbnConfig)

export { zxcvbn }

```
-------------------------------
[playground/backend/database/migrations/1734163381129_create_users_table.ts]

```ts
import { castle } from '#config/castle'
import { BaseSchema } from '@adonisjs/lucid/schema'

export default class extends BaseSchema {
  protected tableName = castle.table.user()

  async up() {
    this.schema.createTable(this.tableName, (t) => {
      t.increments('id')

      t.string('first_name', 255).nullable()
      t.string('last_name', 255).nullable()

      t.string('email', 200).notNullable().unique()

      t.text('password').notNullable()

      t.timestamp('created_at')
      t.timestamp('updated_at')
      t.timestamp('verified_at').nullable()
    })
  }

  async down() {
    this.schema.dropTable(this.tableName)
  }
}

```
-------------------------------
[playground/backend/database/migrations/1734165204861_create_sessions_table.ts]

```ts
import { castle } from '#config/castle'
import { BaseSchema } from '@adonisjs/lucid/schema'

export default class extends BaseSchema {
  protected tableName = castle.table.session()

  async up() {
    this.schema.createTable(this.tableName, (t) => {
      t.increments('id')

      t.string('hash').notNullable()

      t.integer('user_id')
        .unsigned()
        .references(castle.table.user('id'))
        .notNullable()
        .onDelete('CASCADE')

      t.timestamp('created_at')
      t.timestamp('updated_at')
      t.timestamp('expires_at').nullable()
      t.timestamp('used_at').nullable()
    })
  }

  async down() {
    this.schema.dropTable(this.tableName)
  }
}

```
-------------------------------
[playground/backend/database/migrations/1740458814595_create_notes_table.ts]

```ts
import { castle } from '#config/castle'
import { BaseSchema } from '@adonisjs/lucid/schema'

export default class extends BaseSchema {
  protected tableName = castle.table.note()

  async up() {
    this.schema.createTable(this.tableName, (t) => {
      t.increments('id')

      t.integer('user_id')
        .unsigned()
        .references(castle.table.user('id'))
        .notNullable()
        .onDelete('CASCADE')

      t.string('title').notNullable()

      t.text('body').notNullable()

      t.timestamp('created_at')
      t.timestamp('updated_at')
    })
  }

  async down() {
    this.schema.dropTable(this.tableName)
  }
}

```
-------------------------------
[playground/backend/database/migrations/1740491631067_create_rate_limits_table.ts]

```ts
import { BaseSchema } from '@adonisjs/lucid/schema'

export default class extends BaseSchema {
  protected tableName = 'rate_limits'

  async up() {
    this.schema.createTable(this.tableName, (table) => {
      table.string('key', 255).notNullable().primary()
      table.integer('points', 9).notNullable().defaultTo(0)
      table.bigint('expire').unsigned()
    })
  }

  async down() {
    this.schema.dropTable(this.tableName)
  }
}

```
-------------------------------
[playground/backend/database/migrations/1742032538631_create_tags_table.ts]

```ts
import { castle } from '#config/castle'
import { BaseSchema } from '@adonisjs/lucid/schema'

export default class extends BaseSchema {
  protected tableName = castle.table.tag()

  async up() {
    this.schema.createTable(this.tableName, (t) => {
      t.increments('id')

      t.integer('user_id')
        .unsigned()
        .references(castle.table.user('id'))
        .notNullable()
        .onDelete('CASCADE')

      t.string('slug').notNullable()

      t.string('name').notNullable()

      t.string('description').nullable()

      t.unique(['user_id', 'slug'])

      t.timestamp('created_at')
      t.timestamp('updated_at')
    })
  }

  async down() {
    this.schema.dropTable(this.tableName)
  }
}

```
-------------------------------
[playground/backend/database/migrations/1742032741448_create_note_tags_table.ts]

```ts
import { castle } from '#config/castle'
import { BaseSchema } from '@adonisjs/lucid/schema'

export default class extends BaseSchema {
  protected tableName = castle.table.noteTags()

  async up() {
    this.schema.createTable(this.tableName, (t) => {
      t.increments('id')

      t.integer('note_id')
        .unsigned()
        .references(castle.table.note('id'))
        .notNullable()
        .onDelete('CASCADE')

      t.integer('tag_id')
        .unsigned()
        .references(castle.table.tag('id'))
        .notNullable()
        .onDelete('CASCADE')

      t.unique(['note_id', 'tag_id'])

      t.timestamp('created_at')
      t.timestamp('updated_at')
    })
  }

  async down() {
    this.schema.dropTable(this.tableName)
  }
}

```
-------------------------------
[playground/backend/package.json]

```json
{
  "name": "@folie/playground-backend",
  "version": "0.0.1",
  "private": true,
  "type": "module",
  "license": "UNLICENSED",
  "exports": {
    "./blueprint": "./blueprint/api/schema.ts"
  },
  "scripts": {
    "start": "node bin/server.js",
    "build": "node ace build",
    "dev": "node ace serve --hmr",
    "test": "node ace test",
    "lint": "eslint .",
    "ace": "node ace",
    "check": "nr typecheck && nr lint",
    "typecheck": "tsc --noEmit",
    "format": "prettier --write \"**/*.{ts,tsx,md,json}\""
  },
  "imports": {
    "#controllers/*": "./app/controllers/*.js",
    "#exceptions/*": "./app/exceptions/*.js",
    "#models/*": "./app/models/*.js",
    "#mails/*": "./app/mails/*.js",
    "#services/*": "./app/services/*.js",
    "#listeners/*": "./app/listeners/*.js",
    "#events/*": "./app/events/*.js",
    "#middleware/*": "./app/middleware/*.js",
    "#validators/*": "./app/validators/*.js",
    "#providers/*": "./providers/*.js",
    "#policies/*": "./app/policies/*.js",
    "#abilities/*": "./app/abilities/*.js",
    "#database/*": "./database/*.js",
    "#start/*": "./start/*.js",
    "#tests/*": "./tests/*.js",
    "#config/*": "./config/*.js",
    "#miscellaneous/*": "./app/miscellaneous/*.js",
    "#types/*": "./types/*.js",
    "#helpers/*": "./app/helpers/*.js"
  },
  "devDependencies": {
    "@adonisjs/assembler": "^7.8.2",
    "@adonisjs/eslint-config": "^2.0.0-beta.6",
    "@adonisjs/prettier-config": "^1.4.0",
    "@adonisjs/tsconfig": "^1.4.0",
    "@japa/api-client": "^2.0.3",
    "@japa/assert": "^3.0.0",
    "@japa/plugin-adonisjs": "^3.0.1",
    "@japa/runner": "^3.1.4",
    "@swc/core": "1.7.26",
    "@types/luxon": "^3.4.2",
    "@types/node": "^22.7.5",
    "eslint": "^9.12.0",
    "hot-hook": "^0.3.1",
    "pino-pretty": "^11.2.2",
    "prettier": "^3.3.3",
    "ts-node-maintained": "^10.9.4",
    "typescript": "~5.6"
  },
  "dependencies": {
    "@adonisjs/bouncer": "^3.1.4",
    "@adonisjs/cache": "^1.1.0",
    "@adonisjs/core": "^6.14.1",
    "@adonisjs/cors": "^2.2.1",
    "@adonisjs/drive": "^3.2.0",
    "@adonisjs/limiter": "^2.3.3",
    "@adonisjs/lucid": "^21.3.0",
    "@adonisjs/mail": "^9.2.2",
    "@folie/blueprint": "workspace:*",
    "@folie/blueprint-lib": "workspace:*",
    "@folie/castle": "workspace:*",
    "@folie/captcha": "workspace:*",
    "@folie/gate": "workspace:*",
    "@folie/lib": "workspace:*",
    "@folie/squid": "workspace:*",
    "@vinejs/vine": "^3.0.0",
    "@zxcvbn-ts/core": "^3.0.4",
    "@zxcvbn-ts/language-common": "^3.0.4",
    "@zxcvbn-ts/language-en": "^3.0.2",
    "better-sqlite3": "^11.6.0",
    "edge.js": "^6.2.0",
    "luxon": "^3.5.0",
    "mysql2": "^3.12.0",
    "reflect-metadata": "^0.2.2",
    "zod": "^3.24.1"
  },
  "hotHook": {
    "boundaries": [
      "./app/controllers/**/*.ts",
      "./app/middleware/*.ts"
    ]
  },
  "overrides": {
    "strtok3": "8.0.1"
  },
  "prettier": "@adonisjs/prettier-config"
}

```
-------------------------------
[playground/backend/providers/boot_provider.ts]

```ts
import type { ApplicationService } from '@adonisjs/core/types'
import { boot } from '../app/boot.js'

export default class BootProvider {
  constructor(protected app: ApplicationService) {}

  /**
   * Register bindings to the container
   */
  register() {}

  /**
   * The container bindings have booted
   */
  async boot() {}

  /**
   * The application has been booted
   */
  async start() {}

  /**
   * The process has been started
   */
  async ready() {
    if (['web'].includes(this.app.getEnvironment())) {
      await boot()
    }
  }

  /**
   * Preparing to shutdown the app
   */
  async shutdown() {}
}

```
-------------------------------
[playground/backend/resources/views/emails/email_verification.edge]

```edge
<p>
  Link for verifying your email: {{ url }}
</p>

<p>
  Please note that the token is valid for only one hour.
</p>

```
-------------------------------
[playground/backend/start/env.ts]

```ts
/*
|--------------------------------------------------------------------------
| Environment variables service
|--------------------------------------------------------------------------
|
| The `Env.create` method creates an instance of the Env service. The
| service validates the environment variables and also cast values
| to JavaScript data types.
|
*/

import { Env } from '@adonisjs/core/env'

export default await Env.create(new URL('../', import.meta.url), {
  TZ: Env.schema.string(),
  NODE_ENV: Env.schema.enum(['development', 'production', 'test'] as const),
  PORT: Env.schema.number(),
  APP_KEY: Env.schema.string(),
  APP_URL: Env.schema.string(),
  HOST: Env.schema.string({ format: 'host' }),
  LOG_LEVEL: Env.schema.enum(['fatal', 'error', 'warn', 'info', 'debug', 'trace']),
  REPORT_ERRORS: Env.schema.boolean.optional(),

  /*
  |----------------------------------------------------------
  | Variables for configuring squid package
  |----------------------------------------------------------
  */
  SQUID_KEY: Env.schema.string(),

  /*
  |----------------------------------------------------------
  | Variables for configuring database connection
  |----------------------------------------------------------
  */
  DB_TYPE: Env.schema.enum(['mysql', 'sqlite'] as const),
  DB_HOST: Env.schema.string({ format: 'host' }),
  DB_PORT: Env.schema.number(),
  DB_USER: Env.schema.string(),
  DB_PASSWORD: Env.schema.string.optional(),
  DB_SSL: Env.schema.boolean.optional(),

  /*
  |----------------------------------------------------------
  | Variables for configuring the limiter package
  |----------------------------------------------------------
  */
  LIMITER_STORE: Env.schema.enum(['database', 'memory'] as const),

  /*
  |----------------------------------------------------------
  | Variables for configuring the captcha package
  |----------------------------------------------------------
  */
  CAPTCHA_PUBLIC_KEY: Env.schema.string(),
  CAPTCHA_PRIVATE_KEY: Env.schema.string(),

  /*
  |----------------------------------------------------------
  | Variables for configuring the mail package
  |----------------------------------------------------------
  */
  SMTP_HOST: Env.schema.string(),
  SMTP_PORT: Env.schema.string(),
  SMTP_USERNAME: Env.schema.string(),
  SMTP_PASSWORD: Env.schema.string(),
})

```
-------------------------------
[playground/backend/start/kernel.ts]

```ts
/*
|--------------------------------------------------------------------------
| HTTP kernel file
|--------------------------------------------------------------------------
|
| The HTTP kernel file is used to register the middleware with the server
| or the router.
|
*/

import router from '@adonisjs/core/services/router'
import server from '@adonisjs/core/services/server'

/**
 * The error handler is used to convert an exception
 * to a HTTP response.
 */
server.errorHandler(() => import('#exceptions/handler'))

/**
 * The server middleware stack runs middleware on all the HTTP
 * requests, even if there is no route registered for
 * the request URL.
 */
server.use([
  () => import('#middleware/container_bindings_middleware'),
  () => import('@folie/castle/middleware/force_json_response_middleware'),
  () => import('@adonisjs/cors/cors_middleware'),
])

/**
 * The router middleware stack runs middleware on all the HTTP
 * requests with a registered route.
 */
router.use([
  () => import('@adonisjs/core/bodyparser_middleware'),
  () => import('#middleware/initialize_bouncer_middleware'),
])

/**
 * Named middleware collection must be explicitly assigned to
 * the routes or the routes group.
 */
export const middleware = router.named({
  captcha: () => import('#middleware/captcha_middleware'),
  auth: () => import('#middleware/auth_middleware'),
})

```
-------------------------------
[playground/backend/start/limiter.ts]

```ts
// @ts-nocheck

/*
|--------------------------------------------------------------------------
| Define HTTP limiters
|--------------------------------------------------------------------------
|
| The "limiter.define" method creates an HTTP middleware to apply rate
| limits on a route or a group of routes. Feel free to define as many
| throttle middleware as needed.
|
*/

import limiter from '@adonisjs/limiter/services/main'

export const throttle = limiter.define('global', () => {
  return limiter.allowRequests(60).every('1 minute')
})

export const signUpThrottle = limiter.define('sign-up', (ctx) => {
  return limiter.allowRequests(20).every('1 hour').usingKey(`sign_up_${ctx.request.ip()}`)
})

export const signInThrottle = limiter.define('sign-in', (ctx) => {
  return limiter.allowRequests(5).every('1 hour').usingKey(`sign_in_${ctx.request.ip()}`)
})

```
-------------------------------
[playground/backend/tests/bootstrap.ts]

```ts
import { assert } from '@japa/assert'
import app from '@adonisjs/core/services/app'
import type { Config } from '@japa/runner/types'
import { pluginAdonisJS } from '@japa/plugin-adonisjs'
import testUtils from '@adonisjs/core/services/test_utils'
import { boot } from '../app/boot.js'
import { TestContext } from '@japa/runner/core'
import { TestResources, testResources } from './resources.js'

/**
 * This file is imported by the "bin/test.ts" entrypoint file
 */

/**
 * Configure Japa plugins in the plugins array.
 * Learn more - https://japa.dev/docs/runner-config#plugins-optional
 */
export const plugins: Config['plugins'] = [
  assert(),

  pluginAdonisJS(app),
  // expectTypeOf(),

  () => {
    TestContext.getter(
      'resource',
      function (this: TestContext) {
        return testResources
      },
      true
    )
  },
]

declare module '@japa/runner/core' {
  interface TestContext {
    resource: TestResources
  }
}

/**
 * Configure lifecycle function to run before and after all the
 * tests.
 *
 * The setup functions are executed before all the tests
 * The teardown functions are executed after all the tests
 */
export const runnerHooks: Required<Pick<Config, 'setup' | 'teardown'>> = {
  setup: [
    () => testUtils.db().truncate(),
    () => testUtils.db().seed(),
    async () => {
      await boot()
    },
  ],
  teardown: [],
}

/**
 * Configure suites by tapping into the test suite instance.
 * Learn more - https://japa.dev/docs/test-suites#lifecycle-hooks
 */
export const configureSuite: Config['configureSuite'] = (suite) => {
  if (['browser', 'functional', 'e2e'].includes(suite.name)) {
    return suite.setup(() => testUtils.httpServer().start())
  }
}

```
-------------------------------
[playground/backend/tests/functional/api/v1/auth.spec.ts]

```ts
import { test } from '@japa/runner'

test.group('API V1 Auth', () => {
  test('Sign In', async ({ assert, resource }) => {
    const mna = await resource.getUser()

    const response = await resource.api.endpoint('V1_AUTH_SIGN_IN').call({
      email: mna.user.email,
      password: resource.password,
    })

    assert.exists(response.token)
    assert.isString(response.token)
  })

  test('Session', async ({ assert, resource }) => {
    const cus = await resource.getUser({
      email: 'session-user@gmail.com',
    })

    const response = await cus.api.endpoint('V1_AUTH_SESSION').call(undefined)

    assert.equal(response.session.email, cus.user.email)
  })

  test('Profile Update', async ({ assert, resource }) => {
    const mna = await resource.getUser({
      email: 'session-user@gmail.com',
    })

    const updatedManagement = resource.info({
      email: mna.user.email,
      firstName: 'Updated',
      lastName: 'Management',
    })

    const response = await mna.api.endpoint('V1_AUTH_PROFILE_UPDATE').call({
      firstName: updatedManagement.firstName,
      lastName: updatedManagement.lastName,
    })

    assert.equal(response.user.firstName, updatedManagement.firstName)
    assert.equal(response.user.lastName, updatedManagement.lastName)
  })

  test('Password Update', async ({ assert, resource }) => {
    const mna = await resource.getUser({
      email: 'session-user@gmail.com',
    })

    const newPassword = 'sick123$'

    await resource.catch(
      mna.api.endpoint('V1_AUTH_PASSWORD_UPDATE').call({
        oldPassword: resource.password,
        newPassword,
      })
    )

    const signInAttempt = await resource.catch(
      mna.api.endpoint('V1_AUTH_SIGN_IN').call({
        email: mna.user.email,
        password: newPassword,
      })
    )

    assert.exists(signInAttempt.token)
    assert.isString(signInAttempt.token)
  })
})

```
-------------------------------
[playground/backend/tests/resources.ts]

```ts
import { endpoints } from '../blueprint/api/schema.js'
import env from '#start/env'
import { Gate, GateError } from '@folie/gate'
import User from '#models/user'
import { inspectLog } from '@folie/castle/helpers'

export class TestResources {
  baseURL = new URL(`http://${env.get('HOST')}:${env.get('PORT')}`)

  endpoints = { ...endpoints }

  api = new Gate({
    baseURL: this.baseURL,
    endpoints: this.endpoints,
  })

  password = 'master'

  info = (params?: { email?: string; firstName?: string; lastName?: string }) => ({
    email: params?.email ?? `auto-user@gmail.com`,
    password: this.password,
    firstName: params?.firstName ?? 'Auto',
    lastName: params?.lastName ?? 'User',
  })

  getUser = async (params?: { email?: string; firstName?: string; lastName?: string }) => {
    const info = this.info({
      email: params?.email,
      firstName: params?.firstName,
      lastName: params?.lastName,
    })

    let user = await User.findBy('email', info.email)

    if (!user) {
      user = await User.create(info)
    }

    const { token } = await this.api.endpoint('V1_AUTH_SIGN_IN').call({
      email: info.email,
      password: this.password,
    })

    if (!user) {
      throw new Error('User not found')
    }

    return {
      user: user,
      api: new Gate({
        baseURL: this.baseURL,
        endpoints: this.endpoints,
        token: token,
      }),
    }
  }

  catch = async <T>(promise: Promise<T>): Promise<T> => {
    try {
      return await promise
    } catch (error) {
      if (error instanceof GateError) {
        inspectLog(error.toJSON())

        throw new Error('Gate Error')
      } else {
        throw error
      }
    }
  }
}

export const testResources = new TestResources()

export type TestManagement = Awaited<ReturnType<typeof testResources.getUser>>

```
-------------------------------
[playground/backend/types/enum.ts]

```ts
// import { XEnum } from '@folie/lib'

/**
 * DON'T EVER CHANGE THIS NUMBERS ELSE YOU WILL BREAK THE DATABASE
 */

```
-------------------------------
[playground/frontend/eslint.config.mjs]

```mjs
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;

```
-------------------------------
[playground/frontend/next-env.d.ts]

```ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.

```
-------------------------------
[playground/frontend/next.config.ts]

```ts
import type { NextConfig } from "next";

import "./src/configs/env";

const nextConfig: NextConfig = {
  reactStrictMode: true,
  transpilePackages: ["@folie/service-formation-backend"],
  webpack: (config) => {
    config.resolve.extensionAlias = {
      ".js": [".ts", ".tsx", ".js", ".jsx"],
      ".mjs": [".mts", ".mjs"],
      ".cjs": [".cts", ".cjs"],
    };
    return config;
  },
};

export default nextConfig;

```
-------------------------------
[playground/frontend/package.json]

```json
{
  "name": "@folie/playground-frontend",
  "version": "0.0.1",
  "description": "",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "typecheck": "tsc --noEmit",
    "format": "prettier --write \"**/*.{ts,tsx,md,json}\"",
    "check": "nr format && nr typecheck && nr lint"
  },
  "dependencies": {
    "@folie/blueprint-lib": "workspace:*",
    "@folie/cobalt": "workspace:*",
    "@folie/cobalt-animation": "workspace:*",
    "@folie/gate": "workspace:*",
    "@folie/gate-next": "workspace:*",
    "@folie/gate-tan": "workspace:*",
    "@folie/lib": "workspace:*",
    "@folie/playground-backend": "workspace:*",
    "@mantine/core": "^7.17.2",
    "@mantine/dates": "^7.17.2",
    "@mantine/form": "^7.17.2",
    "@mantine/hooks": "^7.17.2",
    "@mantine/modals": "^7.17.2",
    "@mantine/notifications": "^7.17.2",
    "@mantine/nprogress": "^7.17.2",
    "@mantine/tiptap": "^7.17.2",
    "@marsidev/react-turnstile": "^1.1.0",
    "@t3-oss/env-nextjs": "^0.11.1",
    "@tabler/icons-react": "^3.29.0",
    "@tanstack/react-query": "^5.52.2",
    "@tiptap/extension-code-block-lowlight": "^2.11.5",
    "@tiptap/extension-highlight": "^2.11.5",
    "@tiptap/extension-link": "^2.11.5",
    "@tiptap/extension-placeholder": "^2.11.5",
    "@tiptap/extension-subscript": "^2.11.5",
    "@tiptap/extension-superscript": "^2.11.5",
    "@tiptap/extension-text-align": "^2.11.5",
    "@tiptap/extension-underline": "^2.11.5",
    "@tiptap/pm": "^2.11.5",
    "@tiptap/react": "^2.11.5",
    "@tiptap/starter-kit": "^2.11.5",
    "boring-avatars": "^1.11.2",
    "case-anything": "^3.1.0",
    "cookies-next": "^5.1.0",
    "dayjs": "^1.11.13",
    "jotai": "^2.12.2",
    "lowlight": "^3.3.0",
    "lz-string": "^1.5.0",
    "next": "15.1.6",
    "next-seo": "^6.6.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.1.6",
    "postcss": "^8.5.1",
    "postcss-preset-mantine": "^1.17.0",
    "postcss-simple-vars": "^7.0.1",
    "typescript": "~5.6"
  }
}

```
-------------------------------
[playground/frontend/postcss.config.cjs]

```cjs
module.exports = {
  plugins: {
    "postcss-preset-mantine": {},
    "postcss-simple-vars": {
      variables: {
        "mantine-breakpoint-xs": "36em",
        "mantine-breakpoint-sm": "48em",
        "mantine-breakpoint-md": "62em",
        "mantine-breakpoint-lg": "75em",
        "mantine-breakpoint-xl": "88em",
      },
    },
  },
};

```
-------------------------------
[playground/frontend/src/components/boring_avatar.tsx]

```tsx
import { Avatar, AvatarProps } from "@mantine/core";
import BoringAvatar from "boring-avatars";

type Props = AvatarProps & {
  seed: string;
};

export const LocalBoringAvatar = (props: Props) => {
  const { seed, ...rest } = props;

  return (
    <>
      <Avatar radius="md" {...rest}>
        <BoringAvatar
          name={seed}
          square
          variant="beam"
          colors={["#141414", "#c9c9c9"]}
        />
      </Avatar>
    </>
  );
};

```
-------------------------------
[playground/frontend/src/components/dash.tsx]

```tsx
export const IconDash = () => {
  return (
    <>
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="15"
        height="15"
        fill="none"
      >
        <path
          stroke="currentColor"
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="1.5"
          d="M2.5 7.5h10"
        ></path>
      </svg>
    </>
  );
};

```
-------------------------------
[playground/frontend/src/components/disable_tab_index.tsx]

```tsx
import { ReactNode, useEffect, useRef } from "react";

type Props = {
  children: ReactNode;
};

export const DisableTabIndex = (props: Props) => {
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const container = containerRef.current;
    if (container) {
      const elements = container.querySelectorAll("[tabindex]");
      elements.forEach((element) => {
        element.setAttribute("tabindex", "-1");
      });

      const observer = new MutationObserver((mutationsList) => {
        for (const mutation of mutationsList) {
          if (mutation.type === "childList") {
            mutation.addedNodes.forEach((node) => {
              if (node instanceof Element) {
                const elementsWithTabIndex =
                  node.querySelectorAll("[tabindex]");
                elementsWithTabIndex.forEach((el) => {
                  el.setAttribute("tabindex", "-1");
                });
                if (node.hasAttribute("tabindex")) {
                  node.setAttribute("tabindex", "-1");
                }
              }
            });
          }
        }
      });

      observer.observe(container, { childList: true, subtree: true });

      return () => {
        observer.disconnect();
      };
    }
  }); // Run only once on mount

  return <div ref={containerRef}>{props.children}</div>;
};

```
-------------------------------
[playground/frontend/src/components/logo.tsx]

```tsx
import { setting } from "@/configs/setting";
import { LogoBase, LogoBaseProps } from "@folie/cobalt/components";

export const Logo = (props: LogoBaseProps) => {
  return (
    <>
      <LogoBase {...props}>{setting.app.name}</LogoBase>
    </>
  );
};

```
-------------------------------
[playground/frontend/src/components/navigation_loading.tsx]

```tsx
import { setting } from "@/configs/setting";
import { Breathing } from "@folie/cobalt-animation";
import { NavigationLoadingBase } from "@folie/cobalt/components";
import { Title } from "@mantine/core";

type Props = {
  opened: boolean;
  children: React.ReactNode;
};

export const NavigationLoading = (props: Props) => {
  return (
    <>
      <NavigationLoadingBase
        opened={props.opened}
        bg="var(--mantine-color-dark-9)"
        center={
          <Title>
            <Breathing
              label={setting.app.name}
              staggerDuration={0.1}
              fromFontVariationSettings="'wght' 200, 'slnt' 0"
              toFontVariationSettings="'wght' 800, 'slnt' -10"
            />
          </Title>
        }
      >
        {props.children}
      </NavigationLoadingBase>
    </>
  );
};

```
-------------------------------
[playground/frontend/src/components/pagination_range.tsx]

```tsx
import { Text, TextProps } from "@mantine/core";

type Props = TextProps & {
  page: number;
  limit: number;
  total: number;
};

export const PaginationRange = (props: Props) => {
  const { page, limit, total, ...rest } = props;

  const start = (page - 1) * limit + 1;
  const end = Math.min(page * limit, total);

  return (
    <Text size="sm" c="dimmed" fw="500" {...rest}>
      {start} to {end} of {total} results
    </Text>
  );
};

```
-------------------------------
[playground/frontend/src/components/query_loader.tsx]

```tsx
import { QueryLoaderProps, QueryLoader } from "@folie/cobalt/components";
import { Alert } from "@mantine/core";

export const LocalQueryLoader = <OUT,>(props: QueryLoaderProps<OUT>) => {
  return (
    <QueryLoader
      isError={
        <Alert color="red.5" variant="light">
          Error
        </Alert>
      }
      {...props}
    />
  );
};

```
-------------------------------
[playground/frontend/src/components/simple_pagination.tsx]

```tsx
import { Group, Text } from "@mantine/core";
import { TextButton } from "./text_button";

type Props = {
  page: number;
  limit: number;
  total: number;
  onChange: (page: number) => void;
};

export const SimplePagination = (props: Props) => {
  const { page, limit, total, onChange } = props;

  return (
    <>
      <Group>
        <Text size="sm" c="dimmed" fw="500">
          {page} of {Math.ceil(total / limit)} pages
        </Text>

        <TextButton
          disabled={page === 1}
          onClick={() => onChange(page - 1)}
          size="sm"
          fw="500"
        >
          Prev
        </TextButton>

        <TextButton
          disabled={page === Math.ceil(total / limit)}
          onClick={() => onChange(page + 1)}
          size="sm"
          fw="500"
        >
          Next
        </TextButton>
      </Group>
    </>
  );
};

```
-------------------------------
[playground/frontend/src/components/text_button.tsx]

```tsx
import { Text, TextProps } from "@mantine/core";

type Props = TextProps & {
  children: React.ReactNode;
  disabled?: boolean;
  onClick?: () => void;
};

export const TextButton = (props: Props) => {
  const { children, disabled, onClick, style, c, ...rest } = props;

  return (
    <>
      <Text
        onClick={onClick}
        c={disabled ? "dimmed" : c}
        style={{
          ...style,
          cursor: disabled ? "auto" : "pointer",
          pointerEvents: disabled ? "none" : "auto",
        }}
        {...rest}
      >
        {children}
      </Text>
    </>
  );
};

```
-------------------------------
[playground/frontend/src/components/ui/notes/lazy_text_editor.tsx]

```tsx
import { Skeleton, Stack } from "@mantine/core";
import dynamic from "next/dynamic";

export const LazyNoteTextEditor = dynamic(
  () => import("./text_editor").then((d) => d.NoteTextEditor),
  {
    loading: () => (
      <>
        <Stack>
          <Skeleton height={40} radius="sm" />

          <Skeleton height={300} radius="sm" />
        </Stack>
      </>
    ),
  },
);

```
-------------------------------
[playground/frontend/src/components/ui/notes/tag/badge.tsx]

```tsx
import { askConfirmation } from "@folie/cobalt/components";
import { V1TagShowRoute } from "@folie/playground-backend/blueprint";
import { Badge, DefaultMantineColor, Tooltip } from "@mantine/core";

type Props = {
  tag: V1TagShowRoute["output"]["tag"];
  remove?: () => void;
  color?: DefaultMantineColor;
};

export const TagBadge = (props: Props) => {
  const { tag } = props;

  return (
    <>
      <Tooltip
        opened={(tag.description?.length ?? 0) > 0 ? undefined : false}
        label={tag.description}
        multiline
        w={220}
        withArrow
      >
        <Badge
          variant="filled"
          color={props.color ?? "dark.8"}
          style={{
            cursor: props.remove ? "pointer" : "default",
          }}
          onClick={
            props.remove
              ? async () => {
                  const confirmation = await askConfirmation({
                    message: `Are you sure you want to remove tag "${tag.name}"?`,
                    labels: {
                      confirm: "Remove",
                    },
                  });

                  if (confirmation) {
                    props.remove?.();
                  }
                }
              : undefined
          }
        >
          {tag.name}
        </Badge>
      </Tooltip>
    </>
  );
};

```
-------------------------------
[playground/frontend/src/components/ui/notes/tag/create_form.tsx]

```tsx
import { gateTan } from "@/configs/gate_tan";
import { RightGroup } from "@folie/cobalt/components";
import { Form } from "@folie/gate-tan/components";
import { Button, Modal, Textarea, TextInput } from "@mantine/core";
import { notifications } from "@mantine/notifications";

type Props = {
  refetch?: () => void;
  opened: boolean;
  close: () => void;
};

export const TagCreateForm = (props: Props) => {
  const { form, mutation, inputProps } = gateTan.useForm({
    endpoint: "V1_TAG_CREATE",
    initialValues: {
      name: "",
      description: "",
    },
    onSuccess: (updatedData) => {
      notifications.show({
        message: updatedData.message,
      });

      props.close();
      props.refetch?.();
      form.reset();
    },
  });

  return (
    <>
      <Modal
        centered
        title="Create New Tag"
        opened={props.opened}
        onClose={() => {
          form.reset();
          props.close();
        }}
      >
        <>
          <Form mutation={mutation} form={form} submit={mutation.mutate}>
            {({ dirty, loading }) => (
              <>
                <TextInput
                  minLength={1}
                  maxLength={20}
                  label="Name"
                  placeholder="Office"
                  required
                  {...inputProps("name")}
                  key={form.key("name")}
                />

                <Textarea
                  minLength={1}
                  maxLength={100}
                  autosize
                  minRows={3}
                  label="Description"
                  placeholder="Description"
                  {...inputProps("description")}
                  key={form.key("description")}
                />

                <RightGroup>
                  <Button type="submit" loading={loading} disabled={!dirty}>
                    Create
                  </Button>
                </RightGroup>
              </>
            )}
          </Form>
        </>
      </Modal>
    </>
  );
};

```
-------------------------------
[playground/frontend/src/components/ui/notes/tag/manage.tsx]

```tsx
import { LocalQueryLoader } from "@/components/query_loader";
import { gateTan } from "@/configs/gate_tan";
import { For, Show } from "@folie/cobalt/components";
import { DotProp } from "@folie/lib";
import {
  ActionIcon,
  AppShellSection,
  Center,
  CloseButton,
  Flex,
  Group,
  Loader,
  Paper,
  Stack,
  Text,
  TextInput,
  Title,
} from "@mantine/core";
import { IconPlus } from "@tabler/icons-react";
import { useState } from "react";
import { TagCreateForm } from "./create_form";
import Link from "next/link";

type Props = {
  state: boolean;
  setState: (value: boolean) => void;
};

export const TagManageAside = (props: Props) => {
  const { body, query, setBody } = gateTan.useList({
    endpoint: "V1_TAG_LIST",
    input: {
      query: {
        page: 1,
        limit: 50,
        order: {
          by: "updatedAt",
          dir: "desc",
        },
        properties: {
          metric: true,
        },
      },
    },
    debounce: {
      timeout: 500,
    },
    enabled: props.state,
  });

  const [tagCreateModalState, setTagCreateModalState] = useState(false);

  return (
    <>
      <TagCreateForm
        opened={tagCreateModalState}
        refetch={query.refetch}
        close={() => setTagCreateModalState(false)}
      />

      <AppShellSection>
        <Group justify="space-between">
          <CloseButton
            variant="transparent"
            onClick={() => props.setState(!props.state)}
          />

          <Title c="white" order={5} fw="600">
            Manage Tags
          </Title>
        </Group>
      </AppShellSection>
      <AppShellSection grow mt="md">
        <Stack h="100%">
          <Flex justify="center" align="center" direction="row" gap="xs">
            <TextInput
              flex={1}
              minLength={1}
              maxLength={100}
              placeholder="Search tags..."
              value={DotProp.lookup(body, "query.filter.value", "")}
              onChange={(e) => {
                const newValue = e.currentTarget.value;

                setBody({
                  query: {
                    ...body.query,
                    filter: newValue !== "" ? { value: newValue } : undefined,
                  },
                });
              }}
            />

            <ActionIcon
              size="sm"
              variant="transparent"
              onClick={() => setTagCreateModalState(true)}
            >
              <IconPlus />
            </ActionIcon>
          </Flex>

          <LocalQueryLoader
            query={query}
            isLoading={
              <>
                <Center h="100%">
                  <Loader />
                </Center>
              </>
            }
          >
            {({ data }) => (
              <>
                <Show>
                  <Show.When isTrue={data.length === 0}>
                    <>
                      <Center h="100%">
                        <Text fs="italic" fw="bold">
                          {(() => {
                            const filterValue = DotProp.lookup(
                              body,
                              "query.filter.value",
                              "",
                            );

                            if (filterValue !== "") {
                              return `No tags found for "${filterValue}"`;
                            } else {
                              return `"No tags found."`;
                            }
                          })()}
                        </Text>
                      </Center>
                    </>
                  </Show.When>

                  <Show.Else>
                    <>
                      <For each={data}>
                        {(tag) => (
                          <>
                            <Paper
                              component={Link}
                              p="md"
                              href={`/app/notes/tags/${tag.id}`}
                              style={{
                                cursor: "pointer",
                              }}
                            >
                              <Group justify="space-between">
                                <Title order={6} flex={1}>
                                  <Text inherit truncate="end" maw="60%">
                                    {tag.name}
                                  </Text>
                                </Title>

                                <Text c="dimmed" size="sm">
                                  {tag.metric?.notes}
                                </Text>
                              </Group>
                            </Paper>
                          </>
                        )}
                      </For>
                    </>
                  </Show.Else>
                </Show>
              </>
            )}
          </LocalQueryLoader>
        </Stack>
      </AppShellSection>
    </>
  );
};

```
-------------------------------
[playground/frontend/src/components/ui/notes/tag/note.tsx]

```tsx
import { LocalQueryLoader } from "@/components/query_loader";
import { gateTan } from "@/configs/gate_tan";
import { ICON_SIZE } from "@folie/cobalt";
import { For } from "@folie/cobalt/components";
import { DotProp } from "@folie/lib";
import { V1NoteShowRoute } from "@folie/playground-backend/blueprint";
import { Badge, Combobox, Group, Text, useCombobox } from "@mantine/core";
import { IconPlus } from "@tabler/icons-react";
import { useMemo } from "react";
import { useDisclosure } from "@mantine/hooks";
import { TagBadge } from "./badge";
import { TagCreateForm } from "./create_form";

type Props = {
  note: V1NoteShowRoute["output"]["note"];
  refetch: () => void;
};

export const NoteTag = (props: Props) => {
  const {
    query: tagQ,
    body: tagBody,
    setBody: setTagBody,
  } = gateTan.useList({
    endpoint: "V1_TAG_LIST",
    input: {
      query: {
        page: 1,
        limit: 50,
        order: {
          by: "name",
          dir: "asc",
        },
      },
    },
  });

  const noteTagQ = gateTan.useQuery({
    endpoint: "V1_TAG_LIST",
    input: {
      query: {
        page: 1,
        limit: 50,
        order: {
          by: "name",
          dir: "asc",
        },
        filter: {
          noteId: props.note.id,
        },
      },
    },
  });

  const tagM = gateTan.useMutation({
    endpoint: "V1_NOTE_TAG_UPDATE",
    onSuccess: () => {
      noteTagQ.refetch();
      props.refetch();
    },
  });

  const combobox = useCombobox({
    onDropdownClose: () => {
      combobox.resetSelectedOption();
      combobox.focusTarget();
      setTagBody({
        query: {
          ...tagBody.query,
          filter: {
            ...tagBody.query?.filter,
            value: undefined,
          },
        },
      });
    },

    onDropdownOpen: () => {
      tagQ.refetch();
      noteTagQ.refetch();
      combobox.focusSearchInput();
    },
  });

  const [tagCreateFormOpened, tagCreateFormHandlers] = useDisclosure(false, {
    onOpen: () => {
      combobox.closeDropdown();
    },
    onClose: () => {
      combobox.openDropdown();
    },
  });

  const options = useMemo(() => {
    if (!noteTagQ.data?.data || !tagQ.data?.data) return [];

    const existingTags = noteTagQ.data.data.map((tag) => tag.id);
    const availableTags = tagQ.data.data.filter(
      (tag) => !existingTags.includes(tag.id),
    );

    return availableTags.map((tag) => (
      <>
        <Combobox.Option value={tag.id} key={tag.id}>
          <Text size="sm">{tag.name}</Text>
        </Combobox.Option>
      </>
    ));
  }, [noteTagQ.data?.data, tagQ.data?.data]);

  return (
    <>
      <TagCreateForm
        refetch={tagQ.refetch}
        opened={tagCreateFormOpened}
        close={tagCreateFormHandlers.close}
      />

      <Group gap="xs">
        <LocalQueryLoader query={noteTagQ}>
          {({ data }) => (
            <>
              <For each={data}>
                {(tag) => (
                  <>
                    <TagBadge
                      tag={tag}
                      remove={() => {
                        tagM.mutate({
                          params: {
                            noteId: props.note.id,
                          },
                          action: "remove",
                          tagId: tag.id,
                        });
                      }}
                    />
                  </>
                )}
              </For>
            </>
          )}
        </LocalQueryLoader>

        <Combobox
          store={combobox}
          width={250}
          position="bottom"
          withArrow
          withinPortal={false}
          positionDependencies={[noteTagQ.data?.data]}
          onOptionSubmit={(tagId) => {
            tagM.mutate({
              params: {
                noteId: props.note.id,
              },
              action: "add",
              tagId,
            });
          }}
        >
          <Combobox.Target>
            <Badge
              variant="filled"
              color="dark.7"
              leftSection={<IconPlus size={ICON_SIZE.XS} />}
              onClick={() => combobox.toggleDropdown()}
              style={{
                cursor: "pointer",
              }}
            >
              Add
            </Badge>
          </Combobox.Target>

          <Combobox.Dropdown>
            <Combobox.Search
              disabled={tagQ.isLoading}
              value={DotProp.lookup(tagBody, "query.filter.value", "")}
              onChange={(event) => {
                const newValue = event.currentTarget.value;

                setTagBody({
                  query: {
                    ...tagBody.query,
                    filter: {
                      ...tagBody.query?.filter,
                      value: newValue.length > 0 ? newValue : undefined,
                    },
                  },
                });
              }}
              placeholder="Search tags"
            />

            <Combobox.Options>
              {options}

              <Combobox.Empty>
                <Text
                  size="sm"
                  fw="500"
                  c="white"
                  style={{ cursor: "pointer" }}
                  onClick={() => {
                    tagCreateFormHandlers.open();
                  }}
                >
                  Create New
                </Text>
              </Combobox.Empty>
            </Combobox.Options>
          </Combobox.Dropdown>
        </Combobox>
      </Group>
    </>
  );
};

```
-------------------------------
[playground/frontend/src/components/ui/notes/tag/update_form.tsx]

```tsx
import { gateTan } from "@/configs/gate_tan";
import { RightGroup } from "@folie/cobalt/components";
import { Form } from "@folie/gate-tan/components";
import { V1TagShowRoute } from "@folie/playground-backend/blueprint";
import { Button, Textarea, TextInput } from "@mantine/core";
import { notifications } from "@mantine/notifications";

type Props = {
  tag: V1TagShowRoute["output"]["tag"];
};

export const TagUpdateForm = (props: Props) => {
  const { form, mutation, inputProps } = gateTan.useForm({
    endpoint: "V1_TAG_UPDATE",
    initialValues: {
      params: {
        tagId: props.tag.id,
      },
      name: props.tag.name,
      description: props.tag.description,
    },
    onSuccess: (updatedData) => {
      notifications.show({
        message: updatedData.message,
      });

      return {
        queryKeys: (qk) => [
          qk("V1_TAG_SHOW", {
            params: {
              tagId: props.tag.id,
            },
          }),
        ],

        input: {
          params: {
            tagId: props.tag.id,
          },
          description: updatedData.tag.description,
          name: updatedData.tag.name,
        },
      };
    },
  });

  return (
    <>
      <Form mutation={mutation} form={form} submit={mutation.mutate}>
        {({ dirty, loading }) => (
          <>
            <TextInput
              minLength={1}
              maxLength={20}
              label="Name"
              placeholder="Office"
              required
              {...inputProps("name")}
              key={form.key("name")}
            />

            <Textarea
              minLength={1}
              maxLength={100}
              autosize
              minRows={3}
              label="Description"
              placeholder="Description"
              {...inputProps("description")}
              key={form.key("description")}
            />

            <RightGroup>
              <Button type="submit" loading={loading} disabled={!dirty}>
                Update
              </Button>
            </RightGroup>
          </>
        )}
      </Form>
    </>
  );
};

```
-------------------------------
[playground/frontend/src/components/ui/notes/text_editor.tsx]

```tsx
import "@mantine/tiptap/styles.css";

import { useUncontrolled } from "@mantine/hooks";
import { useEditor, BubbleMenu } from "@tiptap/react";
import {
  RichTextEditor,
  Link,
  useRichTextEditorContext,
} from "@mantine/tiptap";
import StarterKit from "@tiptap/starter-kit";
import Placeholder from "@tiptap/extension-placeholder";
import Highlight from "@tiptap/extension-highlight";
import Underline from "@tiptap/extension-underline";
import TextAlign from "@tiptap/extension-text-align";
import Superscript from "@tiptap/extension-superscript";
import SubScript from "@tiptap/extension-subscript";
import { Group, InputError, Paper, Stack } from "@mantine/core";
import { DisableTabIndex } from "@/components/disable_tab_index";
import { all, createLowlight } from "lowlight";
import CodeBlockLowlight from "@tiptap/extension-code-block-lowlight";
import { IconCodeDots } from "@tabler/icons-react";

const lowlight = createLowlight(all);

// ============================================

const ToggleCodeBlockControl = () => {
  const { editor } = useRichTextEditorContext();
  return (
    <RichTextEditor.Control
      onClick={() => editor?.chain().focus().toggleCodeBlock().run()}
      aria-label="Insert star emoji"
      title="Insert star emoji"
    >
      <IconCodeDots stroke={1.5} size={16} />
    </RichTextEditor.Control>
  );
};

// ============================================

type Props = {
  value?: string;
  defaultValue?: string;
  onChange?: (value: string) => void;
  disabled?: boolean;
  error?: string;
};

export const NoteTextEditor = (props: Props) => {
  const [_value, handleChange] = useUncontrolled({
    value: props.defaultValue,
    defaultValue: props.defaultValue,
    finalValue: "",
    onChange: props.onChange,
  });

  const editor = useEditor({
    extensions: [
      StarterKit,
      Link,
      Placeholder.configure({
        placeholder: "Start typing your thoughts here...",
      }),
      Underline,
      Superscript,
      SubScript,
      Highlight,
      TextAlign.configure({ types: ["heading", "paragraph"] }),
      CodeBlockLowlight.configure({
        lowlight,
      }),
    ],
    content: _value,
    immediatelyRender: false,
    editable: !props.disabled,
    onUpdate: ({ editor }) => {
      handleChange(editor.getHTML());
    },
  });

  return (
    <>
      <Stack>
        <RichTextEditor
          editor={editor}
          styles={{
            root: {
              border: "none",
            },
            content: {
              background: "transparent",
            },
          }}
        >
          <DisableTabIndex>
            <RichTextEditor.Toolbar
              sticky
              stickyOffset={90}
              style={{
                border: "none",
                borderRadius: "var(--mantine-radius-sm)",
              }}
            >
              <RichTextEditor.ControlsGroup>
                <RichTextEditor.Blockquote />
                <RichTextEditor.Hr />
                <RichTextEditor.BulletList />
                <RichTextEditor.OrderedList />
                <RichTextEditor.Subscript />
                <RichTextEditor.Superscript />
              </RichTextEditor.ControlsGroup>

              <RichTextEditor.ControlsGroup>
                <RichTextEditor.Link />
                <RichTextEditor.Unlink />
              </RichTextEditor.ControlsGroup>

              <RichTextEditor.ControlsGroup>
                <RichTextEditor.AlignLeft />
                <RichTextEditor.AlignCenter />
                <RichTextEditor.AlignJustify />
                <RichTextEditor.AlignRight />
              </RichTextEditor.ControlsGroup>
            </RichTextEditor.Toolbar>
          </DisableTabIndex>

          {editor && (
            <BubbleMenu editor={editor}>
              <Paper p="xs">
                <Group gap="xs">
                  <RichTextEditor.ControlsGroup>
                    <RichTextEditor.Bold />
                    <RichTextEditor.Italic />
                    <RichTextEditor.Underline />
                    <RichTextEditor.Strikethrough />
                    <RichTextEditor.ClearFormatting />
                    <RichTextEditor.Highlight />
                    <RichTextEditor.Code />
                    <ToggleCodeBlockControl />
                  </RichTextEditor.ControlsGroup>

                  <RichTextEditor.ControlsGroup>
                    <RichTextEditor.H1 />
                    <RichTextEditor.H2 />
                    <RichTextEditor.H3 />
                    <RichTextEditor.H4 />
                  </RichTextEditor.ControlsGroup>
                </Group>
              </Paper>
            </BubbleMenu>
          )}

          {props.error && <InputError mt="md">{props.error}</InputError>}

          <RichTextEditor.Content mt="md" />
        </RichTextEditor>
      </Stack>
    </>
  );
};

```
-------------------------------
[playground/frontend/src/components/ui/notes/title_input.tsx]

```tsx
import { Textarea, TextareaProps } from "@mantine/core";

type Props = TextareaProps;

export const NoteTitleInput = (props: Props) => {
  return (
    <>
      <Textarea
        placeholder="Title"
        variant="unstyled"
        minLength={1}
        maxLength={100}
        autosize
        styles={{
          input: {
            fontSize: "40px",
            fontWeight: "bold",
            border: "none",
          },
        }}
        {...props}
      />
    </>
  );
};

```
-------------------------------
[playground/frontend/src/components/ui/notes/update_form.tsx]

```tsx
import { ActionIcon, Badge, Group, Menu, Stack, Text } from "@mantine/core";
import { NoteTitleInput } from "@/components/ui/notes/title_input";
import { LazyNoteTextEditor } from "@/components/ui/notes/lazy_text_editor";
import { gateTan } from "@/configs/gate_tan";
import {
  V1NoteShowRoute,
  V1NoteUpdateRoute,
} from "@folie/playground-backend/blueprint";
import { useDebouncedCallback } from "@mantine/hooks";
import { OnValuesChangeParams } from "@folie/gate-tan/types";
import { useMemo, useState } from "react";
import { timeAgo } from "@/lib/helpers/date";
import LZString from "lz-string";
import { usePreventNavigation } from "@/lib/hooks/use_prevent_navigation";
import { IconDotsVertical } from "@tabler/icons-react";
import { useRouter } from "next/router";
import { NoteTag } from "./tag/note";

type Props = {
  note: V1NoteShowRoute["output"]["note"];
  refetch: () => void;
};

export const NoteUpdateForm = (props: Props) => {
  const router = useRouter();

  const [status, setStatus] = useState<"Saved" | "Unsaved" | "Error">("Saved");

  usePreventNavigation(status !== "Saved", () => {
    return confirm("Warning! You have unsaved changes.");
  });

  const decompressedBody = useMemo(() => {
    return LZString.decompressFromBase64(props.note.body);
  }, [props.note.body]);

  const handleSave = useDebouncedCallback(
    (values: OnValuesChangeParams<V1NoteUpdateRoute>) => {
      values.mutation.mutate({
        ...values.values,
        body: values.values.body
          ? LZString.compressToBase64(values.values.body)
          : values.values.body,
      });
    },
    2500,
  );

  const { form, inputProps } = gateTan.useForm({
    endpoint: "V1_NOTE_UPDATE",

    initialValues: {
      params: {
        noteId: props.note.id,
      },
      title: props.note.title,
      body: decompressedBody,
    },
    onValuesChange: (params) => {
      handleSave(params);
      setStatus("Unsaved");
    },
    onSuccess: () => {
      props.refetch();
      setStatus("Saved");
    },
    mutation: {
      onErrorHook: {
        after: () => {
          setStatus("Error");
        },
      },
    },
  });

  const deleteM = gateTan.useMutation({
    endpoint: "V1_NOTE_DELETE",
    onSuccess: () => {
      router.push("/app/notes");
    },
  });

  return (
    <>
      <Stack>
        <Stack gap={0}>
          <Group justify="space-between">
            <Badge
              color={
                status === "Saved"
                  ? "teal.5"
                  : status === "Unsaved"
                    ? "yellow"
                    : "red.5"
              }
              radius="sm"
              variant="light"
            >
              {status}
            </Badge>

            <Group>
              <Text c="dimmed" size="sm">
                {timeAgo(props.note.updatedAt)}
              </Text>

              <Menu shadow="md" width={200} position="bottom-end">
                <Menu.Target>
                  <ActionIcon variant="transparent" size="xs">
                    <IconDotsVertical />
                  </ActionIcon>
                </Menu.Target>

                <Menu.Dropdown>
                  <Menu.Item
                    color="red"
                    onClick={() => {
                      deleteM.mutate({
                        params: {
                          noteId: props.note.id,
                        },
                      });
                    }}
                  >
                    Delete
                  </Menu.Item>
                </Menu.Dropdown>
              </Menu>
            </Group>
          </Group>

          <NoteTitleInput
            {...inputProps("title")}
            key={form.key("title")}
            disabled={false}
          />

          <NoteTag note={props.note} refetch={props.refetch} />
        </Stack>

        <LazyNoteTextEditor {...inputProps("body")} key={form.key("body")} />
      </Stack>
    </>
  );
};

```
-------------------------------
[playground/frontend/src/components/ui/setting/password_update_form.tsx]

```tsx
import { gateTan } from "@/configs/gate_tan";
import { HorizontalInput, RightGroup } from "@folie/cobalt/components";
import { Button, PasswordInput, Stack } from "@mantine/core";
import { notifications } from "@mantine/notifications";
import { Form } from "@folie/gate-tan/components";

export const SettingPasswordUpdateForm = () => {
  const { form, inputProps, mutation } = gateTan.useForm({
    endpoint: "V1_AUTH_PASSWORD_UPDATE",
    initialValues: {
      newPassword: "",
      oldPassword: "",
    },
    onSuccess: (updatedData) => {
      notifications.show({
        message: updatedData.message,
      });

      return {
        input: {
          newPassword: "",
          oldPassword: "",
        },
        queryKeys: (qk) => [qk("V1_AUTH_SESSION")],
      };
    },
  });

  return (
    <>
      <Form mutation={mutation} submit={mutation.mutate} form={form}>
        {({ dirty, loading }) => (
          <>
            <HorizontalInput
              label="Password"
              description="Please enter your current and new password to update your credentials."
            >
              <Stack>
                <PasswordInput
                  placeholder="Old password"
                  required
                  withAsterisk={false}
                  minLength={8}
                  maxLength={32}
                  {...inputProps("oldPassword")}
                  key={form.key("oldPassword")}
                />

                <PasswordInput
                  placeholder="New password"
                  required
                  withAsterisk={false}
                  minLength={8}
                  maxLength={32}
                  {...inputProps("newPassword")}
                  key={form.key("newPassword")}
                />
              </Stack>
            </HorizontalInput>

            <RightGroup>
              <Button type="submit" loading={loading} disabled={!dirty}>
                Update
              </Button>
            </RightGroup>
          </>
        )}
      </Form>
    </>
  );
};

```
-------------------------------
[playground/frontend/src/components/ui/setting/update_form.tsx]

```tsx
import { gateTan } from "@/configs/gate_tan";
import { HorizontalInput, RightGroup } from "@folie/cobalt/components";
import { Form } from "@folie/gate-tan/components";
import { V1AuthSessionRoute } from "@folie/playground-backend/blueprint";
import { Button, Group, TextInput } from "@mantine/core";
import { notifications } from "@mantine/notifications";

type Props = {
  session: V1AuthSessionRoute["output"]["session"];
};

export const SettingGeneralUpdateForm = (props: Props) => {
  const { form, inputProps, mutation } = gateTan.useForm({
    endpoint: "V1_AUTH_PROFILE_UPDATE",
    initialValues: {
      firstName: props.session.firstName,
      lastName: props.session.lastName,
    },
    onSuccess: (updatedData) => {
      notifications.show({
        message: updatedData.message,
      });

      return {
        input: {
          ...updatedData.user,
        },
        queryKeys: (qk) => [qk("V1_AUTH_SESSION")],
      };
    },
  });

  return (
    <>
      <Form mutation={mutation} submit={mutation.mutate} form={form}>
        {({ dirty, loading }) => (
          <>
            <HorizontalInput
              label="Name"
              description="This name will be visible to users with whom you will share your passwords, notes etc."
            >
              <Group grow>
                <TextInput
                  placeholder="First Name"
                  {...inputProps("firstName")}
                  key={form.key("firstName")}
                />

                <TextInput
                  placeholder="Last Name"
                  {...inputProps("lastName")}
                  key={form.key("lastName")}
                />
              </Group>
            </HorizontalInput>

            <HorizontalInput
              label="Email"
              description="This is your primary email address."
            >
              <TextInput
                placeholder="someone@gmail.com"
                readOnly
                value={props.session.email}
              />
            </HorizontalInput>

            <RightGroup>
              <Button type="submit" loading={loading} disabled={!dirty}>
                Update
              </Button>
            </RightGroup>
          </>
        )}
      </Form>
    </>
  );
};

```
-------------------------------
[playground/frontend/src/configs/endpoints.ts]

```ts
import { endpoints as backendEndpoints } from "@folie/playground-backend/blueprint";

export const endpoints = {
  ...backendEndpoints,
};

```
-------------------------------
[playground/frontend/src/configs/env.ts]

```ts
import { createEnv } from "@t3-oss/env-nextjs";
import { z } from "zod";

export const env = createEnv({
  client: {
    NEXT_PUBLIC_CAPTCHA_PUBLIC_KEY: z.string().min(1),

    NEXT_PUBLIC_BACKEND_URL: z
      .string()
      .min(1)
      .url()
      .optional()
      .default("http://localhost:3333"),

    NEXT_PUBLIC_NODE_ENV: z
      .enum(["development", "production"])
      .optional()
      .default("production"),
  },

  runtimeEnv: {
    NEXT_PUBLIC_CAPTCHA_PUBLIC_KEY: process.env.NEXT_PUBLIC_CAPTCHA_PUBLIC_KEY,
    NEXT_PUBLIC_BACKEND_URL: process.env.NEXT_PUBLIC_BACKEND_URL,
    NEXT_PUBLIC_NODE_ENV: process.env.NEXT_PUBLIC_NODE_ENV,
  },

  isServer: typeof window === "undefined",
  emptyStringAsUndefined: false,
  skipValidation: !!process.env.SKIP_ENV_VALIDATION,
});

```
-------------------------------
[playground/frontend/src/configs/font.ts]

```ts
import { Geist, Geist_Mono } from "next/font/google";

const GeistSans = Geist({ subsets: ["latin"] });

const GeistMono = Geist_Mono({ subsets: ["latin"] });

export const FONTS = {
  GEIST: GeistSans.style.fontFamily,
  GEIST_MONO: GeistMono.style.fontFamily,
};

```
-------------------------------
[playground/frontend/src/configs/gate.ts]

```ts
import { Gate } from "@folie/gate";
import { env } from "./env";
import { endpoints } from "./endpoints";
import { gateClient } from "./gate_client";

export const gate = new Gate({
  baseURL: new URL(env.NEXT_PUBLIC_BACKEND_URL),
  endpoints: endpoints,
  token: () => gateClient.getCookie("session"),
  header: () => {
    const cap = gateClient.getCookie("captcha");

    if (!cap) {
      return null;
    }

    return {
      token: cap,
    };
  },
});

```
-------------------------------
[playground/frontend/src/configs/gate_client.ts]

```ts
import { GateNextClient } from "@folie/gate-next";

export const gateClient = new GateNextClient({
  cookieKeys: {
    session: "session_token",
    captcha: "captcha_token",
  },
  paramKeys: ["userId", "noteId", "tagId"] as const,
});

```
-------------------------------
[playground/frontend/src/configs/gate_server.ts]

```ts
import { gate } from "./gate";
import { endpoints } from "./endpoints";
import { GateNextServer } from "@folie/gate-next";
import { gateClient } from "./gate_client";

export const gateServer = new GateNextServer({
  gate,
  endpoints,
  checkpoint: {
    redirect: "/sign-in",
  },
  session: {
    cookie: gateClient.cookieKeys.session,
    endpoint: "V1_AUTH_SESSION",
  },
});

```
-------------------------------
[playground/frontend/src/configs/gate_tan.ts]

```ts
import { gate } from "./gate";
import { notifications } from "@mantine/notifications";
import { endpoints } from "./endpoints";
import { GateTan } from "@folie/gate-tan";

export const gateTan = new GateTan({
  gate,
  endpoints,
  notification: (params) =>
    notifications.show({
      title: params.title,
      message: params.message,
    }),
});

```
-------------------------------
[playground/frontend/src/configs/index.ts]

```ts
import type { CobaltConfig as CC } from "@folie/cobalt/types";

export const CobaltConfig: CC = {
  theme: "dark",
  forceTheme: true,
};

```
-------------------------------
[playground/frontend/src/configs/setting.ts]

```ts
export const setting = {
  app: {
    name: "Playground",
    tagline: "Testing Folie Packages Here.",
    description: "Testing Folie Packages Here.",
  },

  header: {
    height: 60,
  },

  home: "/notes",
};

```
-------------------------------
[playground/frontend/src/configs/theme.ts]

```ts
import {
  createTheme,
  defaultVariantColorsResolver,
  parseThemeColor,
  VariantColorsResolver,
} from "@mantine/core";
import { FONTS } from "./font";

const variantColorResolver: VariantColorsResolver = (input) => {
  const defaultResolvedColors = defaultVariantColorsResolver(input);
  const parsedColor = parseThemeColor({
    color: input.color || input.theme.primaryColor,
    theme: input.theme,
  });

  // Override some properties for variant
  if (
    parsedColor.isThemeColor &&
    input.variant === "filled" &&
    parsedColor.color === "gray"
  ) {
    return {
      ...defaultResolvedColors,
      color: "var(--mantine-color-dark-9)",
    };
  }

  return defaultResolvedColors;
};

export const MantineTheme = createTheme({
  fontFamily: FONTS.GEIST,
  fontFamilyMonospace: FONTS.GEIST_MONO,

  headings: {
    fontFamily: FONTS.GEIST,
    fontWeight: "500",
  },

  variantColorResolver: variantColorResolver,

  defaultRadius: "sm",
  autoContrast: true,
  primaryColor: "gray",
  primaryShade: 0,
  cursorType: "pointer",
});

```
-------------------------------
[playground/frontend/src/lib/crumbs.ts]

```ts
import { CrumbsHolder } from "./helpers/crumbs_holder";

export const homeCrumbs = new CrumbsHolder([
  {
    label: "Home",
    href: "app",
  },
]);

export const noteCrumbs = homeCrumbs.extend([
  {
    label: "Notes",
    href: "notes",
  },
]);

export const tagCrumbs = noteCrumbs.extend([
  {
    label: "Tags",
    href: "",
  },
]);

export const settingCrumbs = homeCrumbs.extend([
  {
    label: "Settings",
    href: "settings",
  },
]);

```
-------------------------------
[playground/frontend/src/lib/helpers/crumbs_holder.ts]

```ts
import { Crumbs } from "../types";

export class CrumbsHolder {
  constructor(private crumbs: Crumbs) {}

  extend(crumbs: Crumbs) {
    return new CrumbsHolder([...this.crumbs, ...crumbs]);
  }

  get(crumbs?: Crumbs): Crumbs {
    return [...this.crumbs, ...(crumbs || [])].reduce<Crumbs>(
      (acc, crumb, index) => {
        const lastCrumb = acc[acc.length - 1];

        const href =
          index === 0 ? `/${crumb.href}` : `${lastCrumb.href}/${crumb.href}`;

        acc.push({ ...crumb, href });

        return acc;
      },
      [],
    );
  }
}

```
-------------------------------
[playground/frontend/src/lib/helpers/date.ts]

```ts
import dayjs from "dayjs";
import relativeTime from "dayjs/plugin/relativeTime";

dayjs.extend(relativeTime);

export const formatDate = (
  date: string | Date | null,
  format: string = "DD MMM YYYY HH:mm A",
) => {
  if (!date) return null;

  return dayjs(date).format(format);
};

export const timeAgo = (date: string | Date | null) => {
  if (!date) return null;

  return dayjs(date).fromNow();
};

export const parseDate = (date: string | null) => {
  if (!date) return null;

  return new Date(date);
};

export const stringifyDate = (date: Date | null) => {
  if (!date) return null;

  return date.toISOString();
};

```
-------------------------------
[playground/frontend/src/lib/hooks/use_prevent_navigation.ts]

```ts
import Router from "next/router";
import { useEffect, useCallback } from "react";

export const usePreventNavigation = (
  active: boolean,
  onConfirm: () => boolean,
) => {
  const handleRouteChangeStart = useCallback(() => {
    if (active) {
      const ok = onConfirm();
      if (!ok) {
        Router.events.emit("routeChangeError");
        throw "Abort route change. Please ignore this error.";
      }
    }
  }, [active, onConfirm]);

  const handleBeforeUnload = useCallback(
    (event: BeforeUnloadEvent) => {
      if (active) {
        const ok = onConfirm();
        if (!ok) {
          event.preventDefault();
          event.returnValue = true; // Standard message will be shown by the browser
          return true;
        }
      }
    },
    [active, onConfirm],
  );

  useEffect(() => {
    if (active) {
      Router.events.on("routeChangeStart", handleRouteChangeStart);
      window.addEventListener("beforeunload", handleBeforeUnload);
    } else {
      Router.events.off("routeChangeStart", handleRouteChangeStart);
      window.removeEventListener("beforeunload", handleBeforeUnload);
    }

    return () => {
      Router.events.off("routeChangeStart", handleRouteChangeStart);
      window.removeEventListener("beforeunload", handleBeforeUnload);
    };
  }, [active, handleRouteChangeStart, handleBeforeUnload]);
};

```
-------------------------------
[playground/frontend/src/lib/hooks/use_session.ts]

```ts
import { gateTan } from "@/configs/gate_tan";

export const useSession = () => {
  const query = gateTan.useQuery({
    endpoint: "V1_AUTH_SESSION",
    input: undefined,
  });

  return query;
};

```
-------------------------------
[playground/frontend/src/lib/jotai.ts]

```ts

```
-------------------------------
[playground/frontend/src/lib/types/index.ts]

```ts
import { TextProps } from "@mantine/core";

export type Crumbs = { label: string; href: string; options?: TextProps }[];

```
-------------------------------
[playground/frontend/src/pages/404.tsx]

```tsx
import { Center, Stack, Text, Title } from "@mantine/core";

export default function Page() {
  return (
    <>
      <Center h="100vh">
        <Stack>
          <Title mx="auto" size="15vw">
            404
          </Title>

          <Text mx="auto" size="xl">
            Page not found
          </Text>
        </Stack>
      </Center>
    </>
  );
}

```
-------------------------------
[playground/frontend/src/pages/_app.tsx]

```tsx
import "@mantine/core/styles.css";
import "@/styles/global.css";
import "@mantine/dates/styles.css";
import "@mantine/notifications/styles.css";
import "@mantine/nprogress/styles.css";
import "@folie/cobalt-animation/cobalt-animation.css";
import "@folie/cobalt/cobalt.css";
import "@/styles/theme.css";

import type { AppProps } from "next/app";

import { CobaltConfig } from "@/configs";
import { MantineTheme } from "@/configs/theme";
import { CobaltContext } from "@folie/cobalt";
import { NextSeo } from "next-seo";
import { useRouter } from "next/router";
import { useState } from "react";
import { setting } from "@/configs/setting";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

export default function App({ Component, pageProps }: AppProps) {
  const router = useRouter();

  const [queryClient] = useState(() => new QueryClient());

  return (
    <>
      <NextSeo title={setting.app.name} description={setting.app.description} />
      <CobaltContext
        config={CobaltConfig}
        mantine={MantineTheme}
        router={router}
        // navigation={{
        //   started: (url) => {
        //     if (url !== router.asPath) {
        //       setNavigationState(true);
        //     }
        //   },
        //   completed: () => {
        //     setNavigationState(false);
        //   },
        // }}
      >
        <QueryClientProvider client={queryClient}>
          <Component {...pageProps} />
          {/* <NavigationLoading opened={NavigationState}>
          </NavigationLoading> */}
        </QueryClientProvider>
      </CobaltContext>
    </>
  );
}

```
-------------------------------
[playground/frontend/src/pages/_document.tsx]

```tsx
import { CobaltConfig } from "@/configs";
import { HeadScript } from "@folie/cobalt/components";
import { Head, Html, Main, NextScript } from "next/document";

export default function Document() {
  return (
    <Html lang="en" suppressHydrationWarning>
      <Head>
        <HeadScript {...CobaltConfig} />
      </Head>
      <body>
        <Main />
        <NextScript />
      </body>
    </Html>
  );
}

```
-------------------------------
[playground/frontend/src/pages/app/index.tsx]

```tsx
import { AppLayout } from "@/components/layout/app";
import { gateServer } from "@/configs/gate_server";
import { homeCrumbs } from "@/lib/crumbs";
import { Center, Text } from "@mantine/core";

export const getServerSideProps = gateServer.checkpoint();

export default function Page() {
  return (
    <>
      <AppLayout fullHeight crumbs={homeCrumbs.get()}>
        <Center h="100%">
          <Text fs="italic" fw="bold">
            Still thinking what to do is a waste of time
          </Text>
        </Center>
      </AppLayout>
    </>
  );
}

```
-------------------------------
[playground/frontend/src/pages/app/notes/[noteId].tsx]

```tsx
import { AppLayout } from "@/components/layout/app";
import { gateServer } from "@/configs/gate_server";
import { noteCrumbs } from "@/lib/crumbs";
import { gateTan } from "@/configs/gate_tan";
import { gateClient } from "@/configs/gate_client";
import { LocalQueryLoader } from "@/components/query_loader";
import { NoteUpdateForm } from "@/components/ui/notes/update_form";
import { Container, Group, Skeleton, Space, Stack } from "@mantine/core";

export const getServerSideProps = gateServer.checkpoint();

export default function Page() {
  const { isReady, param } = gateClient.useParams();

  const noteId = param.bind(null, "noteId");

  const noteQ = gateTan.useQuery({
    endpoint: "V1_NOTE_SHOW",
    input: {
      params: {
        noteId: noteId(),
      },
    },
    enabled: isReady,
  });

  return (
    <>
      <AppLayout
        crumbs={noteCrumbs.get([
          {
            label: noteQ.data?.note.title || "Untitled",
            href: noteId(),
          },
        ])}
      >
        <Container pt="xl">
          <LocalQueryLoader
            query={noteQ}
            isLoading={
              <>
                <Stack gap="xs">
                  <Group justify="space-between">
                    <Skeleton width={60} height={20} radius="sm" />

                    <Group gap="xs">
                      <Skeleton width={60} height={20} radius="sm" />

                      <Skeleton width={20} height={20} radius="sm" />
                    </Group>
                  </Group>

                  <Skeleton height={40} radius="sm" />

                  <Skeleton width={60} height={20} radius="lg" />

                  <Skeleton height={400} radius="sm" />
                </Stack>
              </>
            }
          >
            {({ note }) => (
              <>
                <NoteUpdateForm note={note} refetch={() => noteQ.refetch()} />

                <Space h="xl" />
              </>
            )}
          </LocalQueryLoader>
        </Container>
      </AppLayout>
    </>
  );
}

```
-------------------------------
[playground/frontend/src/pages/app/notes/index.tsx]

```tsx
import { AppLayout } from "@/components/layout/app";
import { LocalQueryLoader } from "@/components/query_loader";
import {
  Button,
  Center,
  Container,
  Divider,
  Group,
  Loader,
  Paper,
  Space,
  Stack,
  Text,
  TextInput,
  Title,
  Tooltip,
} from "@mantine/core";
import { gateServer } from "@/configs/gate_server";
import { noteCrumbs } from "@/lib/crumbs";
import { gateTan } from "@/configs/gate_tan";
import { For, Show } from "@folie/cobalt/components";
import { timeAgo } from "@/lib/helpers/date";
import { PaginationRange } from "@/components/pagination_range";
import { SimplePagination } from "@/components/simple_pagination";
import { useRouter } from "next/router";
import { DotProp } from "@folie/lib";
import { TagBadge } from "@/components/ui/notes/tag/badge";
import { IconPlus, IconTagFilled } from "@tabler/icons-react";
import { ICON_SIZE } from "@folie/cobalt";
import { TagManageAside } from "@/components/ui/notes/tag/manage";
import { useState } from "react";
import { notifications } from "@mantine/notifications";

export const getServerSideProps = gateServer.checkpoint();

export default function Page() {
  const router = useRouter();

  const [tagManageState, setTagManageState] = useState(false);

  const { body, query, setBody } = gateTan.useList({
    endpoint: "V1_NOTE_LIST",
    input: {
      query: {
        page: 1,
        limit: 10,
        order: {
          by: "updatedAt",
          dir: "desc",
        },
      },
    },
    debounce: {
      timeout: 500,
    },
  });

  const createM = gateTan.useMutation({
    endpoint: "V1_NOTE_CREATE",
    onSuccess: (updatedData) => {
      notifications.show({
        message: updatedData.message,
      });

      router.push(`/app/notes/${updatedData.note.id}`);
    },
  });

  return (
    <>
      <AppLayout
        crumbs={noteCrumbs.get()}
        aside={{
          state: tagManageState,
          setState: setTagManageState,
          children: (
            <TagManageAside
              state={tagManageState}
              setState={setTagManageState}
            />
          ),
        }}
      >
        <Container pt="xl">
          <Stack>
            <Group justify="space-between">
              <Title>Notes</Title>

              <Group>
                <Button
                  leftSection={<IconPlus size={ICON_SIZE.SM} />}
                  onClick={() => createM.mutate(undefined)}
                  loading={createM.isPending}
                >
                  Create
                </Button>

                <Tooltip label="Manage Tags" position="bottom-end">
                  <Button
                    px="xs"
                    variant="outline"
                    onClick={() => setTagManageState(!tagManageState)}
                  >
                    <IconTagFilled size={ICON_SIZE.SM} />
                  </Button>
                </Tooltip>
              </Group>
            </Group>

            <TextInput
              minLength={1}
              maxLength={100}
              description='Use "tag:" to search by tag, or enter keywords to search by note title'
              placeholder="Search notes..."
              value={DotProp.lookup(body, "query.filter.value", "")}
              onChange={(e) => {
                const newValue = e.currentTarget.value;

                setBody({
                  query: {
                    ...body.query,
                    filter: newValue !== "" ? { value: newValue } : undefined,
                  },
                });
              }}
            />

            <Divider />

            <LocalQueryLoader
              query={query}
              isLoading={
                <>
                  <Center h="100vh">
                    <Loader />
                  </Center>
                </>
              }
            >
              {({ data, meta }) => (
                <>
                  <Show>
                    <Show.When isTrue={data.length === 0}>
                      <>
                        <Center h="50vh">
                          <Text fs="italic" fw="bold">
                            {(() => {
                              const filterValue = DotProp.lookup(
                                body,
                                "query.filter.value",
                                "",
                              );

                              if (filterValue !== "") {
                                return `No notes found for "${filterValue}"`;
                              } else {
                                return `"No notes found."`;
                              }
                            })()}
                          </Text>
                        </Center>
                      </>
                    </Show.When>

                    <Show.Else>
                      <>
                        <For each={data}>
                          {(note) => (
                            <>
                              <Paper
                                p="md"
                                onClick={() =>
                                  router.push(`/app/notes/${note.id}`)
                                }
                                style={{
                                  cursor: "pointer",
                                }}
                              >
                                <Stack>
                                  <Group justify="space-between">
                                    <Title order={4} flex={1}>
                                      <Text inherit truncate="end" maw="60%">
                                        {note.title}
                                      </Text>
                                    </Title>

                                    <Text c="dimmed" size="sm">
                                      {timeAgo(note.updatedAt)}
                                    </Text>
                                  </Group>

                                  {note.tags.length > 0 && (
                                    <Group gap="xs">
                                      <For each={note.tags}>
                                        {(tag) => (
                                          <>
                                            <TagBadge
                                              color="dark.9"
                                              tag={tag}
                                            />
                                          </>
                                        )}
                                      </For>
                                    </Group>
                                  )}
                                </Stack>
                              </Paper>
                            </>
                          )}
                        </For>

                        <Group justify="space-between">
                          <PaginationRange
                            page={DotProp.lookup(body, "query.page", 1)}
                            limit={DotProp.lookup(body, "query.limit", 10)}
                            total={meta.total}
                          />

                          <SimplePagination
                            page={DotProp.lookup(body, "query.page", 1)}
                            limit={DotProp.lookup(body, "query.limit", 10)}
                            total={meta.total}
                            onChange={(page) => {
                              setBody(
                                DotProp.assignOrOmit(
                                  body,
                                  "query.page",
                                  page,
                                  1,
                                ),
                              );
                            }}
                          />
                        </Group>

                        <Space h="xl" />
                      </>
                    </Show.Else>
                  </Show>
                </>
              )}
            </LocalQueryLoader>
          </Stack>
        </Container>
      </AppLayout>
    </>
  );
}

```
-------------------------------
[playground/frontend/src/pages/app/notes/tags/[tagId].tsx]

```tsx
import { AppLayout } from "@/components/layout/app";
import { gateServer } from "@/configs/gate_server";
import { tagCrumbs } from "@/lib/crumbs";
import { gateTan } from "@/configs/gate_tan";
import { gateClient } from "@/configs/gate_client";
import { LocalQueryLoader } from "@/components/query_loader";
import { Container, Group, Skeleton, Stack } from "@mantine/core";
import { TagUpdateForm } from "@/components/ui/notes/tag/update_form";

export const getServerSideProps = gateServer.checkpoint();

export default function Page() {
  const { isReady, param } = gateClient.useParams();

  const tagId = param.bind(null, "tagId");

  const tagQ = gateTan.useQuery({
    endpoint: "V1_TAG_SHOW",
    input: {
      params: {
        tagId: tagId(),
      },
    },
    enabled: isReady,
  });

  return (
    <>
      <AppLayout
        crumbs={tagCrumbs.get([
          {
            label: tagQ.data?.tag.name || "Untitled",
            href: tagId(),
          },
        ])}
      >
        <Container pt="xl">
          <LocalQueryLoader
            query={tagQ}
            isLoading={
              <>
                <Stack gap="xs">
                  <Group justify="space-between">
                    <Skeleton width={60} height={20} radius="sm" />

                    <Group gap="xs">
                      <Skeleton width={60} height={20} radius="sm" />

                      <Skeleton width={20} height={20} radius="sm" />
                    </Group>
                  </Group>

                  <Skeleton height={40} radius="sm" />

                  <Skeleton width={60} height={20} radius="lg" />

                  <Skeleton height={400} radius="sm" />
                </Stack>
              </>
            }
          >
            {({ tag }) => (
              <>
                <TagUpdateForm tag={tag} />
              </>
            )}
          </LocalQueryLoader>
        </Container>
      </AppLayout>
    </>
  );
}

```
-------------------------------
[playground/frontend/src/pages/app/settings.tsx]

```tsx
import { AppLayout } from "@/components/layout/app";
import { LocalQueryLoader } from "@/components/query_loader";
import { useSession } from "@/lib/hooks/use_session";
import {
  Center,
  Container,
  Group,
  Loader,
  Space,
  Stack,
  Tabs,
  Text,
  Title,
} from "@mantine/core";
import { SettingGeneralUpdateForm } from "@/components/ui/setting/update_form";
import { SettingPasswordUpdateForm } from "@/components/ui/setting/password_update_form";
import { gateServer } from "@/configs/gate_server";
import { LocalBoringAvatar } from "@/components/boring_avatar";
import { settingCrumbs } from "@/lib/crumbs";

export const getServerSideProps = gateServer.checkpoint();

export default function Page() {
  const sessionQ = useSession();

  return (
    <>
      <AppLayout fullHeight crumbs={settingCrumbs.get()}>
        <LocalQueryLoader
          query={sessionQ}
          isLoading={
            <>
              <Center h="100vh">
                <Loader />
              </Center>
            </>
          }
        >
          {({ session }) => (
            <>
              <Container pt="xl">
                <Stack>
                  <Group>
                    <LocalBoringAvatar seed={session.id} size="xl" />

                    <Stack gap={0}>
                      <Title order={3}>
                        {session.firstName} {session.lastName}
                      </Title>

                      <Text c="dimmed">{session.email}</Text>
                    </Stack>
                  </Group>

                  <Space h="md" />

                  <Tabs defaultValue="general">
                    <Tabs.List>
                      <Tabs.Tab value="general">General</Tabs.Tab>
                      <Tabs.Tab value="security">Security</Tabs.Tab>
                    </Tabs.List>

                    <Tabs.Panel value="general" pt="xl">
                      <SettingGeneralUpdateForm session={session} />
                    </Tabs.Panel>

                    <Tabs.Panel value="security" pt="xl">
                      <SettingPasswordUpdateForm />
                    </Tabs.Panel>
                  </Tabs>
                </Stack>
              </Container>
            </>
          )}
        </LocalQueryLoader>
      </AppLayout>
    </>
  );
}

```
-------------------------------
[playground/frontend/src/pages/index.tsx]

```tsx
import { Logo } from "@/components/logo";
import { setting } from "@/configs/setting";
import { Reveal } from "@folie/cobalt-animation";
import {
  AppShell,
  Button,
  Center,
  Group,
  Stack,
  Text,
  Title,
} from "@mantine/core";
import Link from "next/link";

export default function Page() {
  return (
    <>
      <AppShell header={{ height: setting.header.height }} padding="md">
        <AppShell.Header withBorder={false} px="md" bg="transparent">
          <Group justify="space-between" h="100%">
            <Logo size="lg" />

            <Group>
              <Button component={Link} href="/sign-in" variant="outline">
                Sign In
              </Button>
              <Button component={Link} href="/sign-up" c="dark">
                Sign Up
              </Button>
            </Group>
          </Group>
        </AppShell.Header>

        <AppShell.Main h={`calc(100vh - ${setting.header.height}px)`}>
          <Center h="100%">
            <Stack gap="0">
              <Title mx="auto" size="15vw" fw="800">
                <Reveal
                  splitBy="characters"
                  staggerDuration={0.025}
                  staggerFrom="center"
                  transition={{
                    type: "spring",
                    stiffness: 200,
                    damping: 21,
                  }}
                >
                  {setting.app.name}
                </Reveal>
              </Title>

              <Text mx="auto" size="lg">
                <Reveal
                  splitBy="characters"
                  staggerDuration={0.025}
                  staggerFrom="center"
                  transition={{
                    type: "spring",
                    stiffness: 200,
                    damping: 21,
                    delay: 0.3,
                  }}
                >
                  {setting.app.tagline}
                </Reveal>
              </Text>
            </Stack>
          </Center>
        </AppShell.Main>
      </AppShell>
    </>
  );
}

```
-------------------------------
[playground/frontend/src/pages/sign-in.tsx]

```tsx
import { Logo } from "@/components/logo";
import {
  Anchor,
  Button,
  Card,
  Container,
  PasswordInput,
  Stack,
  Text,
  TextInput,
  Title,
} from "@mantine/core";
import { notifications } from "@mantine/notifications";
import { useRouter } from "next/router";
import { Turnstile, TurnstileInstance } from "@marsidev/react-turnstile";
import { useRef, useState } from "react";
import { env } from "@/configs/env";
import { gateServer } from "@/configs/gate_server";
import { gateTan } from "@/configs/gate_tan";
import { gateClient } from "@/configs/gate_client";
import { useQueryClient } from "@tanstack/react-query";
import { Form } from "@folie/gate-tan/components";

export const getServerSideProps = gateServer.checkpoint({
  condition: ({ session }) => {
    return {
      allow: !session,
      redirect: "/app",
    };
  },
});

export default function Page() {
  const router = useRouter();

  const captchaRef = useRef<TurnstileInstance>(undefined);

  const [captchaReady, setCaptchaReady] = useState(false);

  const queryClient = useQueryClient();

  const { form, inputProps, mutation } = gateTan.useForm({
    endpoint: "V1_AUTH_SIGN_IN",

    initialValues: {
      email: "",
      password: "",
    },

    onSuccess: (data) => {
      gateClient.setCookie("session", data.token);

      queryClient.clear();

      notifications.show({
        message: data.message,
      });

      router.replace("/app");
    },
    mutation: {
      onErrorHook: {
        after: () => {
          captchaRef.current?.reset();
          setCaptchaReady(false);
          gateClient.removeCookie("captcha");
        },
      },
    },
  });

  return (
    <>
      <Container size="xs">
        <Stack gap="xs" w="100%" justify="center" h="100vh">
          <Logo size="xl" mx="auto" />

          <Card withBorder p="md">
            <Stack>
              <Title order={2}>Welcome back!</Title>

              <Text size="sm">
                Don&apos;t have an account?{" "}
                <Anchor td="underline" href="/sign-up">
                  Create an account
                </Anchor>
              </Text>

              <Form mutation={mutation} submit={mutation.mutate} form={form}>
                {({ dirty, loading }) => (
                  <>
                    <TextInput
                      autoComplete="email"
                      label="Email"
                      placeholder="Enter your email"
                      type="email"
                      {...inputProps("email")}
                      key={form.key("email")}
                      required
                      withAsterisk={false}
                    />

                    <PasswordInput
                      label="Password"
                      placeholder="Enter your password"
                      {...inputProps("password")}
                      key={form.key("password")}
                      required
                      minLength={8}
                      maxLength={32}
                      withAsterisk={false}
                    />

                    {dirty && (
                      <Turnstile
                        ref={captchaRef}
                        siteKey={env.NEXT_PUBLIC_CAPTCHA_PUBLIC_KEY}
                        onSuccess={(t) => {
                          gateClient.setCookie("captcha", t);
                          setCaptchaReady(true);
                        }}
                        onExpire={() => {
                          notifications.show({
                            title: "Captcha Expired",
                            message: "Complete it again",
                          });

                          setCaptchaReady(false);
                          gateClient.removeCookie("captcha");
                        }}
                        onError={() => {
                          notifications.show({
                            title: "Captcha Error",
                            message: "Please try again",
                          });

                          setCaptchaReady(false);
                          gateClient.removeCookie("captcha");
                        }}
                        options={{
                          size: "flexible",
                        }}
                      />
                    )}

                    <Button
                      type="submit"
                      loading={loading}
                      disabled={!dirty || !captchaReady}
                    >
                      Sign In
                    </Button>
                  </>
                )}
              </Form>
            </Stack>
          </Card>
        </Stack>
      </Container>
    </>
  );
}

```
-------------------------------
[playground/frontend/src/pages/sign-up.tsx]

```tsx
import { Logo } from "@/components/logo";
import {
  Anchor,
  Button,
  Card,
  Container,
  Group,
  PasswordInput,
  Stack,
  Text,
  TextInput,
  Title,
} from "@mantine/core";
import { notifications } from "@mantine/notifications";
import { useRouter } from "next/router";
import { Turnstile, TurnstileInstance } from "@marsidev/react-turnstile";
import { useRef, useState } from "react";
import { env } from "@/configs/env";
import { gateServer } from "@/configs/gate_server";
import { gateTan } from "@/configs/gate_tan";
import { gateClient } from "@/configs/gate_client";
import { Form } from "@folie/gate-tan/components";

export const getServerSideProps = gateServer.checkpoint({
  condition: ({ session }) => {
    return {
      allow: !session,
      redirect: "/app",
    };
  },
});

export default function Page() {
  const router = useRouter();

  const captchaRef = useRef<TurnstileInstance>(undefined);

  const [captchaReady, setCaptchaReady] = useState(false);

  const { form, inputProps, mutation } = gateTan.useForm({
    endpoint: "V1_AUTH_SIGN_UP",

    initialValues: {
      firstName: "",
      lastName: "",
      email: "",
      password: "",
      confirmPassword: "",
    },

    onSuccess: (data) => {
      notifications.show({
        message: data.message,
      });

      router.replace("/sign-in");
    },
    mutation: {
      onErrorHook: {
        after: () => {
          captchaRef.current?.reset();
          setCaptchaReady(false);
          gateClient.removeCookie("captcha");
        },
      },
    },
  });

  return (
    <>
      <Container size="xs">
        <Stack gap="xs" w="100%" justify="center" h="100vh">
          <Logo size="xl" mx="auto" />

          <Card withBorder p="md">
            <Stack>
              <Title order={2}>Create an account</Title>

              <Text size="sm">
                Already have an account?{" "}
                <Anchor td="underline" href="/sign-in">
                  Sign In
                </Anchor>
              </Text>

              <Form mutation={mutation} submit={mutation.mutate} form={form}>
                {({ dirty, loading }) => (
                  <>
                    <Group grow>
                      <TextInput
                        label="First name"
                        placeholder="John"
                        {...inputProps("firstName")}
                        key={form.key("firstName")}
                        required
                        withAsterisk={false}
                      />

                      <TextInput
                        label="Last name"
                        placeholder="Doe"
                        {...inputProps("lastName")}
                        key={form.key("lastName")}
                        required
                        withAsterisk={false}
                      />
                    </Group>

                    <TextInput
                      label="Email"
                      description="Only gmail's are allowed"
                      placeholder="someone@gmail.com"
                      type="email"
                      {...inputProps("email")}
                      key={form.key("email")}
                      required
                      withAsterisk={false}
                    />

                    <PasswordInput
                      label="Password"
                      placeholder="MwL]6j*mGnQW9zn"
                      {...inputProps("password")}
                      key={form.key("password")}
                      required
                      minLength={8}
                      maxLength={32}
                      withAsterisk={false}
                    />

                    <PasswordInput
                      label="Confirm Password"
                      placeholder="MwL]6j*mGnQW9zn"
                      {...inputProps("confirmPassword")}
                      key={form.key("confirmPassword")}
                      required
                      minLength={8}
                      maxLength={32}
                      withAsterisk={false}
                    />

                    {dirty && (
                      <Turnstile
                        ref={captchaRef}
                        siteKey={env.NEXT_PUBLIC_CAPTCHA_PUBLIC_KEY}
                        onSuccess={(t) => {
                          gateClient.setCookie("captcha", t);
                          setCaptchaReady(true);
                        }}
                        onExpire={() => {
                          notifications.show({
                            title: "Captcha Expired",
                            message: "Complete it again",
                          });

                          setCaptchaReady(false);
                          gateClient.removeCookie("captcha");
                        }}
                        onError={() => {
                          notifications.show({
                            title: "Captcha Error",
                            message: "Please try again",
                          });

                          setCaptchaReady(false);
                          gateClient.removeCookie("captcha");
                        }}
                        options={{
                          size: "flexible",
                        }}
                      />
                    )}

                    <Button
                      type="submit"
                      loading={loading}
                      disabled={!dirty || !captchaReady}
                    >
                      Sign Up
                    </Button>
                  </>
                )}
              </Form>
            </Stack>
          </Card>
        </Stack>
      </Container>
    </>
  );
}

```
-------------------------------
[playground/frontend/src/pages/verify.tsx]

```tsx
import { Logo } from "@/components/logo";
import { Button, Card, Container, Stack, Title } from "@mantine/core";
import { notifications } from "@mantine/notifications";
import { useRouter } from "next/router";
import { Turnstile, TurnstileInstance } from "@marsidev/react-turnstile";
import { useRef, useState } from "react";
import { env } from "@/configs/env";
import { InferGetServerSidePropsType } from "next";
import { gateServer } from "@/configs/gate_server";
import { NextServerError } from "@folie/gate-next";
import { gateTan } from "@/configs/gate_tan";
import { gateClient } from "@/configs/gate_client";

export const getServerSideProps = gateServer.server(
  async ({ ctx }) => {
    const { query } = ctx;

    const token = query.token;

    if (typeof token !== "string") {
      throw NextServerError.notFound();
    }

    const tokenLength = token.length;

    if (tokenLength < 150 || tokenLength > 300) {
      throw NextServerError.notFound();
    }

    return {
      props: {
        token,
      },
    };
  },
  {
    checkpoint: ({ session }) => {
      return {
        allow: !session,
        redirect: "/app",
      };
    },
  },
);

export default function Page(
  props: InferGetServerSidePropsType<typeof getServerSideProps>,
) {
  const router = useRouter();

  const captchaRef = useRef<TurnstileInstance>(undefined);

  const [captchaReady, setCaptchaReady] = useState(false);

  const verifyM = gateTan.useMutation({
    endpoint: "V1_AUTH_VERIFY",
    onSuccess: (data) => {
      notifications.show({
        message: data.message,
      });

      router.replace("/sign-in");
    },

    onErrorHook: {
      after: () => {
        captchaRef.current?.reset();
        setCaptchaReady(false);
        gateClient.removeCookie("captcha");
      },
    },
  });

  return (
    <>
      <Container size="xs">
        <Stack gap="xs" w="100%" justify="center" h="100vh">
          <Logo size="xl" mx="auto" />

          <Card withBorder p="md">
            <Stack>
              <Title order={2}>Verify Your Identity</Title>

              <Turnstile
                ref={captchaRef}
                siteKey={env.NEXT_PUBLIC_CAPTCHA_PUBLIC_KEY}
                onSuccess={(t) => {
                  gateClient.setCookie("captcha", t);
                  setCaptchaReady(true);
                }}
                onExpire={() => {
                  notifications.show({
                    title: "Captcha Expired",
                    message: "Complete it again",
                  });

                  setCaptchaReady(false);
                  gateClient.removeCookie("captcha");
                }}
                onError={() => {
                  notifications.show({
                    title: "Captcha Error",
                    message: "Please try again",
                  });

                  setCaptchaReady(false);
                  gateClient.removeCookie("captcha");
                }}
                options={{
                  size: "flexible",
                }}
              />

              <Button
                loading={verifyM.isPending}
                disabled={!captchaReady}
                onClick={() => {
                  verifyM.mutate({
                    token: props.token,
                  });
                }}
              >
                Verify
              </Button>
            </Stack>
          </Card>
        </Stack>
      </Container>
    </>
  );
}

```
-------------------------------
[playground/frontend/src/styles/global.css]

```css
@layer mantine, mantine-datatable, mantine-contextmenu;

::selection {
  color: var(--mantine-color-dark-9);
  background: var(--mantine-color-white);
}

.blink {
  animation: blinker 1s linear infinite;
}

@keyframes blinker {
  50% {
    opacity: 0;
  }
}

```
-------------------------------
[playground/frontend/src/styles/theme.css]

```css
:root {
  @mixin dark {
    &[data-variant="filled"] {
      color: var(--mantine-color-red-9);
    }
  }
}

body {
  @mixin dark {
    background-color: var(--mantine-color-dark-9);
  }
}

/* AppShell */

.mantine-AppShell-main {
  @mixin dark {
    background-color: var(--mantine-color-dark-9);
  }
}

.mantine-AppShell-header {
  @mixin dark {
    background-color: var(--mantine-color-dark-9);
  }
}

.mantine-AppShell-navbar {
  @mixin dark {
    background-color: var(--mantine-color-dark-9);
  }
}

.mantine-AppShell-aside {
  @mixin dark {
    background-color: var(--mantine-color-dark-9);
  }
}

/* Paper */

.mantine-Paper-root {
  @mixin dark {
    background-color: var(--mantine-color-dark-8);
  }
}

/* Menu */

.mantine-Menu-dropdown {
  @mixin dark {
    background-color: var(--mantine-color-dark-8);
  }
}

.mantine-Menu-item[data-hovered="true"] {
  @mixin dark {
    background-color: var(--mantine-color-dark-6);
  }
}

/* NavLink */

.mantine-NavLink-root {
  padding-left: 0;
  padding-right: 0;

  @mixin hover {
    background-color: transparent;
  }
}

/* Modal */

.mantine-Modal-content {
  @mixin dark {
    background-color: var(--mantine-color-dark-8);
  }
}

.mantine-Modal-header {
  @mixin dark {
    background-color: var(--mantine-color-dark-8);
  }
}

.color-dimmed {
  @mixin dark {
    color: var(--mantine-color-dimmed);
  }
}

/* Input */

.mantine-Input-input {
  @mixin dark {
    &[data-variant="default"] {
      background-color: var(--mantine-color-dark-8);
    }
  }
}

/* DropDown */

.mantine-Select-dropdown {
  @mixin dark {
    background-color: var(--mantine-color-dark-8);
  }
}

.ProseMirror {
  --mantine-spacing-md: 0px;
}

.mantine-Pagination-control {
  @mixin dark {
    &[data-active] {
      --pagination-active-color: var(--mantine-color-dark-9);
    }
  }
}

.mantine-RichTextEditor-toolbar {
  @mixin dark {
    background-color: var(--mantine-color-dark-8);
  }
}

.mantine-Paper-root {
  @mixin dark {
    background-color: var(--mantine-color-dark-8);
  }

  @mixin light {
    background-color: var(--mantine-color-gray-1);
  }
}

.tiptap a {
  color: var(--mantine-color-blue-3);
}

.mantine-Combobox-dropdown {
  @mixin dark {
    background-color: var(--mantine-color-dark-8);
  }
}

.mantine-HoverCard-dropdown {
  @mixin dark {
    background-color: var(--mantine-color-dark-8);
  }
}

.text-hover-underline {
  @mixin hover {
    text-decoration: underline;
  }
}

```
-------------------------------
[pnpm-workspace.yaml]

```yaml
packages:
  - "packages/*"
  - "playground/**"

```
-------------------------------
[release.ts]

```ts
#!/usr/bin/env tsx

/**
 * https://github.com/SchemaStore/schemastore/blob/master/src/schemas/json/package.json
 */

import fs from "node:fs";

// ============================================

type DependencyType = "prod" | "dev" | "peer";
const DependencyTypes: DependencyType[] = ["prod", "dev", "peer"];

class PackageJSON {
  #path: string;
  #data: Record<string, any> | undefined;

  constructor(path: string) {
    this.#path = path;
  }

  async #fileExists(): Promise<boolean> {
    try {
      await fs.promises.access(this.#path);
      return true;
    } catch (error) {
      return false;
    }
  }

  async load(): Promise<void> {
    try {
      const exist = await this.#fileExists();

      if (!exist) {
        throw new Error(`Package.json not found at ${this.#path}`);
      }

      const data = await fs.promises.readFile(this.#path, "utf-8");
      this.#data = JSON.parse(data);
    } catch (error) {
      console.error(`Error loading package.json from ${this.#path}:`, error);
      throw error;
    }
  }

  get data(): any {
    if (!this.#data) {
      throw new Error("Package.json data not loaded yet. Call load() first.");
    }

    return this.#data;
  }

  get name(): string {
    return this.data.name;
  }

  get version(): string {
    return this.data.version;
  }

  async setVersion(version: string): Promise<void> {
    this.data.version = version;
    await this.save();
  }

  getDependencies(
    type: DependencyType = "prod",
  ): Record<string, string> | null {
    switch (type) {
      case "prod":
        return this.data?.dependencies ?? null;

      case "dev":
        return this.data?.devDependencies ?? null;

      case "peer":
        return this.data?.peerDependencies ?? null;
    }
  }

  setDependencies(deps: Record<string, string>, type: DependencyType = "prod") {
    const exist = this.getDependencies(type);

    if (!exist) {
      return;
    }

    switch (type) {
      case "prod":
        this.data.dependencies = deps;
        break;

      case "dev":
        this.data.devDependencies = deps;
        break;

      case "peer":
        this.data.peerDependencies = deps;
        break;
    }
  }

  getDependency(pkg: string, type: DependencyType = "prod"): string | null {
    const exist = this.getDependencies(type);

    if (!exist) {
      return null;
    }

    return exist[pkg] ?? null;
  }

  async updateDependency(
    pkg: string,
    version: string,
    type: "prod" | "dev" | "peer" = "prod",
  ): Promise<void> {
    const exist = this.getDependency(pkg, type);

    if (!exist || exist === version) {
      return;
    }

    this.setDependencies(
      {
        ...this.getDependencies(type),
        [pkg]: version,
      },
      type,
    );

    await this.save();
  }

  async save(): Promise<void> {
    try {
      await fs.promises.writeFile(
        this.#path,
        JSON.stringify(this.data, null, 2),
      );
    } catch (error) {
      console.error(`Error saving package.json to ${this.#path}:`, error);
      throw error;
    }
  }
}

// ============================================

const CONFIG = {
  PACKAGES: [
    "./packages/blueprint",
    "./packages/blueprint_lib",
    "./packages/castle",
    "./packages/cobalt",
    "./packages/cobalt_animation",
    "./packages/gate",
    "./packages/gate_tan",
    "./packages/gate_next",
    "./packages/lib",
    "./packages/squid",
    "./packages/captcha",
  ],
} as const;

const updateDependencies = async (
  packages: Map<string, PackageJSON>,
  target: PackageJSON,
  constVersion?: string,
) => {
  for (const type of DependencyTypes) {
    const exist = target.getDependencies(type);

    if (exist) {
      for (const [dep, pkg] of packages) {
        await target.updateDependency(
          dep,
          constVersion ?? `^${pkg.version}`,
          type,
        );
      }
    }
  }
};

const main = async (cleanup?: boolean) => {
  const pkgs = new Map<string, PackageJSON>();

  for (const pkg of CONFIG.PACKAGES) {
    const pkgJSON = new PackageJSON(`${pkg}/package.json`);

    await pkgJSON.load();

    pkgs.set(pkgJSON.name, pkgJSON);
  }

  if (cleanup === true) {
    for (const [pkg, pkgJSON] of pkgs) {
      await updateDependencies(pkgs, pkgJSON, "workspace:*");
    }
  } else {
    for (const [pkg, pkgJSON] of pkgs) {
      await updateDependencies(pkgs, pkgJSON);
    }
  }
};

const args = process.argv.slice(2);

main(args.includes("--cleanup"))
  .then(() => {
    process.exit(0);
  })
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });

```
-------------------------------
[turbo.json]

```json
{
  "$schema": "https://turbo.build/schema.json",
  "ui": "tui",
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "inputs": ["$TURBO_DEFAULT$", ".env*"],
      "outputs": [".next/**", "!.next/cache/**", "./build/**", "./dist/**"]
    },
    "lint": {
      "dependsOn": ["^lint"]
    },
    "typecheck": {
      "dependsOn": ["^typecheck"]
    },
    "dev": {
      "cache": false,
      "persistent": true
    },
    "format": {
      "dependsOn": ["^format"],
      "inputs": ["**/*.{ts,tsx}"],
      "outputs": ["**/*.{ts,tsx}"]
    }
  }
}

```
-------------------------------